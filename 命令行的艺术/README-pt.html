<p>🌍<br><em><a href="README-cs.md">Čeština</a> ∙ <a href="README-de.md">Deutsch</a> ∙ <a href="README-el.md">Ελληνικά</a> ∙ <a href="README.md">English</a> ∙ <a href="README-es.md">Español</a> ∙ <a href="README-fr.md">Français</a> ∙ <a href="README-id.md">Indonesia</a> ∙ <a href="README-it.md">Italiano</a> ∙ <a href="README-ja.md">日本語</a> ∙ <a href="README-ko.md">한국어</a> ∙ <a href="README-pt.md">Português</a> ∙ <a href="README-ro.md">Română</a> ∙ <a href="README-ru.md">Русский</a> ∙ <a href="README-sl.md">Slovenščina</a> ∙ <a href="README-uk.md">Українська</a> ∙ <a href="README-zh.md">简体中文</a> ∙ <a href="README-zh-Hant.md">繁體中文</a></em></p>
<h1 id="A-arte-da-linha-de-comando"><a href="#A-arte-da-linha-de-comando" class="headerlink" title="A arte da linha de comando"></a>A arte da linha de comando</h1><ul>
<li><a href="#meta">Meta</a></li>
<li><a href="#básico">Básico</a></li>
<li><a href="#uso-diário">Uso diário</a></li>
<li><a href="#processamento-de-arquivos-e-dados">Processamento de arquivos e dados</a></li>
<li><a href="#debugs-do-sistema">Debugando o sistema</a></li>
<li><a href="#one-liners">One-liners</a></li>
<li><a href="#obscuros-mas-úteis">Obscuros mas úteis</a></li>
<li><a href="#mais-conteúdo">Mais conteúdo</a></li>
<li><a href="#aviso">Aviso</a></li>
</ul>
<p><img src="cowsay.png" alt="curl -s &#39;https://raw.githubusercontent.com/jlevy/the-art-of-command-line/master/README.md&#39; | egrep -o &#39;`\w+`&#39; | tr -d &#39;`&#39; | cowsay -W50"></p>
<p>Fluência na linha de comando é uma habilidade muitas vezes negligenciada ou considerada obsoleta, porém ela aumenta sua flexibilidade e produtividade como <em>desenvolvedor</em> de diversas maneiras, sutis ou não. Este texto descreve uma seleção de notas e dicas de uso da linha de comando que me parecem muito uteis, quando usando o Linux. Algumas dicas são elementares, e outras são mais específicas, sofisticadas ou obscuras. Esta página é curta, mas se você souber usar e lembrar todos os items que estão aqui, então você está mandando bem.</p>
<p>Muito do que está aqui <a href="http://www.quora.com/What-are-some-lesser-known-but-useful-Unix-commands">originalmente</a><br><a href="http://www.quora.com/What-are-the-most-useful-Swiss-army-knife-one-liners-on-Unix">apareceu</a><br>no <a href="http://www.quora.com/What-are-some-time-saving-tips-that-every-Linux-user-should-know">Quora</a>,<br>mas dado o interesse por lá, me pareceu importante usar o Github, onde pessoas mais talentosas do que eu, poderiam sugerir melhorias facilmente. Se você descobrir um erro ou algo que poderia ser melhorado, por favor abra um issue ou um PR! (E claro, por favor veja as `meta sections’ e PRs/issues existentes, primeiro.)</p>
<h2 id="Meta"><a href="#Meta" class="headerlink" title="Meta"></a>Meta</h2><p>Escopo:</p>
<ul>
<li>Este guia é destinado tanto aos iniciantes quanto aos usuários mais experientes. Os objetivos são <em>abrangência</em> (tudo que é importante), <em>especificidade</em> (dar exemplos concretos dos casos de usos mais comuns), e <em>concisão</em> (evitar coisas que não são tão essenciais ou digressões que você pode facilmente encontrar pela Internet). Todas as dicas são essenciais em alguma situação ou trazem uma economia notável de tempo em relação a outras alternativas.</li>
<li>Este guia é escrito para o Linux. Muitos, mas não todos os items, se aplicam igualmente para o MacOS (ou mesmo o Cygwin).</li>
<li>O foco está na interatividade com Bash, embora muitas dicas aqui sejam aplicáveis a outras `shells’ e também a scripts em Bash, em geral.</li>
<li>Incluímos tanto comandos no Unix “padrão”, quanto comandos que requeiram instalação de pacotes adicionais – desde que estes sejam importantes o suficiente para merecerem sua inclusão nessa lista.</li>
</ul>
<p>Notas:</p>
<ul>
<li>Para manter este guia em uma única página, o conteúdo implícito será incluído por referência. Você é competente o suficiente para verificar mais detalhes em outros lugares, desde que você já tenha entendido a ideia ou saiba o que procurar no Google. Use <code>apt-get</code>, <code>yum</code>, <code>dnf</code>, <code>pacman</code>, <code>pip</code> ou <code>brew</code> (quando adequado) para instalar novos programas.</li>
<li>Use <a href="http://explainshell.com/">Explainshell</a> para encontrar informações úteis sobre o que fazem os comandos, as opções, pipes, etc.</li>
</ul>
<h2 id="Basico"><a href="#Basico" class="headerlink" title="Básico"></a>Básico</h2><ul>
<li><p>Aprenda o básico sobre Bash. Na verdade, digite <code>man bash</code> e pelo menos entenda superficialmente o seu funcionamento; é bastante simples de ler e nem é tão grande assim. Shells alternativas podem ser legais, mas Bash é a mais poderosa e sempre está disponível (aprender <em>somente</em> zsh, fish, etc, é tentador quando você usa o seu próprio notebook, mas restringe você em muitas situações, por exemplo quando você quer  usar servidores de outros).</p>
</li>
<li><p>Aprenda bem pelo menos um editor de texto tradicional. Idealmente o Vim (<code>vi</code>), já que nenhum outro funciona tão bem nos   terminais aleatórios que a gente encontra por aí (mesmo que você prefira usar o Emacs, um IDE, ou um editor hipster a maior parte  do tempo).</p>
</li>
<li><p>Saiba como ler a documentação com o <code>man</code> (para os curiosos, <code>man man</code> lista os números das seções, por exemplo, 1 se refere aos comandos “regulares”, 5 é sobre arquivos/convenções, e 8 diz respeito a administração). Procure outros documentos do manual com o <code>apropos</code>. Saiba que alguns dos comandos não são executáveis, mas sim built-ins (embutidos) no bash, pra esses você poderá conseguir ajuda com <code>help</code> e <code>help -d</code>.</p>
</li>
<li><p>Aprenda como fazer redirecionamento de saída e entrada usando <code>&gt;</code> e <code>&lt;</code> e pipes usando <code>|</code>. Aprenda sobre o stdout e stdin.</p>
</li>
<li><p>Aprenda sobre a expansão de arquivos glob com <code>*</code> ( e talvez <code>?</code> e <code>{</code>…<code>}</code>) e entenda as diferenças entre aspas duplas <code>&quot;</code> e aspas simples <code>&#39;</code>. (Veja mais em variáveis de expansão abaixo.)</p>
</li>
<li><p>Se familiarize com o gerenciamento de jobs em Bash: <code>&amp;</code>, <strong>ctrl-z</strong>, <strong>ctrl-c</strong>, <code>jobs</code>, <code>fg</code>, <code>bg</code>, <code>kill</code>, etc.</p>
</li>
<li><p>Aprenda <code>ssh</code>, e o básico de autenticação sem senha, através do <code>ssh-agent</code>, <code>ssh-add</code>, etc.</p>
</li>
<li><p>Gerenciamento básico de arquivos: <code>ls</code> e <code>ls -l</code> (em particular, aprenda o que cada coluna no <code>ls -l</code> significa), <code>less</code>, <code>head</code>, <code>tail</code> e <code>tail -f</code> (ou melhor ainda, <code>less +F</code>), <code>ln</code> e <code>ln -s</code>(aprenda as diferenças e vantagens de soft links comparados a hard links), <code>chown</code>, <code>chmod</code>, <code>du</code> (para um rápido resumo do uso do disco: <code>du -sk *</code>). Para gerenciamento do sistema de arquivos, <code>df</code>, <code>mount</code>, <code>fdisk</code>, <code>mkfs</code>, <code>lsblk</code>.</p>
</li>
<li><p>Gerenciamento básico da rede: <code>ip</code> ou <code>ifconfig</code>, <code>dig</code>.</p>
</li>
<li><p>Saiba bem como usar expressões regulares, e as várias flags para <code>grep</code>/<code>egrep</code>. As <code>-i</code>, <code>-o</code>, <code>-A</code>, e <code>-B</code> são opções que é importante conhecer.</p>
</li>
<li><p>Aprenda a usar <code>apt-get</code>, <code>yum</code>, <code>dnf</code> ou <code>pacman</code> (dependendo da distribuição) para procurar e instalar pacotes. E garanta que você possui o <code>pip</code> para instalar ferramentas baseadas em Python (algumas das abaixo são mais fáceis de instalar através do <code>pip</code>).</p>
</li>
</ul>
<h2 id="Uso-diario"><a href="#Uso-diario" class="headerlink" title="Uso diário"></a>Uso diário</h2><ul>
<li><p>Usando Bash, use <strong>Tab</strong> para completar argumentos e <strong>ctrl-r</strong> para pesquisar através a história dos comandos.</p>
</li>
<li><p>Em Bash, utilize <strong>ctrl-w</strong> para deletar a última palavra, e <strong>ctrl-u</strong> para deletar tudo e voltar para o início da linha. Use <strong>alt-b</strong> e <strong>alt-f</strong> para se mover por palavras, <strong>ctrl-k</strong> para apagar até o final da linha, <strong>ctrl-l</strong> para limpar a tela. Consulte <code>man readline</code> para todos os keybindings padrões do Bash. Existem muitos. Por exemplo <strong>alt-.</strong> circula através dos argumentos anteriores, e <strong>alt-*</strong> expande um glob.</p>
</li>
<li><p>Alternativamente, se você adora os keybinds do vi, use <code>set -o vi</code>.</p>
</li>
<li><p>Para ver os comandos recentes, <code>history</code>. Existem também muitas abreviações como <code>!$</code> (último argumento) e <code>!!</code> último comando, embora estes sejam muitas vezes facilmente substituídos por <strong>ctrl-r</strong> e <strong>alt-.</strong>.</p>
</li>
<li><p>Pra voltar para o diretório anterior de trabalho: <code>cd -</code>.</p>
</li>
<li><p>Se você está na metade do caminho ao digitar um comando, mas mudou de ideia, tecle <strong>alt-#</strong> para adicionar um <code>#</code> ao início da linha e definir esta como um comentário (ou use <strong>ctrl-a</strong>. <strong>#</strong>. <strong>enter</strong>). Mais tarde você poderá recuperar o comando através da <code>history</code>.</p>
</li>
<li><p>Use <code>xargs</code> (ou <code>parallel</code>). Estes são muito poderosos. Note que você pode controlar como os vários items são executados por linha (<code>-L</code>) assim como o paralelismo (<code>-P</code>). Se você não tem certeza se isto é a coisa certa a se fazer, use <code>xargs echo</code> primeiro. O <code>-I{}</code> também é muito útil. Exemplos:</p>
<pre><code class="bash">find . -name <span class="string">'*.py'</span> | xargs grep some_function
cat hosts | xargs -I{} ssh root@{} hostname
</code></pre>
</li>
<li><p><code>pstree -p</code> é um modo de visualização muito útil da árvore de processos.</p>
</li>
<li><p>Use <code>pgrep</code> e <code>pkill</code> para procurar ou sinalizar os processo pelo seu nome (<code>-f</code> é muito útil).</p>
</li>
<li><p>Saiba os vários sinais que você pode enviar para um processo. Por exemplo, para suspender um processo, use <code>kill -STOP [pid]</code>. Para saber a lista completas dos sinais, veja <code>man 7 signal</code>.</p>
</li>
<li><p>Use <code>nohup</code> ou <code>disown</code> se você deseja por o processo no background, executando para sempre.</p>
</li>
<li><p>Verifique quais processos estão escutando através de <code>netstat -lntp</code> ou <code>ss -plat</code> (para TCP; adicione <code>-u</code> para UDP).</p>
</li>
<li><p>Veja também <code>lsof</code> para abrir sockets e arquivos.</p>
</li>
<li><p>Em scripts Bash, use <code>set -x</code> para debugar a saída. Utilize modos estritos sempre que for possível. Use <code>set -e</code> para abortar em caso de erros. Use <code>set -o pipefail</code> para também ser restrito a respeito dos erros (embora este tópico seja um pouco sútil). Para scripts mais desenvolvidos, use também <code>trap</code>.</p>
</li>
<li><p>Em Bash scripts, subshells (escrito com parênteses) são formas convenientes de agrupar comandos. Um exemplo comum é temporariamente se mover para um diretório de trabalho diferente, e.g.</p>
<pre><code class="bash"><span class="comment"># faz algo no diretório corrente</span>
(<span class="built_in">cd</span> /some/other/dir &amp;&amp; other-command)
<span class="comment"># continua no diretório atual</span>
</code></pre>
</li>
<li><p>No Bash, note que existem muitos tipos de variáveis de expansão. Verificando a existência de uma variável: <code>${name:?error_messages}</code>. Por exemplo, se um script Bash requer um único argumento, apenas escreva <code>input_file=${1:?usage: $0 input_file}</code>. Expansões aritméticas: <code>i=$(( (i + 1) % 5 ))</code>. Sequências: <code>{1..10}</code>. Aparando as strings: <code>${var%suffix}</code> e <code>${var#prefix}</code>. Por exemplo, se <code>var=foo.pdf</code>, então <code>echo ${var%.pdf}.txt</code> imprime <code>foo.txt</code>.</p>
</li>
<li><p>A saída de um comando pode ser tratada como um arquivo através <code>&lt;(algum comando)</code>. Por exemplo, comparar um arquivo local <code>/etc/hosts</code> com um remoto:</p>
<pre><code class="sh">diff /etc/hosts &lt;(ssh somehost cat /etc/hosts)
</code></pre>
</li>
<li><p>Saiba sobre “documentos aqui” no Bash, como em <code>cat &lt;&lt;EOF ...</code>.</p>
</li>
<li><p>No Bash, redirecionar a saída padrão (stdout) e a saída de erro padrão (stderr) através de: <code>algum-comando &gt;logfile 2&gt; $1</code>. Muitas vezes, para garantir que um comando não deixa um arquivo aberto para manipular a entrada padrão, digitando isso no terminal que você está, é uma boa prática adicionar um <code>&lt;/dev/null</code>.</p>
</li>
<li><p>Use <code>man ascii</code> para visualizar a tabela ASCII, com valores hexadecimais e decimais. Para informações gerais sobre codificações, <code>man unicode</code>, <code>man utf-8</code>, e <code>man latin1</code> são úteis.</p>
</li>
<li><p>Use <code>screen</code> ou <a href="https://tmux.github.io/"><code>tmux</code></a> para multiplexar as telas, especialmente útil em sessões ssh remotas e para desplugar e replugar a uma sessão. Uma alternativa mais simples para a persistência de uma sessão é <code>dtach</code>.</p>
</li>
<li><p>No ssh, saber como realizar um túnel de portas com <code>-L</code> ou <code>-D</code> (e ocasionalmente <code>-R</code>) é útil, para por exemplo acessar sites webs de um servidor remoto.</p>
</li>
<li><p>Pode ser útil realizar algumas otimizações em suas configurações do ssh; por exemplo, o arquivo <code>~/.ssh/config</code> contém configurações para evitar que conexões sejam dropadas em certos ambientes de rede, use compressão (muito útil quando se está usando o scp através de uma conexão lenta), e multiplexação de canais do mesmo servidor com um arquivo de controle local:</p>
<pre><code>TCPKeepAlive=yes
ServerAliveInterval=15
ServerAliveCountMax=6
Compression=yes
ControlMaster auto
ControlPath /tmp/%r@%h:%p
ControlPersist yes
</code></pre></li>
<li><p>Algumas outras opções relevantes para o ssh tem problemas de segurança e devem ser habilitadas com muito cuidado, por exemplo somente para subrede ou host ou em redes confiaveis (de confiança): <code>StrictHostKeyChecking=no</code>, <code>ForwardAgent=yes</code></p>
</li>
<li><p>Para conseguir as permissões em arquivo em forma octal, o que é útil para a configuraçao do sistema mas não disponível no <code>ls</code> e fácil de se confundir, use algo como:</p>
<pre><code class="sh"><span class="built_in">stat</span> -c <span class="string">'%A %a %n'</span> /etc/timezone
</code></pre>
</li>
<li><p>Para seleção interativas de valores da saída de outro comando, use <a href="https://github.com/mooz/percol"><code>percol</code></a>.</p>
</li>
<li><p>Para interação com arquivos baseados na saída de outro comando (like <code>git</code>), use <code>fpp</code> (<a href="https://github.com/facebook/PathPicker">PathPicker</a>).</p>
</li>
<li><p>Para um simples servidor web para todos os arquivos do diretório atual (e subdiretórios), disponível para alguém na sua rede, use:<br><code>python -m SimpleHTTPServer 7777</code> (para a porta 7777 e Python 2) e <code>python -m http.server 7777</code> (para a porta 7777 e Python 3).</p>
</li>
</ul>
<h2 id="Processamento-de-arquivos-e-dados"><a href="#Processamento-de-arquivos-e-dados" class="headerlink" title="Processamento de arquivos e dados"></a>Processamento de arquivos e dados</h2><ul>
<li><p>Para localizar um arquivo pelo nome no diretório atual, <code>find . -iname &#39;*something*&#39;</code> (ou similar). Para procurar um arquivo em qualquer lugar pelo nome, use <code>locate something</code> (mas tenha em mente que o <code>updatedb</code> pode não ter indexado arquivos criados recentemente).</p>
</li>
<li><p>Para uma busca mais geral através de arquivos de dados ou de códigos (mais avançado do que <code>grep -r</code>), use <a href="https://github.com/ggreer/the_silver_searcher"><code>ag</code></a>.</p>
</li>
<li><p>Para converter HTML para texto: <code>lynx -dump -stdin</code>.</p>
</li>
<li><p>Para Markdown, HTML, e todos os demais tipos de conversão de documentos, tente <a href="http://pandoc.org/"><code>pandoc</code></a>.</p>
</li>
<li><p>Se você precisa manipular XML, <code>xmlstarlet</code> é antigo mas é bom.</p>
</li>
<li><p>Para JSON, <code>jq</code>.</p>
</li>
<li><p>Para Excel ou arquivos CSV, <a href="https://github.com/onyxfish/csvkit">csvkit</a> que provê <code>in2csv</code>, <code>csvcut</code>, <code>csvjoin</code>, <code>csvgrep</code>, etc.</p>
</li>
<li><p>Para a Amazon S3, <a href="https://github.com/s3tools/s3cmd"><code>s3cmd</code></a> é uma forma conveniente e <a href="https://github.com/bloomreach/s4cmd"><code>s4cmd</code></a> é mais rápido. O <a href="https://github.com/aws/aws-cli"><code>aws</code></a> da amazon é essencial para outras tarefas relacionadas.</p>
</li>
<li><p>Aprenda a respeito do <code>sort</code> e <code>uniq</code>, incluindo as opções do <code>-u</code> e <code>-d</code> do <code>uniq</code> – veja os one-liners abaixo. Veja também <code>comm</code>.</p>
</li>
<li><p>Aprenda a respeito do <code>cut</code>, <code>paste</code>, e <code>join</code> para manipular arquivos de texto. Muitas pessoas usam <code>cut</code> mas esquecem do <code>join</code>.</p>
</li>
<li><p>Aprenda a respeito do <code>wc</code> para contar novas linhas (<code>-l</code>), caracteres (<code>-m</code>), palavras (<code>-m</code>) e bytes (<code>-c</code>).</p>
</li>
<li><p>Aprenda a respeito do <code>tee</code> para copiar da entrada padrão (stdin) para um arquivo e também para a saída padrão (stdout), como no <code>ls -al | tee file.txt</code>.</p>
</li>
<li><p>Aprenda que as configurações de localização afetam várias ferramentas da linha de comando em formas sutis, incluindo a ordem da ordenação e performance. A maioria das instalações do Linux irá definir <code>LANG</code> ou outras variáveis de localização para o ingles dos USA. Mas esteja ciente de que a ordem da ordenação irá mudar, caso você altere a localização. E saiba que as rotinas do i18n podem fazer o <code>sort</code> ou outros comandos executarem <em>muitas vezes</em> mais devagar. Em algumas situações (como o conjunto de operações ou as operações únicas abaixo) você pode seguramente eliminar a lentidão das rotinas do i18n inteiramente e usar a ordem baseada nos bytes, usando <code>export LC_ALL=C</code>.</p>
</li>
<li><p>Aprenda o básico sobre <code>awk</code> e <code>sed</code> para obtenção de informações simples de dados. Por exemplo, somar todos os números na terceira coluna de um arquivo de texto: <code>awk &#39;{ x += $3 } END { print x }&#39;</code>. Isto é provavelmente 3X mais rápido e 3X mais curto do que o equivalente em Python.</p>
</li>
<li><p>Para substituir todas as ocorrências de uma string em um lugar, em um ou mais arquivos:</p>
<pre><code class="sh">perl -pi.bak -e <span class="string">'s/old-string/new-string/g'</span> my-files-*.txt
</code></pre>
</li>
<li><p>Para renomear muitos arquivos de uma vez, de acordo com um padrão, use <code>rename</code>. Para renomeações mais complexas, <a href="https://github.com/jlevy/repren"><code>repren</code></a> pode ajudar.</p>
<pre><code class="sh"><span class="comment"># Recuperar arquivos de backup foo.bak -&gt; foo:</span>
rename <span class="string">'s/\.bak$//'</span> *.bak
<span class="comment"># Renomea completamente o nome dos arquivos, diretórios, e outros conteúdos foo -&gt; bar:</span>
repren --full --preserve-case --from foo --to bar .
</code></pre>
</li>
<li><p>Utilize o <code>shuf</code> para embaralhar ou selecionar linhas randoms de um arquivo.</p>
</li>
<li><p>Para as opções do <code>sort</code>. Aprenda com as chaves (<code>-t</code> e <code>-k</code>). Em particular, saiba que precisa escrever <code>-k1,1</code> para ordenar somente o primeiro campo; <code>-k1</code> significa ordenar de acordo com a linha inteira.</p>
</li>
<li><p>Ordenação estável (<code>sort -s</code>) pode ser útil. Por exemplo, para ordenar primeiramente pelo campo 2, então secundariamente pelo campo 1, você pode usar <code>sort -k1,1 | sort -s -k2,2</code>.</p>
</li>
<li><p>Se você precisa escrever literalmente um tab na linha de comando no Bash (por exemplo, para o argumento -t do <code>sort</code>), pressione <strong>ctrl-v</strong> <strong>[Tab]</strong> ou escreva <code>$&#39;\t&#39;</code> (o último é melhor pois você pode copiar e colar ele).</p>
</li>
<li><p>As ferramentas padrão para extrair patches de códigos fonte são <code>diff</code>e <code>patch</code>. Veja também <code>diffstat</code> para um resumo de estatísticas de um diff. Note que <code>diff -r</code> funciona para diretórios inteiros. Use <code>diff -r tree1 tree2 | diffstat</code>  para um resumo das alterações.</p>
</li>
<li><p>Para arquivos binários, use <code>hd</code> para um simples dump hexadecimal e <code>bvi</code> para edição binária.</p>
</li>
<li><p>Também para arquivos binários, <code>strings</code> (mais <code>grep</code>, etc.) deixa você encontrar pedaços de texto.</p>
</li>
<li><p>Para diffs binários (compressão delta), use <code>xdelta3.</code></p>
</li>
<li><p>Para converter a codificação de textos, tente <code>iconv</code>. Ou <code>uconv</code> para uso mais avançado; Este suporta algumas funcionalidades avançadas do Unicode. Por exemplo, este comando transforma o texto para minúsculo e remove todos os acentos (expandindo e removendo eles):</p>
<pre><code class="sh">uconv -f utf-8 -t utf-8 -x <span class="string">'::Any-Lower; ::Any-NFD; [:Nonspacing Mark:] &gt;; ::Any-NFC; '</span> &lt; input.txt &gt; output.txt
</code></pre>
</li>
<li><p>Para dividir um arquivo em pedaços, veja <code>split</code> (para dividir por tamanho) e <code>csplit</code> (para dividir por um padrão).</p>
</li>
</ul>
<p>Use <code>zsless</code>, <code>zmore</code>, <code>zcat</code>, and <code>zgrep</code> para manipular arquivos comprimidos.</p>
<h2 id="Debugando-o-sistema"><a href="#Debugando-o-sistema" class="headerlink" title="Debugando o sistema"></a>Debugando o sistema</h2><ul>
<li><p>Para web debug, <code>curl</code> e <code>curl -I</code> são úteis, ou os equivalentes <code>wget</code>, or uma alternativa mais moderna <a href="https://github.com/jakubroztocil/httpie"><code>httpie</code></a>.</p>
</li>
<li><p>Para saber o status do disco/cpu/rede, use <code>iostat</code>, <code>netstat</code>, <code>top</code> (ou o <code>htop</code> como alternativa melhor), e (especialmente) <code>dstat</code>. Bom para obter uma ideia rápida do que está acontecendo em um sistema.</p>
</li>
<li><p>Para um resumo mais aprofundado do sistema, use <a href="https://github.com/nicolargo/glances"><code>glances</code></a>. Este lhe apresenta vários níveis de estatísticas do sistema em uma janela do terminal. Muito útil para uma rápida verificação em vários subsistemas.</p>
</li>
<li><p>Para saber o status da memória, execute e entenda a saída do <code>free</code> <code>vmstat</code>. Em particular, esteja ciente de que o valor “cached”, é mantido pelo kernel Linux como um arquivo de cache, então este efetivamente conta como um valor de memória disponível.</p>
</li>
<li><p>Debugar um sistema java é uma outra historia, mas um simples truque nas máquinas virtuais Oracle ou algum outro tipo de JVM é que você pode executar <code>kill -3 &lt;pid&gt;</code> e um completo rastreamento da pilha(stack trace) e resumo do heap (incluindo detalhes geracionais do garbage collector, os quais podem ser altamente informativos) serão vazados para stderr/logs.</p>
</li>
<li><p>Use <a href="http://www.bitwizard.nl/mtr/"><code>mtr</code></a> como uma melhor alternativa ao traceroute, para identificar problemas na rede.</p>
</li>
<li><p>Para verificar o porque de um disco estar cheio, <a href="https://dev.yorhel.nl/ncdu"><code>ncdu</code></a> economiza bastante tempo em comparação aos comandos usuais como <code>du -sh *</code>.</p>
</li>
<li><p>Para procurar qual socket ou processo está utilizando a banda de rede, tente <a href="http://www.ex-parrot.com/~pdw/iftop/"><code>iftop</code></a> ou <a href="https://github.com/raboof/nethogs"><code>nethogs</code></a>.</p>
</li>
<li><p>A ferramenta <code>ab</code> (que vem com o Apache) é muito útil para verificação rápida da performance do servidor web. Para mais complexos testes de carga, tente <code>siege</code>.</p>
</li>
<li><p>Para debugs mais sérios da rede, <a href="https://wireshark.org/"><code>wireshark</code></a>, <a href="https://www.wireshark.org/docs/wsug_html_chunked/AppToolstshark.html"><code>tshark</code></a>, ou <a href="http://ngrep.sourceforge.net/"><code>ngrep</code></a>.</p>
</li>
<li><p>Aprenda a respeito do <code>strace</code>e <code>ltrace</code>. Estes podem ser úteis se um programa está falhando, travado, ou quebrando, e você não sabe o por que, ou se você quer obter uma ideia geral da performance. Note que a opção de perfil (<code>-c</code>), e a habilidade de se plugar a um processo em execução (<code>-p</code>).</p>
</li>
<li><p>Aprenda a respeito do <code>ldd</code> para verificar bibliotecas compartilhadas, e etc.</p>
</li>
<li><p>Aprenda sobre como se conectar a um processo em execução com o <code>gdb</code> e obter informações sobre a stack trace.</p>
</li>
<li><p>Utilize <code>/proc</code>. Este é incrivelmente útil em algumas vezes quando se deseja debugar problemas ao vivo. Exemplos: <code>/proc/cpuinfo</code>, <code>/proc/xxx/cwd</code>, <code>/proc/xxx/exe</code>, <code>/proc/xxx/fd/</code>, <code>/proc/xxx/smaps</code>.</p>
</li>
<li><p>Quando estiver debugando o porque de algo ter dado errado no passado, <a href="http://sebastien.godard.pagesperso-orange.fr/"><code>sar</code></a> pode ser de muita utilidade. Ele exibe as estatísticas históricas da CPU, memória, rede e etc.</p>
</li>
<li><p>Para análises de performance mais profundas do sistema, dê uma olhada em <code>stap</code> (<a href="https://sourceware.org/systemtap/wiki">SystemTap</a>), <a href="http://en.wikipedia.org/wiki/Perf_(Linux"><code>perf</code></a>), e <a href="https://github.com/draios/sysdig"><code>sysdig</code></a>.</p>
</li>
<li><p>Confirme qual a sua distribuição do Linux usando (funciona na maioria das distros): <code>lsb_release -a</code>.</p>
</li>
<li><p>Use <code>dmesg</code> sempre que algo estiver agindo de maneira estranha (isto pode ser um problema de hardware ou problema de driver).</p>
</li>
</ul>
<h2 id="One-liners"><a href="#One-liners" class="headerlink" title="One-liners"></a>One-liners</h2><p>Alguns exemplos de como reunir os comandos.</p>
<ul>
<li><p>O seguinte é notavelmente e frequentemente útil: muitas vezes você quer obter a interseção, união e a diferença de arquivos de texto através de <code>sort</code>/<code>uniq</code>. Suponha que <code>a</code> e <code>b</code> são arquivos de texto que são “uniqued” únicos. Esse modo é rápido, e funciona em arquivos de tamanhos arbitrários, podem até possuírem gigabytes. (Sorting não é limitado por memória, embora você possa precisar usar a opção <code>-T</code> se <code>/tmp</code> está em uma partição pequena.) Veja também a nota sobre <code>LC_ALL</code> acima e as opções <code>-u</code> do <code>sort</code>(vamos deixar isso claro abaixo).</p>
<pre><code class="sh">cat a b | sort | uniq &gt; c   <span class="comment"># c is a union b</span>
cat a b | sort | uniq -d &gt; c   <span class="comment"># c is a intersect b</span>
cat a b b | sort | uniq -u &gt; c   <span class="comment"># c is set difference a - b</span>
</code></pre>
</li>
<li><p>Use <code>grep . *</code> para visualmente examinar todo o conteúdo de todos os arquivos de um diretório, por exemplo, para diretórios com arquivos de configurações, como <code>/sys</code>, <code>/proc</code>, <code>/etc</code>.</p>
</li>
</ul>
<ul>
<li><p>Somar todos os números em uma terceira coluna de um arquivo de texto (isto é provavelmente 3X mais rápido e 3X menos linhas de código do que o equivalente em Python).</p>
<pre><code class="sh">awk <span class="string">'{ x += $3 } END { print x }'</span> myfile
</code></pre>
</li>
<li><p>Se você quer visualizar tamanhos/datas em uma árvore de arquivos, isto é como um <code>ls -l</code> recursivo, mas é mais fácil de ler do que <code>ls -lR</code>:</p>
<pre><code class="sh">find . -<span class="built_in">type</span> f -ls
</code></pre>
</li>
<li><p>Utilize <code>xargs</code> ou <code>parallel</code> sempre que você puder. Note que você pode controlar quantos item é executado por linha (<code>-L</code>) assim como o paralelismo (<code>-P</code>). Se você não tem certeza de que esta é a coisa certa a se fazer, utilize <code>xargs echo</code> primeiro.</p>
<pre><code class="sh">find . -name <span class="string">'*.py'</span> | xargs grep some_function
cat hosts | xargs -I{} ssh root@{} hostname
</code></pre>
</li>
<li><p>Digamos que você tenha um arquivo de texto, como um log do servidor web, e um certo valor que aparece em algumas linhas, como por exemplo o parâmetro <code>acct_id</code> que está presente na URL. Se você quer um cálculo de quantas requisições para este <code>acct_id</code>.</p>
<pre><code class="sh">cat access.log | egrep -o <span class="string">'acct_id=[0-9]+'</span> | cut -d= -f2 | sort | uniq -c | sort -rn
</code></pre>
</li>
<li><p>Execute esta função para obter uma dica random deste documento (analisa a sintaxe Markdown e extrai um item)</p>
<pre><code class="sh"><span class="keyword">function</span> <span class="function"><span class="title">taocl</span></span>() {
  curl -s https://raw.githubusercontent.com/jlevy/the-art-of-command-line/master/README-pt.md |
    pandoc -f markdown -t html |
    xmlstarlet fo --html --dropdtd |
    xmlstarlet sel -t -v <span class="string">"(html/body/ul/li[count(p)&gt;0])[<span class="variable">$RANDOM</span> mod last()+1]"</span> |
    xmlstarlet unesc | fmt -80
}
</code></pre>
</li>
</ul>
<h2 id="Obscuros-mas-uteis"><a href="#Obscuros-mas-uteis" class="headerlink" title="Obscuros mas úteis"></a>Obscuros mas úteis</h2><ul>
<li><p><code>expr</code>: executa operações boleanas ou aritméticas ou avalia expressões regulares.</p>
</li>
<li><p><code>m4</code>: simples processador de macros.</p>
</li>
<li><p><code>yes</code>: imprime uma string muitas vezes.</p>
</li>
<li><p><code>cal</code>: calendário legal.</p>
</li>
<li><p><code>env</code>: executa um comando (útil em scripts).</p>
</li>
<li><p><code>printenv</code>: imprime as variáveis de ambiente (útil em debug e scripts).</p>
</li>
<li><p><code>look</code>: procura palavras inglesas (ou linhas em um arquivo) começando com uma string.</p>
</li>
<li><p><code>cut</code> e <code>paste</code> e <code>join</code>: manipulação de dados.</p>
</li>
<li><p><code>fmt</code>: formata parágrafos de texto.</p>
</li>
<li><p><code>pr</code>: formata textos em páginas/colunas.</p>
</li>
<li><p><code>fold</code>: envolve linhas de texto.</p>
</li>
<li><p><code>column</code>: formata texto em colunas ou tabelas.</p>
</li>
<li><p><code>expand</code> e <code>unexpand</code>: converte entre tabs e espaços.</p>
</li>
<li><p><code>nl</code>: adiciona números as linhas.</p>
</li>
<li><p><code>seq</code>: imprime números.</p>
</li>
<li><p><code>bc</code>: calculadora.</p>
</li>
<li><p><code>factor</code>: fatora inteiros.</p>
</li>
<li><p><code>gpg</code>: criptografa e assina arquivos.</p>
</li>
<li><p><code>toe</code>: tabela de entradas dos tipos de terminais.</p>
</li>
<li><p><code>nc</code>: ferramenta de debug de rede e transferência de dados.</p>
</li>
<li><p><code>socat</code>: socket relay e encaminhamento de portas tcp (similar ao <code>netcat</code>)</p>
</li>
<li><p><code>slurm</code>: visualização do tráfego da rede.</p>
</li>
<li><p><code>dd</code>: move os dados entre arquivos ou dispositivos.</p>
</li>
<li><p><code>file</code>: identifica o tipo do arquivo.</p>
</li>
<li><p><code>tree</code>: mostra os diretórios e subdiretórios como um árvore de dependências; como <code>ls</code> mas recursivo.</p>
</li>
<li><p><code>stat</code>: informações do arquivo.</p>
</li>
<li><p><code>tac</code>: imprime arquivos na ordem reversa.</p>
</li>
<li><p><code>shuf</code>: seleção random de linhas de um arquivo.</p>
</li>
<li><p><code>comm</code>: compara uma lista de arquivos ordenadas linha por linha.</p>
</li>
<li><p><code>pv</code>: monitora o progresso dos dados através de um pipe.</p>
</li>
<li><p><code>hd</code> e <code>bvi</code>: dump ou edita arquivos binários.</p>
</li>
<li><p><code>strings</code>: extrai texto de arquivos binários.</p>
</li>
<li><p><code>tr</code>: tradução e manipulação de caracteres.</p>
</li>
<li><p><code>iconv</code> ou <code>uconv</code>: conversor de codificações de texto.</p>
</li>
<li><p><code>split</code> e <code>csplit</code>: divisão de arquivos.</p>
</li>
<li><p><code>units</code>: conversor de unidades e cálculos; converte furlongs por quinzena para twips per blink (veja também <code>/usr/share/units/definitions.units</code>)</p>
</li>
<li><p><code>7z</code>: Compressor de arquivos de alto desempenho.</p>
</li>
<li><p><code>ldd</code>: informações dinâmicas das bibliotecas.</p>
</li>
<li><p><code>nm</code>: símbolos de arquivos objetos.</p>
</li>
<li><p><code>ab</code>: benchmarking para web servers.</p>
</li>
<li><p><code>strace</code>: Debug para chamadas de sistema.</p>
</li>
<li><p><a href="http://www.bitwizard.nl/mtr/"><code>mtr</code></a>: melhor traceroute para debugar a rede.</p>
</li>
<li><p><code>cssh</code>: Visualização concorrente da shell.</p>
</li>
<li><p><code>rsync</code>: Sincroniza arquivos e pastas através do SSH.</p>
</li>
<li><p><a href="https://wireshark.org/"><code>wireshark</code></a> e <a href="https://www.wireshark.org/docs/wsug_html_chunked/AppToolstshark.html"><code>tshark</code></a>: captura de pacotes e debug de rede.</p>
</li>
<li><p><a href="http://ngrep.sourceforge.net/"><code>ngrep</code></a>: grep para a camada de rede.</p>
</li>
<li><p><code>host</code> e <code>dig</code>: Consultas DNS.</p>
</li>
<li><p><code>lsof</code>: Arquivo de descritores dos processos e informações dos sockets.</p>
</li>
<li><p><code>dstat</code>: Estatísticas úteis do sistema.</p>
</li>
<li><p><a href="https://github.com/nicolargo/glances"><code>glances</code></a>: Resumo de alto nível, de multi subsistemas.</p>
</li>
<li><p><code>iostat</code>: Estatísticas de uso do CPU e do disco.</p>
</li>
<li><p><code>htop</code>: Versão do top melhorada.</p>
</li>
<li><p><code>last</code>: histórico de logins.</p>
</li>
<li><p><code>w</code>: quem está logado.</p>
</li>
<li><p><code>id</code>: Informações sobre a identidade do user/group.</p>
</li>
<li><p><a href="http://sebastien.godard.pagesperso-orange.fr/"><code>sar</code></a>: histórico dos estados do sistema.</p>
</li>
<li><p><a href="http://www.ex-parrot.com/~pdw/iftop/"><code>iftop</code></a> ou <a href="https://github.com/raboof/nethogs"><code>nethogs</code></a>: Utilização da rede por sockets ou processos.</p>
</li>
<li><p><code>ss</code>: Estatísticas dos sockets.</p>
</li>
<li><p><code>dmesg</code>: Mensagens de erro do sistema e do boot.</p>
</li>
<li><p><code>hdparm</code>: Manipulação/performance de discos SATA/ATA.</p>
</li>
<li><p><code>lsblk</code>: Lista os blocos dos dispositivos: uma visualização em forma de árvore dos seus discos e partições do disco.</p>
</li>
<li><p><code>lshw</code> e <code>lspci</code>: informações do hardware, incluindo RAID, gráficos, etc.</p>
</li>
<li><p><code>fortune</code>, <code>ddate</code>, e <code>sl</code>: um, bem, isto depende de você considerar locomotivas a vapor e citações Zippy “úteis”.</p>
</li>
</ul>
<h2 id="Mais-conteudo"><a href="#Mais-conteudo" class="headerlink" title="Mais conteúdo"></a>Mais conteúdo</h2><ul>
<li><a href="https://github.com/alebcay/awesome-shell">awesome-shell</a>: Uma lista refinada de ferramentas da shell e outros recursos.</li>
<li><a href="http://redsymbol.net/articles/unofficial-bash-strict-mode/">Strict mode</a> para escrever shell scripts melhores.</li>
</ul>
<h2 id="Aviso"><a href="#Aviso" class="headerlink" title="Aviso"></a>Aviso</h2><p>Com a exceção de tarefas muito pequenas,  código é normalmente escrito para que outros possam ler. Junto com o poder vem a responsabilidade. O fato de você <em>poder</em> fazer algo usando Bash não significa necessariamente  que você deve! ;)</p>
<h2 id="Licenca"><a href="#Licenca" class="headerlink" title="Licença"></a>Licença</h2><p><a href="http://creativecommons.org/licenses/by-sa/4.0/"><img src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png" alt="Creative Commons License"></a></p>
<p>Este trabalho está licenciado com uma <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</p>
