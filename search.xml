<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%9A%84%E8%89%BA%E6%9C%AF%2FREADME-zh-Hant%2F</url>
    <content type="text"><![CDATA[🌍Čeština ∙ Deutsch ∙ Ελληνικά ∙ English ∙ Español ∙ Français ∙ Indonesia ∙ Italiano ∙ 日本語 ∙ 한국어 ∙ Português ∙ Română ∙ Русский ∙ Slovenščina ∙ Українська ∙ 简体中文 ∙ 繁體中文 命令列的藝術 必讀 基礎 日常使用 檔案及資料處理 系統偵錯 單行指令碼 冷門但有用的指令 僅限 OS X 系統 僅限 Windows 系統 更多資源 免責聲明 授權條款 熟練使用命令列是一種常常被忽視，或被認為難以掌握的技能，但實際上，它會提高你作為工程師的靈活性以及生產力。本文是一份我在 Linux 上工作時，發現的一些命令列使用技巧的摘要。有些技巧非常基礎，而另一些則相當複雜，甚至晦澀難懂。這篇文章並不長，但當你能夠熟練掌握這裡列出的所有技巧時，你就學會了很多關於命令列的東西了。 這篇文章是許多作者和譯者共同的成果。這裡的大部分內容首次出現於 Quora，但考慮到這裡的人們都具有學習的天賦且樂於接受別人的建議，使用 Github 來做這件事是更佳的選擇。如果你在本文中發現了錯誤或者​​存在可以改善的地方，請果斷提交 Issue 或 Pull Request！ (當然在提交前請看一下必讀節和已有的 PR/issue）。 必讀涵蓋範圍： 這篇文章對剛接觸命令列的新手以及具有命令列使用經驗的人都有用處。本文致力於做到覆蓋面廣（盡量包括一切重要的內容），具體（給出最常見的具體的例子）以及簡潔（避免不必要的，或是可以在其他地方輕鬆查到的細枝末節）。每個技巧都是在特定情境下必備的，或是能顯著減省時間的。 本文為 Linux 所寫，除了 僅限OS X 系統 和 僅限 Windows 系統 章節外，其它章節中的大部分內容都適用於其它 Unix 系統或 MacOS 系統，甚至 Cygwin。 本文關注於互動式 Bash，儘管很多技巧也適用於其他 shell 或 Bash 指令碼。 本文包括了“標準的” Unix 命令和需要安裝特定套件的命令，只要它們足夠重要。 注意事項： 為了能在一頁內展示盡量多的東西，一些具體的資訊會被間接的包含在引用頁裡。聰明機智的你如果掌握了使用 Google 搜尋引擎的基本方法與命令，那麼你將可以查閱到更多的詳細資訊。使用apt-get，yum，dnf，pacman，pip 或brew（以及其它合適的包管理器）來安裝新程式。 使用 Explainshell 去獲取相關命令、參數、管道等解釋。 基礎 學習 Bash 的基礎知識。具體來說，輸入man bash 並至少全文瀏覽一遍; 它很簡單並且不長。其他的 shell 可能很好用，但 Bash 功能強大且幾乎所有情況下都是可用的（ 只學習 zsh，fish 或其他的 shell 的話，在你自己的電腦上會顯得很方便，但在很多情況下會限制你，比如當你需要在伺服器上工作時）。 學習並掌握至少一個基於文字的編輯器。通常 Vim （vi） 會是你最好的選擇，因為在終端裡進行隨機編輯 Vim 真的毫無敵手，哪怕是Emacs、某大型IDE 甚至時下非常流行的編輯器。 學會如何使用man 命令去閱讀文件。學會使用 apropos 去查詢文件。瞭解有些命令是不可執行，而是Bash內建的，可以使用help 和help -d 命令獲取幫助資訊。 學會使用&gt; 和&lt; 來重定向輸出和輸入，學會使用| 來重定向管道。明白&gt; 會覆蓋了輸出文件而&gt;&gt; 是在檔案末新增。瞭解標準輸出 stdout 和標準錯誤 stderr。 學會使用通配符* （或許再算上? 和[…]） 和引用以及引用中&#39; 和&quot; 的區別。 熟悉 Bash 任務管理工具：&amp;，ctrl-z，ctrl-c，jobs，fg，bg，kill 等。 瞭解ssh，以及學會通過使用ssh-agent，ssh-add 等命令來實現基本的無密碼認證。 學會基本的檔案管理：ls 和ls -l （瞭解ls -l 中每一列代表的意義），less，head，tail 和tail -f （甚至less +F），ln 和ln -s （瞭解硬連結與軟連結的區別），chown，chmod，du （硬碟使用情況概述：du -hs * ）。關於檔案系統的管理，學習df，mount，fdisk，mkfs，lsblk。知道 inode 是什麼（與ls -i 和df -i 等命令相關）。 學習基本的網路管理：ip 或ifconfig，dig。 熟悉正規表示式，以及grep／egrep 裡不同參數的作用，例如-i，-o，-v，-A，-B 和-C ，這些參數是值得學習並掌握的。 學會使用apt-get，yum，dnf 或pacman （取決於你使用的 Linux 發行版）來查詢或安裝軟體包。並確保你的環境中有pip 來安裝基於 Python 的命令列工具（接下來提到的部分程式使用pip 來安裝會很方便）。 日常使用 在 Bash 中，可以使用 Tab 自動補全參數，使用 ctrl-r 搜尋命令列歷史（在按下之後，鍵入便可以搜尋，重複按下ctrl-r會在更多匹配中迴圈，按下 Enter 會執行找到的命令，按下右方向鍵會將結果放入當前行中，使你可以進行編輯）。 在 Bash 中，可以使用 ctrl-w 刪除你鍵入的最後一個單詞，使用 ctrl-u 刪除當前游標所在位置之前的內容，使用 alt-b 和 alt-f以單詞為單位移動游標，​​使用 ctrl-a 將游標移至行首，使用 ctrl-e 將游標移至行尾，使用 ctrl-k 刪除游標至行尾的所有內容，使用 ctrl-l 清屏。鍵入man readline 檢視 Bash 中的預設快捷鍵，內容很多。例如 alt-. 迴圈地移向前一個參數，以及 alt-* 展開通配符。 你喜歡的話，可以鍵入set -o vi 來使用vi 風格的快捷鍵，而set -o emacs 可以把它改回來。 為了方便地鍵入長命令，在設定你的編輯器後（例如export EDITOR=vim），鍵入 ctrl-x ctrl-e 會開啟一個編輯器來編輯當前命令。在 vi 模式下則鍵入 escape-v 實現相同的功能。 鍵入 history 檢視命令列歷史記錄。其中有許多縮寫，例如!$（最後鍵入的參數）和!!（最後鍵入的命令），儘管通常被 ctrl-r 和 alt-. 取代。 回到上一個工作路徑：cd - 如果你輸入命令的時候改變了主意，按下 alt-# 來在行首新增#，或者依次按下 ctrl-a， #， enter。這樣做的話，之後你可以很方便的利用命令列歷史回到你剛才輸入到一半的命令。 使用 xargs （ 或 parallel），他們非常強大。注意到你可以控制每行參數的個數（-L）和最大並行數（-P）。如果你不確定它們是否會按你想的那樣工作，先使用xargs echo 檢視一下。此外，使用 -I{} 會很方便。例如： 12 find . -name '*.py' | xargs grep some_function cat hosts | xargs -I&#123;&#125; ssh root@&#123;&#125; hostname pstree -p 有助於展示程序樹。 使用pgrep 和pkill 根據名字查詢程序或傳送訊號（-f 參數通常有用）。 瞭解你可以發往程序的訊號的種類。比如，使用kill -STOP [pid] 停止一個程序。使用 man 7 signal 檢視詳細列表。 使用nohup 或disown 使一個後臺程序持續運行。 使用netstat -lntp 或ss -plat 檢查哪些程序在監聽埠（預設是檢查 TCP 埠; 使用參數-u 檢查 UDP 埠）。 有關開啟 socket 和檔案，請參閱lsof。 使用uptime 或w 來檢視系統已經運行多長時間。 使用alias 來創建常用命令的快捷形式。例如：alias ll=&#39;ls -latr&#39; 使你可以方便地執行ls -latr命令。 在 Bash 指令碼中，使用set -x 去偵錯輸出，盡可能的使用嚴格模式，使用set -e 令指令碼在發生錯誤時退出而不是繼續運行，使用set -u 來檢查是否使用了未賦值的變數，使用set -o pipefail 嚴謹地對待錯誤（儘管問題可能很微妙）。當牽扯到很多指令碼時，使用 trap。一個好的習慣是在指令碼檔案開頭這樣寫，這會使它檢測一些錯誤，並在錯誤發生時中斷程式並輸出資訊： 12 set -euo pipefail trap "echo 'error: Script failed: see failed command above'" ERR 在 Bash 指令碼中，子 shell（使用括號(...)）是一種組織參數的便捷方式。一個常見的例子是臨時地移動工作路徑，程式碼如下： 123 # do something in current dir (cd /some/other/dir &amp;&amp; other-command) # continue in original dir 在 Bash 中，要注意其中有許多形式的擴展。檢查變數是否存在：${name:?error message}。例如，當 Bash 指令碼需要一個參數時，可以使用這樣的程式碼input_file=${1:?usage: $0 input_file}。數學表示式：i=$(( (i + 1) % 5 ))。序列：{1..10}。截斷字元串：${var%suffix} 和${var#prefix}。例如，假設var=foo.pdf，那麼echo ${var%.pdf}.txt 將輸出foo.txt。 使用括號擴展（{…}）來減少輸入相似文字，並自動化文字組合。這在某些情況下會很有用，例如mv foo.{txt,pdf} some-dir（同時移動兩個檔案），cp somefile{,.bak}（會被擴展成cp somefile somefile .bak）或者mkdir -p test-{a,b,c}/subtest-{1,2,3}（會被擴展成所有可能的組合，並創建一個目錄樹）。 通過使用&lt;(some command) 可以將輸出視為檔案。例如，對比本地檔案/etc/hosts 和一個​​遠端檔案： 1 diff /etc/hosts &lt;(ssh somehost cat /etc/hosts) 瞭解 Bash 中的“here documents”，例如cat &lt;&lt;EOF ...。 在 Bash 中，同時重定向標準輸出和標準錯誤，some-command &gt;logfile 2&gt;&amp;1。通常，為了保證命令不會在標準輸入裡殘留一個開啟了的檔案控制代碼導致你當前所在的終端無法操作，新增&lt;/dev/null 是一個好習慣。 使用man ascii 檢視具有十六進位制和十進位制值的ASCII表。 man unicode，man utf-8，以及man latin1 有助於你去了解通用的編碼資訊。 使用screen 或tmux 來使用多個螢幕，當你在使用 ssh 時（儲存session 資訊）特別有用。另一個輕量級的解決方案是 dtach。 ssh 中，瞭解如何使用-L 或-D（偶爾需要用-R）去開啟通道是非常有用的，例如當你需要從一臺遠端伺服器上訪問 web。 對 ssh 設定做一些小優化可能是很有用的，例如這個​​~/.ssh/config 檔案包含了防止特定環境下斷開連線、壓縮資料、多通道等選項： 1234567 TCPKeepAlive=yes ServerAliveInterval=15 ServerAliveCountMax=6 Compression=yes ControlMaster auto ControlPath /tmp/%r@%h:%p ControlPersist yes 部分其他的關於 ssh 的選項是安全敏感且應當小心啟用的。例如在可信任的網路中：StrictHostKeyChecking=no，ForwardAgent=yes 考慮使用mosh 作為 ssh 的替代品，它使用 UDP 協議。 獲取檔案的八進位制格式許可權，使用類似如下的程式碼： 1 stat -c '%A %a %n' /etc/timezone 使用percol 或者fzf 可以互動式地從另一個命令輸出中選取值。 使用fpp（PathPicker）可以與基於另一個命令(例如git）輸出的檔案互動。 要基於當前目錄(以及子目錄)建立一個簡易的 web 伺服器給所處網路的所有使用者，可以使用：python -m SimpleHTTPServer 7777 （使用埠 7777 和 Python 2）或python -m http.server 7777 （使用埠 7777 和 Python 3）。 以某種許可權執行命令，使用sudo（root 許可權）或sudo -u（其他使用者）。使用su或者sudo bash來啟動一個以對應使用者許可權運行的shell。使用su -模擬其他使用者的登入。 檔案及資料處理 在當前路徑下通過檔名定位一個檔案，find . -iname &#39;*something*&#39;（或類似的）。在所有路徑下通過檔名查詢檔案，使用locate something （但請記住updatedb 可能沒有對最近新建的檔案建立索引）。 使用ag 在原始碼或資料檔案裡檢索（比grep -r 更好）。 將 HTML 轉為文字：lynx -dump -stdin Markdown，HTML，以及所有文件格式之間的轉換，試試pandoc。 如果你不得不處理 XML，xmlstarlet 寶刀未老。 使用jq 處理 JSON。 使用shyaml 處理 YAML。 Excel 或 CSV 檔案的處理，csvkit 提供了in2csv，csvcut，csvjoin，csvgrep 等工具。 關於 Amazon S3，s3cmd 很方便，而s4cmd 更快。 Amazon 官方的aws 以及saws 是其他 AWS 相關工作的基礎。 瞭解如何使用sort 和uniq，包括 uniq 的-u 參數和-d 參數，詳見後文單行指令碼節。另外可以瞭解一下 comm。 瞭解如何使用cut，paste 和join 來更改檔案。很多人都會使用cut，但幾乎都不會使用join。 瞭解如何運用wc 去計算新行數（-l），字元數（-m），單詞數（-w）以及位位元數（-c）。 瞭解如何使用tee 將標準輸入複製到檔案甚至標準輸出，例如ls -al | tee file.txt。 瞭解語言環境對許多命令列工具的微妙影響，包括排序的順序和效能。大多數 Linux 的安裝過程會將LANG 或其他有關的變數設定為符合本地的設定。意識到當你改變語言環境時，排序的結果可能會改變。明白國際化可能會使 sort 或其他命令運行效率下降許多倍。某些情況下（例如集合運算）你可以放心的使用export LC_ALL=C 來忽略掉國際化並使用基於位元組的順序。 瞭解awk 和sed 關於資料的簡單處理的用法。例如，將文字檔案中第三列的所有數字求和：awk &#39;{ x += $3 } END { print x }&#39;. 這可能比同等作用的 Python 程式碼快三倍且程式碼量少三倍。 替換一個或多個檔案中出現的字元： 1 perl -pi.bak -e 's/old-string/new-string/g' my-files-*.txt 使用repren 來批次重新命名，或是在多個檔案中搜索替換。（有些時候rename 命令也可以批次重新命名，但要注意，它在不同 Linux 發行版中的功能並不完全一樣。） 123456 # Full rename of filenames, directories, and contents foo -&gt; bar: repren --full --preserve-case --from foo --to bar . # Recover backup files whatever.bak -&gt; whatever: repren --renames --from '(.*)\.bak' --to '\1' *.bak # Same as above, using rename, if available: rename 's/\.bak$//' *.bak 根據 man 頁面的描述，rsync 真的是一個快速且非常靈​​活的檔案複製工具。它通常被用於機器間的同步，但在本地也同樣有用。它同時也是刪除大量檔案的最快方法之一： 1mkdir empty &amp;&amp; rsync -r --delete empty/ some-dir &amp;&amp; rmdir some-dir 使用shuf 從一個檔案中隨機選取多行。 瞭解 sort 的參數。處理數字方面，使用-n 或者-h 來處理可讀性數字（例如du -h 的輸出）。明白鍵的工作原理（-t 和 -k）。例如，注意到你需要-k1，1 來按照第一個欄位來排序，而-k1 意味著按照整行排序。穩定排序（sort -s）在某些情況下很有用。例如，以第二個欄位為主關鍵字，第一個欄位為次關鍵字進行排序，你可以使用sort -k1，1 | sort -s -k2，2。 如果你想在 Bash 命令列中寫 tab 製表符，按下ctrl-v [Tab] 或鍵入$&#39;\t&#39; （後者可能更好，因為你可以複製貼上它）。 標準的原始碼對比及合併工具是diff 和patch。使用 diffstat 檢視變更總覽資料。注意到 diff -r 對整個資料夾有效。使用diff -r tree1 tree2 | diffstat 檢視變更總覽資料。 對於二進制檔案，使用hd 使其以十六進位制顯示以及使用bvi 來編輯二進位制。 同樣對於二進制檔案，strings（包括grep 等等）允許你查詢一些文字。 二進制檔案對比（Delta 壓縮），使用xdelta3。 轉換文字編碼可使用 iconv 或 uconv，後者支援 Unicode 相關的進階用法。例如： 12345# 顯示十六進制碼或字元標準名稱（有益於除錯）uconv -f utf-8 -t utf-8 -x '::Any-Hex;' &lt; input.txtuconv -f utf-8 -t utf-8 -x '::Any-Name;' &lt; input.txt# 將文字轉換為小寫並移除所有重音標記（展開字元並移除標記）：uconv -f utf-8 -t utf-8 -x '::Any-Lower; ::Any-NFD; [:Nonspacing Mark:] &gt;; ::Any-NFC;' &lt; input.txt &gt; output.txt 拆分檔案，檢視split（按大小拆分）和csplit（按模式拆分）。 用dateutils 中的dateadd, datediff, strptime 等工具操作日期和時間表示式。 使用zless，zmore，zcat 和zgrep 對壓縮過的檔案進行操作。 系統偵錯 curl 和curl -I 可以便捷地被應用於 web 偵錯，它們的好兄弟wget 也可以，或者是更潮的httpie。 使用iostat、netstat、top （htop 更佳）和dstat 去獲取硬碟、cpu 和網路的狀態。熟練掌握這些工具可以使你快速的對系統的當前狀態有一個大概的認識。 使用netstat 和ss 檢視網路連線的細節。 若要對系統有一個深度的總體認識，使用glances。它在一個終端視窗中向你提供一些系統層級的資料。這對於快速的檢查各個子系統非常有幫助。 若要了解記憶體狀態，運行並理解free 和vmstat 的輸出。尤其注意 “cached” 的值，它指的是 Linux 核心用來作為檔案快取的記憶體大小，因此它與空閒記憶體無關。 Java 系統偵錯則是一件截然不同的事，一個可以用於 Oracle 的 JVM 或其他 JVM 上的偵錯的技巧是你可以運行kill -3 &lt;pid&gt; 同時一個完整的棧軌跡和堆概述（包括 GC 的細節）會被儲存到標準輸出/日誌檔案。 JDK 中的jps，jstat，jstack，jmap 很有用。 SJK tools 更高階. 使用mtr ​​去跟蹤路由，用於確定網路問題。 用ncdu 來檢視磁碟使用情況，它比常用的命令，如du -sh *，更節省時間。 查詢正在使用頻寬的 socket 連線或程序，使用iftop 或nethogs。 ab 工具（內建於Apache）可以簡單粗暴地檢查 web 伺服器的效能。對於更複雜的負載測試，使用siege。 wireshark，tshark 和ngrep 可用於復雜的網路偵錯。 瞭解 strace 和 ltrace。這倆工具在你的程式運行失敗、掛起甚至崩潰，而你卻不知道為什麼或你想對效能有個總體的認識的時候是非常有用的。注意 profile 參數（-c）和附加到一個運行的程序參數（-p）。 瞭解使用 ldd 來檢查共享庫。 瞭解如何運用gdb 連線到一個運行著的程序並獲取它的堆棧軌跡。 學會使用 /proc。它在偵錯正在出現的問題的時候有時會效果驚人。比如：/proc/cpuinfo，/proc/meminfo，/proc/cmdline，/proc/xxx/cwd，/proc/xxx/exe，/proc/xxx/fd/ ，/proc/xxx/smaps（這裡的xxx 表示程序的 id 或 pid）。 當偵錯一些之前出現的問題的時候，sar 非常有用。它展示了 cpu、記憶體以及網路等的歷史資料。 關於更深層次的系統分析以及效能分析，看看stap（SystemTap），perf)，以及sysdig。 檢視你當前使用的系統，使用uname ， uname -a （Unix／kernel 資訊） 或者lsb_release -a （Linux 發行版資訊）。 無論什麼東西工作得很歡樂時試試dmesg（可能是硬體或驅動問題）。 單行指令碼一些命令組合的例子： 當你需要對文字檔案做集合交、並、差運算時，結合使用sort/uniq 很有幫助。假設 a 與 b 是兩內容不同的檔案。這種方式效率很高，並且在小檔案和上G的檔案上都能運用（sort 不被記憶體大小約束，儘管在/tmp 在一個小的根分區上時你可能需要-T 參數），參閱前文中關於LC_ALL 和sort 的-u 參數的部分。 123 cat a b | sort | uniq &gt; c # c is a union b cat ab | sort | uniq -d &gt; c # c is a intersect b cat abb | sort | uniq -u &gt; c # c is set difference a - b 使用grep . *（每行都會附上檔名）或者head -100 *（每個檔案有一個標題）來閱讀檢查目錄下所有檔案的內容。這在檢查一個充滿配置檔案的目錄（如/sys、/proc、/etc）時特別好用。 計算文字檔案第三列中所有數的和（可能比同等作用的Python 程式碼快三倍且程式碼量少三倍）： 1 awk '&#123; x += $3 &#125; END &#123; print x &#125;' myfile 如果你想在檔案樹上檢視大小/日期，這可能看起來像遞迴版的ls -l 但比ls -lR 更易於理解： 1 find . -type f -ls 假設你有一個類似於 web 伺服器日誌檔案的文字檔案，並且一個確定的值只會出現在某些行上，假設一個acct_id 參數在URI中。如果你想計算出每個acct_id 值有多少次請求，使用如下程式碼： 1 cat access.log | egrep -o 'acct_id=[0-9]+' | cut -d= -f2 | sort | uniq -c | sort -rn 運行這個函數從這篇文件中隨機獲取一條技巧（解析 Markdown 檔案並抽取項目）： 1234567 function taocl() &#123; curl -s https://raw.githubusercontent.com/jlevy/the-art-of-command-line/master/README.md | pandoc -f markdown -t html | xmlstarlet fo --html --dropdtd | xmlstarlet sel -t -v "(html/body/ul/li[count(p)&gt;0])[$RANDOM mod last()+1]" | xmlstarlet unesc | fmt -80 &#125; 冷門但有用的指令 expr：計算表示式或正規表示法 m4：簡易的巨集處理器 yes：列印多次字串 cal：漂亮的日曆 env：執行一個命令（指令碼中很有用） printenv：列印環境變數（偵錯時或在使用指令碼時很有用） look：查詢以特定字元串開頭的單詞 cut、paste 和 join：資料操作 fmt：格式化文字段落 pr：將文字格式化成頁/列形式 fold：包裹文字中的幾行 column：將文字格式化成多列或表格 expand 和unexpand：在 tab 與空格之間轉換 nl：新增行號 seq：列印數字 bc：計算機 factor：分解因數 gpg：加密並針對檔案簽章 toe：terminfo entries 列表 nc：網路偵錯及資料傳輸 socat：socket 代理，與 netcat 類似 slurm：網路流量視覺化 dd：在檔案或裝置間傳輸資料 file：確定檔案類型 tree：以樹的形式顯示路徑和檔案，類似於遞迴的ls stat：檔案資訊 time：執行命令，同時計算執行時間 lockfile：使檔案只能通過rm -f 移除 logrotate: 切換、壓縮以及傳送日誌檔案 watch：重複運行同一個命令，展示結果並 highlight 有更改的部分 tac：反向輸出文件 shuf：檔案中隨機選取幾行 comm：一行一行的比較排序過的檔案 pv：監視通過 pipe 的資料 hd，hexdump，xxd，biew 和bvi：儲存或編輯二進位檔案 strings：從二進位檔案中抽取文字 tr：轉換字母 iconv 或 uconv：簡易的檔案編碼 split 和 csplit：分割檔案 sponge：在寫入前讀取所有輸入，在讀取檔案後再向同一檔案寫入時比較有用，例如grep -v something some-file | sponge some-file units：將一種計量單位轉換為另一種等效的計量單位（參閱/usr/share/units/definitions.units） apg：隨機生成密碼 7z：高比例的檔案壓縮 ldd：動態庫資訊 nm：提取 obj 檔案中的符號 ab：效能分析 web 伺服器 strace：系統呼叫偵錯 mtr：更好的網路偵錯跟蹤工具 cssh：視覺化的並發 shell rsync：通過ssh 或本地檔案系統同步檔案和資料夾 wireshark 和tshark：抓包和網路偵錯工具 ngrep：網路層的 grep host 和 dig：DNS 查詢 lsof：列出當前系統開啟檔案的工具以及檢視埠資訊 dstat：系統狀態檢視 glances：高層次的多子系統總覽 iostat：硬碟使用狀態 mpstat: CPU 使用狀態 vmstat: 記憶體使用狀態 htop：top 的加強版 last：登入記錄 w：檢視處於登入狀態的使用者 id：使用者/組 ID 資訊 sar：系統歷史資料 iftop 或nethogs：套接字及程序的網路利用 ss：socket 資料 dmesg：引導及系統錯誤資訊 sysctl: 在核心運行時動態地檢視和修改內核的運行參數 hdparm：SATA/ATA 磁碟更改及效能分析 lsblk：列出塊裝置資訊：以樹形展示你的磁碟以及磁碟分區資訊 lshw，lscpu，lspci，lsusb 和dmidecode：檢視硬體資訊，包括CPU、BIOS、RAID、顯示卡、USB裝置等 lsmod 和modinfo：列出核心模組，並顯示其細節 fortune，ddate 和sl：額，這主要取決於你是否認為蒸汽火車和莫名其妙的名人名言是否“有用” 僅限 OS X 系統以下是僅限於 MacOS 系統的技巧 用brew （Homebrew）或者port （MacPorts）進行套件管理。這些可以用來在 Mac 系統上安裝以上的大多數命令。 用pbcopy 複製任何命令的輸出到桌面應用，用pbpaste 貼上輸入。 若要在 Mac OS 終端中將 Option 鍵視為 alt 鍵（例如在上面介紹的alt-b, alt-f 等命令中用到），開啟偏好設定-&gt; 描述檔案-&gt; 鍵盤並勾選“使用 Option 鍵作為 Meta 鍵”。 用open 或者open -a /Applications/Whatever.app 使用桌面應用開啟檔案。 Spotlight： 用mdfind 搜尋檔案，用mdls 列出後設資料（例如照片的EXIF 資訊）。 注意 MacOS 系統是基於BSD UNIX 的，許多命令（例如ps，ls，tail，awk，sed）都和 Linux 中有些微的不同，這些指令主要是被 System V -style Unix 和 GNU 工具影響。你可以透過標題為”BSD General Commands Manual” 的 man 頁面發現這些不同。在有些情況下 GNU 版本的命令也可能被安裝（例如gawk 和gsed 對應GNU 中的awk 和sed ）。如果要寫跨平臺的 Bash 指令碼，避免使用這些命令（例如，考慮 Python 或者perl ）或者經過仔細的測試。 用 sw_vers 獲取 MacOS 的版本資訊。 僅限 Windows 系统 要在 Microsoft Windows 中使用 Unix shell，可以安装 Cygwin。本文件中介绍的大多數内容都將適用。 透過 Cygwin 的套件管理器來安裝額外的 Unix 指令。 使用 mintty 作為你的命令列視窗。 要訪問 Windows 剪貼簿，可以透過 /dev/clipboard。 執行 cygstart 以透過預設程式打開一個文件。 要訪問 Windows 登錄檔，可以使用 regtool。 注意 Windows 磁碟機路徑 C:\ 在 Cygwin 中用 /cygdrive/c 代表，而 Cygwin 的 / 在 Windows 中顯示在 C:\cygwin。要轉換 Cygwin 和 Windows 風格的路徑可以用 cygpath。這在需要使用 Windows 指令的脚本裡很有用。 學會使用 wmic，你就可以從命令列執行大多數 Windows 系統管理任務，並編成腳本。 更多資源 awesome-shell：一份精美的命令列工具及資源的列表。 awesome-osx-command-line：一份針對 Mac OS 命令列的更深入的指南。 Strict mode：為了編寫更好的指令碼檔案。 shellcheck：一個靜態shell 指令碼分析工具，本質上是 bash／sh／zsh 的lint。 Filenames and Pathnames in Shell：有關如何在 shell 腳本里正確處理檔名的細枝末節。 免責聲明除去特別微小的任務，編寫程式碼是出於方便閱讀的目的。能力往往伴隨著責任。你 可以 在 Bash 中做一些事並不意味著你應該去做！ ;) 授權條款 本文使用授權協議 知識共享署名 - 相同方式共享 4.0 國際許可。]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%9A%84%E8%89%BA%E6%9C%AF%2FREADME-zh%2F</url>
    <content type="text"><![CDATA[🌍Čeština ∙ Deutsch ∙ Ελληνικά ∙ English ∙ Español ∙ Français ∙ Indonesia ∙ Italiano ∙ 日本語 ∙ 한국어 ∙ Português ∙ Română ∙ Русский ∙ Slovenščina ∙ Українська ∙ 简体中文 ∙ 繁體中文 命令行的艺术 前言 基础 日常使用 文件及数据处理 系统调试 单行脚本 冷门但有用 仅限 OS X 系统 仅限 Windows 系统 更多资源 免责声明 熟练使用命令行是一种常常被忽视，或被认为难以掌握的技能，但实际上，它会提高你作为工程师的灵活性以及生产力。本文是一份我在 Linux 上工作时，发现的一些命令行使用技巧的摘要。有些技巧非常基础，而另一些则相当复杂，甚至晦涩难懂。这篇文章并不长，但当你能够熟练掌握这里列出的所有技巧时，你就学会了很多关于命令行的东西了。 这篇文章是许多作者和译者共同的成果。这里的部分内容首次出现于 Quora，但已经迁移到了 Github，并由众多高手做出了许多改进。如果你在本文中发现了错误或者存在可以改善的地方，请贡献你的一份力量。 前言涵盖范围： 这篇文章不仅能帮助刚接触命令行的新手，而且对具有经验的人也大有裨益。本文致力于做到覆盖面广（涉及所有重要的内容），具体（给出具体的最常用的例子），以及简洁（避免冗余的内容，或是可以在其他地方轻松查到的细枝末节）。在特定应用场景下，本文的内容属于基本功或者能帮助您节约大量的时间。 本文主要为 Linux 所写，但在仅限 OS X 系统章节和仅限 Windows 系统章节中也包含有对应操作系统的内容。除去这两个章节外，其它的内容大部分均可在其他类 Unix 系统或 OS X，甚至 Cygwin 中得到应用。 本文主要关注于交互式 Bash，但也有很多技巧可以应用于其他 shell 和 Bash 脚本当中。 除去“标准的”Unix 命令，本文还包括了一些依赖于特定软件包的命令（前提是它们具有足够的价值）。 注意事项： 为了能在一页内展示尽量多的东西，一些具体的信息可以在引用的页面中找到。我们相信机智的你知道如何使用 Google 或者其他搜索引擎来查阅到更多的详细信息。文中部分命令需要您使用 apt-get，yum，dnf，pacman，pip 或 brew（以及其它合适的包管理器）来安装依赖的程序。 遇到问题的话，请尝试使用 Explainshell 去获取相关命令、参数、管道等内容的解释。 基础 学习 Bash 的基础知识。具体地，在命令行中输入 man bash 并至少全文浏览一遍; 它理解起来很简单并且不冗长。其他的 shell 可能很好用，但 Bash 的功能已经足够强大并且到几乎总是可用的（ 如果你只学习 zsh，fish 或其他的 shell 的话，在你自己的设备上会显得很方便，但过度依赖这些功能会给您带来不便，例如当你需要在服务器上工作时）。 熟悉至少一个基于文本的编辑器。通常而言 Vim （vi） 会是你最好的选择，毕竟在终端中编辑文本时 Vim 是最好用的工具（甚至大部分情况下 Vim 要比 Emacs、大型 IDE 或是炫酷的编辑器更好用）。 学会如何使用 man 命令去阅读文档。学会使用 apropos 去查找文档。知道有些命令并不对应可执行文件，而是在 Bash 内置好的，此时可以使用 help 和 help -d 命令获取帮助信息。你可以用 type 命令 来判断这个命令到底是可执行文件、shell 内置命令还是别名。 学会使用 &gt; 和 &lt; 来重定向输出和输入，学会使用 | 来重定向管道。明白 &gt; 会覆盖了输出文件而 &gt;&gt; 是在文件末添加。了解标准输出 stdout 和标准错误 stderr。 学会使用通配符 * （或许再算上 ? 和 […]） 和引用以及引用中 &#39; 和 &quot; 的区别（后文中有一些具体的例子）。 熟悉 Bash 中的任务管理工具：&amp;，ctrl-z，ctrl-c，jobs，fg，bg，kill 等。 学会使用 ssh 进行远程命令行登录，最好知道如何使用 ssh-agent，ssh-add 等命令来实现基础的无密码认证登录。 学会基本的文件管理工具：ls 和 ls -l （了解 ls -l 中每一列代表的意义），less，head，tail 和 tail -f （甚至 less +F），ln 和 ln -s （了解硬链接与软链接的区别），chown，chmod，du （硬盘使用情况概述：du -hs *）。 关于文件系统的管理，学习 df，mount，fdisk，mkfs，lsblk。知道 inode 是什么（与 ls -i 和 df -i 等命令相关）。 学习基本的网络管理工具：ip 或 ifconfig，dig。 学习并使用一种版本控制管理系统，例如 git。 熟悉正则表达式，学会使用 grep／egrep，它们的参数中 -i，-o，-v，-A，-B 和 -C 这些是很常用并值得认真学习的。 学会使用 apt-get，yum，dnf 或 pacman （具体使用哪个取决于你使用的 Linux 发行版）来查找和安装软件包。并确保你的环境中有 pip 来安装基于 Python 的命令行工具 （接下来提到的部分程序使用 pip 来安装会很方便）。 日常使用 在 Bash 中，可以通过按 Tab 键实现自动补全参数，使用 ctrl-r 搜索命令行历史记录（按下按键之后，输入关键字便可以搜索，重复按下 ctrl-r 会向后查找匹配项，按下 Enter 键会执行当前匹配的命令，而按下右方向键会将匹配项放入当前行中，不会直接执行，以便做出修改）。 在 Bash 中，可以按下 ctrl-w 删除你键入的最后一个单词，ctrl-u 可以删除行内光标所在位置之前的内容，alt-b 和 alt-f 可以以单词为单位移动光标，ctrl-a 可以将光标移至行首，ctrl-e 可以将光标移至行尾，ctrl-k 可以删除光标至行尾的所有内容，ctrl-l 可以清屏。键入 man readline 可以查看 Bash 中的默认快捷键。内容有很多，例如 alt-. 循环地移向前一个参数，而 alt-* 可以展开通配符。 你喜欢的话，可以执行 set -o vi 来使用 vi 风格的快捷键，而执行 set -o emacs 可以把它改回来。 为了便于编辑长命令，在设置你的默认编辑器后（例如 export EDITOR=vim），ctrl-x ctrl-e 会打开一个编辑器来编辑当前输入的命令。在 vi 风格下快捷键则是 escape-v。 键入 history 查看命令行历史记录，再用 !n（n 是命令编号）就可以再次执行。其中有许多缩写，最有用的大概就是 !$， 它用于指代上次键入的参数，而 !! 可以指代上次键入的命令了（参考 man 页面中的“HISTORY EXPANSION”）。不过这些功能，你也可以通过快捷键 ctrl-r 和 alt-. 来实现。 cd 命令可以切换工作路径，输入 cd ~ 可以进入 home 目录。要访问你的 home 目录中的文件，可以使用前缀 ~（例如 ~/.bashrc）。在 sh 脚本里则用环境变量 $HOME 指代 home 目录的路径。 回到前一个工作路径：cd -。 如果你输入命令的时候中途改了主意，按下 alt-# 在行首添加 # 把它当做注释再按下回车执行（或者依次按下 ctrl-a， #， enter）。这样做的话，之后借助命令行历史记录，你可以很方便恢复你刚才输入到一半的命令。 使用 xargs （ 或 parallel）。他们非常给力。注意到你可以控制每行参数个数（-L）和最大并行数（-P）。如果你不确定它们是否会按你想的那样工作，先使用 xargs echo 查看一下。此外，使用 -I{} 会很方便。例如： 12find . -name '*.py' | xargs grep some_functioncat hosts | xargs -I&#123;&#125; ssh root@&#123;&#125; hostname pstree -p 以一种优雅的方式展示进程树。 使用 pgrep 和 pkill 根据名字查找进程或发送信号（-f 参数通常有用）。 了解你可以发往进程的信号的种类。比如，使用 kill -STOP [pid] 停止一个进程。使用 man 7 signal 查看详细列表。 使用 nohup 或 disown 使一个后台进程持续运行。 使用 netstat -lntp 或 ss -plat 检查哪些进程在监听端口（默认是检查 TCP 端口; 添加参数 -u 则检查 UDP 端口）或者 lsof -iTCP -sTCP:LISTEN -P -n (这也可以在 OS X 上运行)。 lsof 来查看开启的套接字和文件。 使用 uptime 或 w 来查看系统已经运行多长时间。 使用 alias 来创建常用命令的快捷形式。例如：alias ll=&#39;ls -latr&#39; 创建了一个新的命令别名 ll。 可以把别名、shell 选项和常用函数保存在 ~/.bashrc，具体看下这篇文章。这样做的话你就可以在所有 shell 会话中使用你的设定。 把环境变量的设定以及登陆时要执行的命令保存在 ~/.bash_profile。而对于从图形界面启动的 shell 和 cron 启动的 shell，则需要单独配置文件。 要想在几台电脑中同步你的配置文件（例如 .bashrc 和 .bash_profile），可以借助 Git。 当变量和文件名中包含空格的时候要格外小心。Bash 变量要用引号括起来，比如 &quot;$FOO&quot;。尽量使用 -0 或 -print0 选项以便用 NULL 来分隔文件名，例如 locate -0 pattern | xargs -0 ls -al 或 find / -print0 -type d | xargs -0 ls -al。如果 for 循环中循环访问的文件名含有空字符（空格、tab 等字符），只需用 IFS=$&#39;\n&#39; 把内部字段分隔符设为换行符。 在 Bash 脚本中，使用 set -x 去调试输出（或者使用它的变体 set -v，它会记录原始输入，包括多余的参数和注释）。尽可能地使用严格模式：使用 set -e 令脚本在发生错误时退出而不是继续运行；使用 set -u 来检查是否使用了未赋值的变量；试试 set -o pipefail，它可以监测管道中的错误。当牵扯到很多脚本时，使用 trap 来检测 ERR 和 EXIT。一个好的习惯是在脚本文件开头这样写，这会使它能够检测一些错误，并在错误发生时中断程序并输出信息： 12set -euo pipefailtrap "echo 'error: Script failed: see failed command above'" ERR 在 Bash 脚本中，子 shell（使用括号 (...)）是一种组织参数的便捷方式。一个常见的例子是临时地移动工作路径，代码如下： 123# do something in current dir(cd /some/other/dir &amp;&amp; other-command)# continue in original dir 在 Bash 中，变量有许多的扩展方式。${name:?error message} 用于检查变量是否存在。此外，当 Bash 脚本只需要一个参数时，可以使用这样的代码 input_file=${1:?usage: $0 input_file}。在变量为空时使用默认值：${name:-default}。如果你要在之前的例子中再加一个（可选的）参数，可以使用类似这样的代码 output_file=${2:-logfile}，如果省略了 $2，它的值就为空，于是 output_file 就会被设为 logfile。数学表达式：i=$(( (i + 1) % 5 ))。序列：{1..10}。截断字符串：${var%suffix} 和 ${var#prefix}。例如，假设 var=foo.pdf，那么 echo ${var%.pdf}.txt 将输出 foo.txt。 使用括号扩展（{…}）来减少输入相似文本，并自动化文本组合。这在某些情况下会很有用，例如 mv foo.{txt,pdf} some-dir（同时移动两个文件），cp somefile{,.bak}（会被扩展成 cp somefile somefile.bak）或者 mkdir -p test-{a,b,c}/subtest-{1,2,3}（会被扩展成所有可能的组合，并创建一个目录树）。 通过使用 &lt;(some command) 可以将输出视为文件。例如，对比本地文件 /etc/hosts 和一个远程文件： 1diff /etc/hosts &lt;(ssh somehost cat /etc/hosts) 编写脚本时，你可能会想要把代码都放在大括号里。缺少右括号的话，代码就会因为语法错误而无法执行。如果你的脚本是要放在网上分享供他人使用的，这样的写法就体现出它的好处了，因为这样可以防止下载不完全代码被执行。 123&#123; # 在这里写代码&#125; 了解 Bash 中的“here documents”，例如 cat &lt;&lt;EOF ...。 在 Bash 中，同时重定向标准输出和标准错误：some-command &gt;logfile 2&gt;&amp;1 或者 some-command &amp;&gt;logfile。通常，为了保证命令不会在标准输入里残留一个未关闭的文件句柄捆绑在你当前所在的终端上，在命令后添加 &lt;/dev/null 是一个好习惯。 使用 man ascii 查看具有十六进制和十进制值的ASCII表。man unicode，man utf-8，以及 man latin1 有助于你去了解通用的编码信息。 使用 screen 或 tmux 来使用多份屏幕，当你在使用 ssh 时（保存 session 信息）将尤为有用。而 byobu 可以为它们提供更多的信息和易用的管理工具。另一个轻量级的 session 持久化解决方案是 dtach。 ssh 中，了解如何使用 -L 或 -D（偶尔需要用 -R）开启隧道是非常有用的，比如当你需要从一台远程服务器上访问 web 页面。 对 ssh 设置做一些小优化可能是很有用的，例如这个 ~/.ssh/config 文件包含了防止特定网络环境下连接断开、压缩数据、多通道等选项： 1234567TCPKeepAlive=yesServerAliveInterval=15ServerAliveCountMax=6Compression=yesControlMaster autoControlPath /tmp/%r@%h:%pControlPersist yes 一些其他的关于 ssh 的选项是与安全相关的，应当小心翼翼的使用。例如你应当只能在可信任的网络中启用 StrictHostKeyChecking=no，ForwardAgent=yes。 考虑使用 mosh 作为 ssh 的替代品，它使用 UDP 协议。它可以避免连接被中断并且对带宽需求更小，但它需要在服务端做相应的配置。 获取八进制形式的文件访问权限（修改系统设置时通常需要，但 ls 的功能不那么好用并且通常会搞砸），可以使用类似如下的代码： 1stat -c '%A %a %n' /etc/timezone 使用 percol 或者 fzf 可以交互式地从另一个命令输出中选取值。 使用 fpp（PathPicker）可以与基于另一个命令(例如 git）输出的文件交互。 将 web 服务器上当前目录下所有的文件（以及子目录）暴露给你所处网络的所有用户，使用：python -m SimpleHTTPServer 7777 （使用端口 7777 和 Python 2）或python -m http.server 7777 （使用端口 7777 和 Python 3）。 以其他用户的身份执行命令，使用 sudo。默认以 root 用户的身份执行；使用 -u 来指定其他用户。使用 -i 来以该用户登录（需要输入你自己的密码）。 将 shell 切换为其他用户，使用 su username 或者 sudo - username。加入 - 会使得切换后的环境与使用该用户登录后的环境相同。省略用户名则默认为 root。切换到哪个用户，就需要输入哪个用户的密码。 了解命令行的 128K 限制。使用通配符匹配大量文件名时，常会遇到“Argument list too long”的错误信息。（这种情况下换用 find 或 xargs 通常可以解决。） 当你需要一个基本的计算器时，可以使用 python 解释器（当然你要用 python 的时候也是这样）。例如： 12&gt;&gt;&gt; 2+35 文件及数据处理 在当前目录下通过文件名查找一个文件，使用类似于这样的命令：find . -iname &#39;*something*&#39;。在所有路径下通过文件名查找文件，使用 locate something （但注意到 updatedb 可能没有对最近新建的文件建立索引，所以你可能无法定位到这些未被索引的文件）。 使用 ag 在源代码或数据文件里检索（grep -r 同样可以做到，但相比之下 ag 更加先进）。 将 HTML 转为文本：lynx -dump -stdin。 Markdown，HTML，以及所有文档格式之间的转换，试试 pandoc。 当你要处理棘手的 XML 时候，xmlstarlet 算是上古时代流传下来的神器。 使用 jq 处理 JSON。 使用 shyaml 处理 YAML。 要处理 Excel 或 CSV 文件的话，csvkit 提供了 in2csv，csvcut，csvjoin，csvgrep 等方便易用的工具。 当你要处理 Amazon S3 相关的工作的时候，s3cmd 是一个很方便的工具而 s4cmd 的效率更高。Amazon 官方提供的 aws 以及 saws 是其他 AWS 相关工作的基础，值得学习。 了解如何使用 sort 和 uniq，包括 uniq 的 -u 参数和 -d 参数，具体内容在后文单行脚本节中。另外可以了解一下 comm。 了解如何使用 cut，paste 和 join 来更改文件。很多人都会使用 cut，但遗忘了 join。 了解如何运用 wc 去计算新行数（-l），字符数（-m），单词数（-w）以及字节数（-c）。 了解如何使用 tee 将标准输入复制到文件甚至标准输出，例如 ls -al | tee file.txt。 要进行一些复杂的计算，比如分组、逆序和一些其他的统计分析，可以考虑使用 datamash。 注意到语言设置（中文或英文等）对许多命令行工具有一些微妙的影响，比如排序的顺序和性能。大多数 Linux 的安装过程会将 LANG 或其他有关的变量设置为符合本地的设置。要意识到当你改变语言设置时，排序的结果可能会改变。明白国际化可能会使 sort 或其他命令运行效率下降许多倍。某些情况下（例如集合运算）你可以放心的使用 export LC_ALL=C 来忽略掉国际化并按照字节来判断顺序。 你可以单独指定某一条命令的环境，只需在调用时把环境变量设定放在命令的前面，例如 TZ=Pacific/Fiji date 可以获取斐济的时间。 了解如何使用 awk 和 sed 来进行简单的数据处理。 参阅 One-liners 获取示例。 替换一个或多个文件中出现的字符串： 1perl -pi.bak -e 's/old-string/new-string/g' my-files-*.txt 使用 repren 来批量重命名文件，或是在多个文件中搜索替换内容。（有些时候 rename 命令也可以批量重命名，但要注意，它在不同 Linux 发行版中的功能并不完全一样。） 123456# 将文件、目录和内容全部重命名 foo -&gt; bar:repren --full --preserve-case --from foo --to bar .# 还原所有备份文件 whatever.bak -&gt; whatever:repren --renames --from '(.*)\.bak' --to '\1' *.bak# 用 rename 实现上述功能（若可用）:rename 's/\.bak$//' *.bak 根据 man 页面的描述，rsync 是一个快速且非常灵活的文件复制工具。它闻名于设备之间的文件同步，但其实它在本地情况下也同样有用。在安全设置允许下，用 rsync 代替 scp 可以实现文件续传，而不用重新从头开始。它同时也是删除大量文件的最快方法之一： 1mkdir empty &amp;&amp; rsync -r --delete empty/ some-dir &amp;&amp; rmdir some-dir 若要在复制文件时获取当前进度，可使用 pv，pycp，progress，rsync --progress。若所执行的复制为block块拷贝，可以使用 dd status=progress。 使用 shuf 可以以行为单位来打乱文件的内容或从一个文件中随机选取多行。 了解 sort 的参数。显示数字时，使用 -n 或者 -h 来显示更易读的数（例如 du -h 的输出）。明白排序时关键字的工作原理（-t 和 -k）。例如，注意到你需要 -k1，1 来仅按第一个域来排序，而 -k1 意味着按整行排序。稳定排序（sort -s）在某些情况下很有用。例如，以第二个域为主关键字，第一个域为次关键字进行排序，你可以使用 sort -k1，1 | sort -s -k2，2。 如果你想在 Bash 命令行中写 tab 制表符，按下 ctrl-v [Tab] 或键入 $&#39;\t&#39; （后者可能更好，因为你可以复制粘贴它）。 标准的源代码对比及合并工具是 diff 和 patch。使用 diffstat 查看变更总览数据。注意到 diff -r 对整个文件夹有效。使用 diff -r tree1 tree2 | diffstat 查看变更的统计数据。vimdiff 用于比对并编辑文件。 对于二进制文件，使用 hd，hexdump 或者 xxd 使其以十六进制显示，使用 bvi，hexedit 或者 biew 来进行二进制编辑。 同样对于二进制文件，strings（包括 grep 等工具）可以帮助在二进制文件中查找特定比特。 制作二进制差分文件（Delta 压缩），使用 xdelta3。 使用 iconv 更改文本编码。需要更高级的功能，可以使用 uconv，它支持一些高级的 Unicode 功能。例如，这条命令移除了所有重音符号： 1uconv -f utf-8 -t utf-8 -x '::Any-Lower; ::Any-NFD; [:Nonspacing Mark:] &gt;; ::Any-NFC; ' &lt; input.txt &gt; output.txt 拆分文件可以使用 split（按大小拆分）和 csplit（按模式拆分）。 操作日期和时间表达式，可以用 dateutils 中的 dateadd、datediff、strptime 等工具。 使用 zless、zmore、zcat 和 zgrep 对压缩过的文件进行操作。 文件属性可以通过 chattr 进行设置，它比文件权限更加底层。例如，为了保护文件不被意外删除，可以使用不可修改标记：sudo chattr +i /critical/directory/or/file 使用 getfacl 和 setfacl 以保存和恢复文件权限。例如： 12getfacl -R /some/path &gt; permissions.txtsetfacl --restore=permissions.txt 为了高效地创建空文件，请使用 truncate（创建稀疏文件），fallocate（用于 ext4，xfs，btrf 和 ocfs2 文件系统），xfs_mkfile（适用于几乎所有的文件系统，包含在 xfsprogs 包中），mkfile（用于类 Unix 操作系统，比如 Solaris 和 Mac OS）。 系统调试 curl 和 curl -I 可以被轻松地应用于 web 调试中，它们的好兄弟 wget 也是如此，或者也可以试试更潮的 httpie。 获取 CPU 和硬盘的使用状态，通常使用使用 top（htop 更佳），iostat 和 iotop。而 iostat -mxz 15 可以让你获悉 CPU 和每个硬盘分区的基本信息和性能表现。 使用 netstat 和 ss 查看网络连接的细节。 dstat 在你想要对系统的现状有一个粗略的认识时是非常有用的。然而若要对系统有一个深度的总体认识，使用 glances，它会在一个终端窗口中向你提供一些系统级的数据。 若要了解内存状态，运行并理解 free 和 vmstat 的输出。值得留意的是“cached”的值，它指的是 Linux 内核用来作为文件缓存的内存大小，而与空闲内存无关。 Java 系统调试则是一件截然不同的事，一个可以用于 Oracle 的 JVM 或其他 JVM 上的调试的技巧是你可以运行 kill -3 &lt;pid&gt; 同时一个完整的栈轨迹和堆概述（包括 GC 的细节）会被保存到标准错误或是日志文件。JDK 中的 jps，jstat，jstack，jmap 很有用。SJK tools 更高级。 使用 mtr 去跟踪路由，用于确定网络问题。 用 ncdu 来查看磁盘使用情况，它比寻常的命令，如 du -sh *，更节省时间。 查找正在使用带宽的套接字连接或进程，使用 iftop 或 nethogs。 ab 工具（Apache 中自带）可以简单粗暴地检查 web 服务器的性能。对于更复杂的负载测试，使用 siege。 wireshark，tshark 和 ngrep 可用于复杂的网络调试。 了解 strace 和 ltrace。这俩工具在你的程序运行失败、挂起甚至崩溃，而你却不知道为什么或你想对性能有个总体的认识的时候是非常有用的。注意 profile 参数（-c）和附加到一个运行的进程参数 （-p）。 了解使用 ldd 来检查共享库。但是永远不要在不信任的文件上运行。 了解如何运用 gdb 连接到一个运行着的进程并获取它的堆栈轨迹。 学会使用 /proc。它在调试正在出现的问题的时候有时会效果惊人。比如：/proc/cpuinfo，/proc/meminfo，/proc/cmdline，/proc/xxx/cwd，/proc/xxx/exe，/proc/xxx/fd/，/proc/xxx/smaps（这里的 xxx 表示进程的 id 或 pid）。 当调试一些之前出现的问题的时候，sar 非常有用。它展示了 cpu、内存以及网络等的历史数据。 关于更深层次的系统分析以及性能分析，看看 stap（SystemTap），perf)，以及sysdig。 查看你当前使用的系统，使用 uname，uname -a（Unix／kernel 信息）或者 lsb_release -a（Linux 发行版信息）。 无论什么东西工作得很欢乐（可能是硬件或驱动问题）时可以试试 dmesg。 如果你删除了一个文件，但通过 du 发现没有释放预期的磁盘空间，请检查文件是否被进程占用：lsof | grep deleted | grep &quot;filename-of-my-big-file&quot; 单行脚本一些命令组合的例子： 当你需要对文本文件做集合交、并、差运算时，sort 和 uniq 会是你的好帮手。具体例子请参照代码后面的，此处假设 a 与 b 是两内容不同的文件。这种方式效率很高，并且在小文件和上 G 的文件上都能运用（注意尽管在 /tmp 在一个小的根分区上时你可能需要 -T 参数，但是实际上 sort 并不被内存大小约束），参阅前文中关于 LC_ALL 和 sort 的 -u 参数的部分。 123sort a b | uniq &gt; c # c 是 a 并 bsort a b | uniq -d &gt; c # c 是 a 交 bsort a b b | uniq -u &gt; c # c 是 a - b 使用 grep . *（每行都会附上文件名）或者 head -100 *（每个文件有一个标题）来阅读检查目录下所有文件的内容。这在检查一个充满配置文件的目录（如 /sys、/proc、/etc）时特别好用。 计算文本文件第三列中所有数的和（可能比同等作用的 Python 代码快三倍且代码量少三倍）： 1awk '&#123; x += $3 &#125; END &#123; print x &#125;' myfile 如果你想在文件树上查看大小/日期，这可能看起来像递归版的 ls -l 但比 ls -lR 更易于理解： 1find . -type f -ls 假设你有一个类似于 web 服务器日志文件的文本文件，并且一个确定的值只会出现在某些行上，假设一个 acct_id 参数在 URI 中。如果你想计算出每个 acct_id 值有多少次请求，使用如下代码： 1egrep -o 'acct_id=[0-9]+' access.log | cut -d= -f2 | sort | uniq -c | sort -rn 要持续监测文件改动，可以使用 watch，例如检查某个文件夹中文件的改变，可以用 watch -d -n 2 &#39;ls -rtlh | tail&#39;；或者在排查 WiFi 设置故障时要监测网络设置的更改，可以用 watch -d -n 2 ifconfig。 运行这个函数从这篇文档中随机获取一条技巧（解析 Markdown 文件并抽取项目）： 12345678function taocl() &#123; curl -s https://raw.githubusercontent.com/jlevy/the-art-of-command-line/master/README-zh.md| pandoc -f markdown -t html | iconv -f 'utf-8' -t 'unicode' | xmlstarlet fo --html --dropdtd | xmlstarlet sel -t -v "(html/body/ul/li[count(p)&gt;0])[$RANDOM mod last()+1]" | xmlstarlet unesc | fmt -80&#125; 冷门但有用 expr：计算表达式或正则匹配 m4：简单的宏处理器 yes：多次打印字符串 cal：漂亮的日历 env：执行一个命令（脚本文件中很有用） printenv：打印环境变量（调试时或在写脚本文件时很有用） look：查找以特定字符串开头的单词或行 cut，paste 和 join：数据修改 fmt：格式化文本段落 pr：将文本格式化成页／列形式 fold：包裹文本中的几行 column：将文本格式化成多个对齐、定宽的列或表格 expand 和 unexpand：制表符与空格之间转换 nl：添加行号 seq：打印数字 bc：计算器 factor：分解因数 gpg：加密并签名文件 toe：terminfo 入口列表 nc：网络调试及数据传输 socat：套接字代理，与 netcat 类似 slurm：网络流量可视化 dd：文件或设备间传输数据 file：确定文件类型 tree：以树的形式显示路径和文件，类似于递归的 ls stat：文件信息 time：执行命令，并计算执行时间 timeout：在指定时长范围内执行命令，并在规定时间结束后停止进程 lockfile：使文件只能通过 rm -f 移除 logrotate： 切换、压缩以及发送日志文件 watch：重复运行同一个命令，展示结果并／或高亮有更改的部分 when-changed：当检测到文件更改时执行指定命令。参阅 inotifywait 和 entr。 tac：反向输出文件 shuf：文件中随机选取几行 comm：一行一行的比较排序过的文件 strings：从二进制文件中抽取文本 tr：转换字母 iconv 或 uconv：文本编码转换 split 和 csplit：分割文件 sponge：在写入前读取所有输入，在读取文件后再向同一文件写入时比较有用，例如 grep -v something some-file | sponge some-file units：将一种计量单位转换为另一种等效的计量单位（参阅 /usr/share/units/definitions.units） apg：随机生成密码 xz：高比例的文件压缩 ldd：动态库信息 nm：提取 obj 文件中的符号 ab 或 wrk：web 服务器性能分析 strace：调试系统调用 mtr：更好的网络调试跟踪工具 cssh：可视化的并发 shell rsync：通过 ssh 或本地文件系统同步文件和文件夹 wireshark 和 tshark：抓包和网络调试工具 ngrep：网络层的 grep host 和 dig：DNS 查找 lsof：列出当前系统打开文件的工具以及查看端口信息 dstat：系统状态查看 glances：高层次的多子系统总览 iostat：硬盘使用状态 mpstat： CPU 使用状态 vmstat： 内存使用状态 htop：top 的加强版 last：登入记录 w：查看处于登录状态的用户 id：用户/组 ID 信息 sar：系统历史数据 iftop 或 nethogs：套接字及进程的网络利用情况 ss：套接字数据 dmesg：引导及系统错误信息 sysctl： 在内核运行时动态地查看和修改内核的运行参数 hdparm：SATA/ATA 磁盘更改及性能分析 lsblk：列出块设备信息：以树形展示你的磁盘以及磁盘分区信息 lshw，lscpu，lspci，lsusb 和 dmidecode：查看硬件信息，包括 CPU、BIOS、RAID、显卡、USB设备等 lsmod 和 modinfo：列出内核模块，并显示其细节 fortune，ddate 和 sl：额，这主要取决于你是否认为蒸汽火车和莫名其妙的名人名言是否“有用” 仅限 OS X 系统以下是仅限于 OS X 系统的技巧。 用 brew （Homebrew）或者 port （MacPorts）进行包管理。这些可以用来在 OS X 系统上安装以上的大多数命令。 用 pbcopy 复制任何命令的输出到桌面应用，用 pbpaste 粘贴输入。 若要在 OS X 终端中将 Option 键视为 alt 键（例如在上面介绍的 alt-b、alt-f 等命令中用到），打开 偏好设置 -&gt; 描述文件 -&gt; 键盘 并勾选“使用 Option 键作为 Meta 键”。 用 open 或者 open -a /Applications/Whatever.app 使用桌面应用打开文件。 Spotlight：用 mdfind 搜索文件，用 mdls 列出元数据（例如照片的 EXIF 信息）。 注意 OS X 系统是基于 BSD UNIX 的，许多命令（例如 ps，ls，tail，awk，sed）都和 Linux 中有微妙的不同（ Linux 很大程度上受到了 System V-style Unix 和 GNU 工具影响）。你可以通过标题为 “BSD General Commands Manual” 的 man 页面发现这些不同。在有些情况下 GNU 版本的命令也可能被安装（例如 gawk 和 gsed 对应 GNU 中的 awk 和 sed ）。如果要写跨平台的 Bash 脚本，避免使用这些命令（例如，考虑 Python 或者 perl ）或者经过仔细的测试。 用 sw_vers 获取 OS X 的版本信息。 仅限 Windows 系统以下是仅限于 Windows 系统的技巧。 在 Winodws 下获取 Unix 工具 可以安装 Cygwin 允许你在 Microsoft Windows 中体验 Unix shell 的威力。这样的话，本文中介绍的大多数内容都将适用。 在 Windows 10 上，你可以使用 Bash on Ubuntu on Windows，它提供了一个熟悉的 Bash 环境，包含了不少 Unix 命令行工具。好处是它允许 Linux 上编写的程序在 Windows 上运行，而另一方面，Windows 上编写的程序却无法在 Bash 命令行中运行。 如果你在 Windows 上主要想用 GNU 开发者工具（例如 GCC），可以考虑 MinGW 以及它的 MSYS 包，这个包提供了例如 bash，gawk，make 和 grep 的工具。MSYS 并不包含所有可以与 Cygwin 媲美的特性。当制作 Unix 工具的原生 Windows 端口时 MinGW 将特别地有用。 另一个在 Windows 下实现接近 Unix 环境外观效果的选项是 Cash。注意在此环境下只有很少的 Unix 命令和命令行可用。 实用 Windows 命令行工具 可以使用 wmic 在命令行环境下给大部分 Windows 系统管理任务编写脚本以及执行这些任务。 Windows 实用的原生命令行网络工具包括 ping，ipconfig，tracert，和 netstat。 可以使用 Rundll32 命令来实现许多有用的 Windows 任务 。 Cygwin 技巧 通过 Cygwin 的包管理器来安装额外的 Unix 程序。 使用 mintty 作为你的命令行窗口。 要访问 Windows 剪贴板，可以通过 /dev/clipboard。 运行 cygstart 以通过默认程序打开一个文件。 要访问 Windows 注册表，可以使用 regtool。 注意 Windows 驱动器路径 C:\ 在 Cygwin 中用 /cygdrive/c 代表，而 Cygwin 的 / 代表 Windows 中的 C:\cygwin。要转换 Cygwin 和 Windows 风格的路径可以用 cygpath。这在需要调用 Windows 程序的脚本里很有用。 学会使用 wmic，你就可以从命令行执行大多数 Windows 系统管理任务，并编成脚本。 要在 Windows 下获得 Unix 的界面和体验，另一个办法是使用 Cash。需要注意的是，这个环境支持的 Unix 命令和命令行参数非常少。 要在 Windows 上获取 GNU 开发者工具（比如 GCC）的另一个办法是使用 MinGW 以及它的 MSYS 软件包，该软件包提供了 bash、gawk、make、grep 等工具。然而 MSYS 提供的功能没有 Cygwin 完善。MinGW 在创建 Unix 工具的 Windows 原生移植方面非常有用。 更多资源 awesome-shell：一份精心组织的命令行工具及资源的列表。 awesome-osx-command-line：一份针对 OS X 命令行的更深入的指南。 Strict mode：为了编写更好的脚本文件。 shellcheck：一个静态 shell 脚本分析工具，本质上是 bash／sh／zsh 的 lint。 Filenames and Pathnames in Shell：有关如何在 shell 脚本里正确处理文件名的细枝末节。 Data Science at the Command Line：用于数据科学的一些命令和工具，摘自同名书籍。 免责声明除去特别小的工作，你编写的代码应当方便他人阅读。能力往往伴随着责任，你 有能力 在 Bash 中玩一些奇技淫巧并不意味着你应该去做！;) 授权条款 本文使用授权协议 Creative Commons Attribution-ShareAlike 4.0 International License。]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%9A%84%E8%89%BA%E6%9C%AF%2FREADME-uk%2F</url>
    <content type="text"><![CDATA[🌍Čeština ∙ Deutsch ∙ Ελληνικά ∙ English ∙ Español ∙ Français ∙ Indonesia ∙ Italiano ∙ 日本語 ∙ 한국어 ∙ Português ∙ Română ∙ Русский ∙ Slovenščina ∙ Українська ∙ 简体中文 ∙ 繁體中文 Мистецтво командного рядка Опис Основи Щоденне використання Обробка файлів та інформації Відладка Одним рядком Складно але корисно Тільки для OS X Тільки для Windows Інші джерела Відмова від відповідальності Використанню командного рядка часто не приділяють достатньої уваги. Про термінал говорять, як про щось містичне. Насправді, ці навики явно (і не явно) збільшують вашу продуктивність у роботі. Даний документ є підбіркою на наш погляд корисних при роботі з командним рядком в Linux заміток і порад. Деякі з них - прості та очевидні, але інші - або призначені для вирішення конкретних завдань, або досить складні чи широко невідомі. Це невелика публікація, але якщо ви вже все знаєте, що тут написано, і можете згадати як це все використовувати - ви знаєте багато! Це – результат роботи багатьох авторів і перекладачів.Дещо з цього спочатку з’явилось на Quora, але потім переїхало на Github, де багато людей талановитіших за початкового автора, внесли багато удосконалень.Задайте питання якщо у вас є питання стосовно командного рядка.Будь-ласка, зробіть свій внесок якщо ви знайшли помилку або можете щось покращити! ОписОхоплення: Дана публікація призначена як для початківців, так і для досвідчених користувачів. Цілі: наповнення (зібрати всі важливі аспекти використання командного рядка), практичність (надати конкретні приклади для найпоширеніших ситуацій) та стислість (не варто вдаватись у несуттєві деталі, про які можна прочитати деінде). Цей документ написаний для користувачів Linux, за винятком розділів “Тільки для OS X“ та “[Тільки для Windows(#Тільки-для-Windows)]”. Все інше підходить для всіх UNIX чи OS X систем (і навіть для Cygwin). Сфокусована на інтерактивному Bash, але багато порад також можуть застосовуватися в інших командних оболонках чи загалом до Bash-скриптів. Ця інструкція включає в себе як стандартні Unix команди, так і ті, для використання яких потрібно встановлювати додаткові пакети, якщо користь від застосування команди виправдовує установку пакету. Нотатки: Вся інформація збережена в одному файлі для спрощення пошуку, перекладу та навігації. У вас вистачить вмінь, щоб самостійно вивчити питання більш детально в іншому місці. Використовуйте apt-get, yum, dnf, pacman, pip та brew (залежно від вашої системи управління пакетами) для установки нових програм. На Explainshell можна знайти просте і докладне пояснення того, що таке команди, їх опції, пайпи(pipes(|)) і т.д. Основи Вивчіть основи Bash. Просто візьміть і наберіть у командному рядку термінала man bash і хоча б перегляньте; він досить просто читається і він не дуже великий. Інші шелли теж можуть бути хороші, але Bash - потужна програма, і Bash завжди під рукою (вивчення виключно zsh, fish і т.д., хоч і привабливо на вашому особистому комп’ютері, насправді обмежує в багатьох випадках, наприклад при використанні існуючих серверів). Вивчіть використання хоча б одного консольного редактора тексту. Найкраще Vim (vi), адже у нього немає конкурентів, коли вам потрібно швидко щось правити (навіть якщо ви постійно використовуєте Emacs чи якийсь важкий IDE або модний хіпстерський редактор). Знайте, як читати документацію командою man (для допитливих: man man пояснює номери розділів документації, наприклад 1 - для звичайних команд, 5 - для файлів, 8 - для адміністративних команд). Шукайте інформацію через apropos, і пам’ятайте, що деякі команди - не виконувані (executables), а внутрішні команди Bash, і допомогу по них можна отримати через команду help і help -d. Ви можете з’ясувати чи є Ваша команда виконуваним файлом чи вбудована в shell чи є псевдонім, використовуючи команду type команда. Можна перенаправляти ввід та вивід користуючися &gt;, &lt; та каналами |. Пам’ятайте, що &gt; - переписує вихідний файл, а &gt;&gt; додає до нього. Дізнайтеся побільше про stdout і stderr. Дізнайтеся побільше про розширення шаблонів * (а також ? і […]), про вживанняя лапок та про відмінності між подвійними &quot; та одинарними &#39; лапками. Ознайомтеся, як працювати із процесами в Bash: &amp;, ctrl-z, ctrl-c, jobs, fg, bg, kill, і т.д. Знайте ssh та основи безпарольної аутентифікації через ssh-agent, ssh-add, і т.д. Основи роботи з файлами: ls і ls -l (зокрема, дізнайтеся, що значить кожен стовпець в ls -l), less, head,tail і tail -f (або навіть краще - less +F), ln і ln -s (дізнайтеся про відмінності та переваги символьних і жорстких посилань), chown, chmod, du (для отримання швидкої інформації по використанню диска: du -hk *). Для керування файловою системою: df, mount, fdisk, mkfs, lsblk. Дізнайтеся, що таке inode (ls -i чи df -i). Основи роботи з мережею: ip, ifconfig, dig, traceroute або route. Вивчіть і використовуйте систему управління версіями, наприклад таку, як git. Навчіться писати регулярні вирази і вивчіть різні опції для grep/egrep. Такі опції як -i, -o, -A, та -B варто знати. Навчіться використовувати системами управління пакетами apt-get, yum, dnf та pacman (залежно від дистрибутива). Знайте як шукати і встановлювати пакети. Обов’язково майте встановленим pip для встановки модулів та програм, написаних на Python (деякі з тих команд, що ви знайдете нижче, найлегше встановити через pip). Щоденне використання Використовуйте клавішу табуляції (Tab) в Bash для автодоповнення аргументів до команд та ctrl-r для пошуку по історії командного рядка. Використовуйте ctrl-w в Bash для того, щоб видалити останнє слово в команді; ctrl-u для того, щоб видалити команду повністю. Використовуйте alt-b і alt-f для того, щоб переміщатись між словами у команді, ctrl-k для того, щоб перейти в кінець рядка, ctrl-l для того, щоб очистити екран. Гляньте на man readline щоб дізнатися про всі комбінації клавіш Bash. Їх багато! Наприклад, alt-. переміщається між попередніми аргументам команди, а alt-* максимально розширює аргументи. Якщо вам подобаються клавішні комбінації vim, виконайте set -o vi (set -o emacs щоб повернути налаштування). Для редагування довгих команд після налаштування вашого консольного редактора (наприклад export EDITOR=vim), ctrl-x ctrl-e відкриє поточну команду в редакторі для багаторядкового редагування команди. Або у vi стилі, escape-v. Для того, щоб переглянути історію, введіть history. Також існує безліч абревіатур, наприклад ! $ - Останній аргумент, !! - остання команда, хоча ці абревіатури часто заміняються комбінаціями ctrl-r та alt-.. Перейти в домашню директорію можна за допомогою cd. Щоб вказати шлях до файлів із домашньої директорії можна скористатися префіксом ~ (наприклад: ~/.bashrc). У sh скриптах для звернення до домашньої директорії можна використовувати змінну $HOME. Для того, щоб стрибнути до останньої робочої директорії, використовуйте cd - Якщо ви написали команду наполовину і раптом передумали, натисніть alt-# для того, щоб додати # на початок команди, та відправте команду як коментар. Потім ви зможете повернутися до неї через історію команд. Використовуйти xargs (або parallel). Це дуже корисно. Зверніть увагу, що ви можете контролювати кількість команд на кожен рядок (-L) також паралельність (-P). Якщо ви не впевнені, що робите щось правильно, почніть з xargs echo. Також -I{} - корисно. Приклади: 12find . -name '*.py' | xargs grep some_functioncat hosts | xargs -I&#123;&#125; ssh root@&#123;&#125; hostname pstree -p - допоможе побачити дерево процесів. Grep the output of ps aux to know the pid of a process, like ps aux | grep postgresql Використовуйте pgrep і pkill для того, щоб знаходити або слати сигнали до процесів по імені (-f корисна опція). Знайте різні сигнали, які можна слати процесам. Наприклад, щоб призупинити процес, використовуйте kill -STOP [pid]. Для повного списку подивіться man 7 signal. Використовуйте nohup абоdisown, якщо ви хочете запустити фоновий процес що б він постійно виконувався у фоні. Дізнайтеся, які процеси слухають порти через netstat -lntp або ss -plat (для TCP; додайте -u для UDP). Зверніть увагу на команду lsof і fuser. Вони допоможуть Вам подивитися відкриті сокети і файли. Команда uptime or w показує як довго працює система. Використовуйте alias, щоб створити скорочення для часто використовуємих команд. Наприклад, alias ll=&#39;ls -latr&#39; створить нове скорочення(alias) ll. Збережіть свої синоніми (aliases), налаштування і фунції які ви часто використовуєте у ~/.bashrc, більш детально тут. Це зробить їх доступними в усіх ваших сесіях shell. Синхронізуйте ваші конфігураційні файли (наприклад .bashrc та .bash_profile) між різними комп’ютерами за допомогою Git. Вставте настройки змінних середовища і команди, які повинні бути виконані при вході у систему в файл ~/.bash_profile. Окремі налаштування будуть потрібні для оболонок, які запускаються із під графічного інтерфейсу та з під cron задач. Необхідно розуміти, що потрібна обережність коли змінні та імена файлів включають пробіли. Окружіть ваші Bash змінні в подвійні лапки: &quot;$FOO&quot;. Використовуйте -0 або -print0 опції щоб дозволити розмежувати імена файлів за допомогою нульових(null) символів. Наприклад: locate -0 pattern | xargs -0 ls -al або find / -print0 -type d | xargs -0 ls -al. Щоб перебрати імена файлів які містять пробільні символи для циклу встановіть ваш IFS(API файлової системи) використовувати тільки ‘\n’ для цього використовуйте - IFS=$&#39;\n&#39;. У Bash скриптах використовуйте set -x (або set -v) щоб дебажити вивід. Використовуйте строгий(strict) режим скрізь, де це можливо. Використовуйте set -e для того, щоб припиняти виконання при помилках (не нульовий вихідний код). Використовуйте set -u що б визначити невстановленні змінні. Використовуйте set -o pipefail щоб при помилках невикористовувати пайпи(вертикальна риска). Для більш складних скриптів також використовуйте trap на EXIT or ERR.Корисною буде звичка почати використовувати настипний скрипт, який допоможе виявити і перервати на загальних помилках і вивести повідомлення: 12set -euo pipefailtrap "echo 'error: Script failed: see failed command above'" ERR У Bash-скриптах підоболочки(subshells) - зручний спосіб групувати команди. Один із найпоширеніших прикладів - тимчасово пересунутися в іншу робочу директорію: 123# Do something in current dir(cd / some / other / dir &amp;&amp; other-command)# Continue in original dir У Bash багато типів простору змінних. Перевірити, чи існує змінна - ${name:? Error message}. Наприклад, якщо Bash-скрипту потрібен всього один аргумент, просто напишіть input_file=${1:?usage: $0 input_file}. Арифметична область видимості: i=$(( (i + 1) % 5 )). Послідовності: {1..10}. Обрізка рядків: ${var%suffix} і ${var#prefix}. Наприклад, якщо var=foo.pdf тоді echo ${var%.pdf}.txt виведе foo.txt. Фігурні скобки, використовуючи {…} може зменшити необхідність повторно вводити той самий текст і автоматизувати. Це корисно в такому прикладі як mv foo.{txt,pdf} some-dir (який пересуває обидва файла), cp somefile{,.bak} (який розширюється у cp somefile somefile.bak) або mkdir -p test-{a,b,c}/subtest-{1,2,3} (яка розширює всі можливі комбінації і створює дерево деректорій). Вивід будь-якої команди можна обробити як файл наступним чином &lt;(some command). Наприклад, порівняння локального файлу `/etc/hosts з віддаленим: 1diff /etc/hosts &lt;(ssh somehost cat /etc/hosts) Знайте про heredoc -синтаксис в Bash: cat &lt;&lt; EOF .... У Bash перенаправляйте стандартні потоки виводу(output) та помилок, ось так: some-command &gt;logfile 2&gt;&amp;1. Найчастіше, для того, щоб переконатись, що команда не залишить відкритим файл, прив’язавши його до відкритого терміналу, вважається хорошою практикою додавати &lt;/dev/null. Використовуйте man ascii щоб отримати таблицю ASCII символів із шіснадцядковими і десятковими значеннями. Для інших основних кодувань користуйтесь: man unicode,man utf-8 і man latin1. Використовуйте screen або tmux для того, щоб мати кілька екранів в одному терміналі. Це особливо корисно в ssh сесії що б приєднатись чи відєднатись до сесії. byobu розширює функціонал screen або tmux надає більше інформації і полегшить керування. Більш мінімалістичною альтернативою для цього є dtach. У SSH корисно знати як зробити port tunnel з опціями -L і-D (іноді -R) це корисно наприклад для того, щоб отримати доступ до сайту із віддаленого сервера. Ще може бути корисно зробити декілька оптимізацій у конфігурації вашого SSH, наприклад у файлі ~/.ssh/config містить налаштування, які допомагають уникати втрачених підключень в деяких мережевих оточеннях, використати стиснення (яке корисне при використанні scp при повільному підключенні) і збільште кількість каналів до одного сервера через цей конфіг, ось так: 1234567TCPKeepAlive=yesServerAliveInterval=15ServerAliveCountMax=6Compression=yesControlMaster autoControlPath /tmp/%r@%h:%pControlPersist yes Деякі із інших налаштування SSH можуть сильно вплинути на безпеку і повинні мінятися обережно, наприклад, для конкретної підмережі, конкретної машини або в домашніх мережах: StrictHostKeyChecking=no, ForwardAgent=yes Розглянемо mosh як альтернатива ssh який використовує UDP, уникаючи розривів підключеня (вимагає установки на стороні сервера). Щоб отримати права доступу до файлу у вісімковому вигляді, що є корисно для конфігурації систем але не можна отримати з допомогою команди ls, можна використовувати щось схоже на це: 1stat -c '%A %a %n' /etc/timezone Для інтерактивного виділення результатів інших команд використовуйте percol або fzf. Для роботи з файлами, список яких дала інша команда (наприклад git), використовуйте fpp (PathPicker). Щоб швидко підняти веб-сервер в поточній директорії (і піддерикторіях), який доступний для всіх у вашій мережі, використовуйте:python -m SimpleHTTPServer 7777 (на прту 7777 і для Python 2) або python -m http.server 7777 (на прту 7777 і для Python 3). Щоб виконати команду з привілеями, використовуйте sudo (для root) і sudo -u (для іншого користувача). Використовуйте su або sudo bash, щоб запустити шелл від імені цього користувача. Використовуйте su -, щоб симулювати свіжий вхід під root або під іншим користувачем. Обробка файлів та інформації Для того, щоб знайти файл в поточній директорії, виконайте find. -iname &#39;*something*&#39;. Для того, щоб шукати файл по всій системі, використовуйте locate something (але не забувайте, що updatedb міг ще не проіндексувати нещодавно створені файли). Для пошуку по вмісту або фалах (більш детально зробити пошук допоможе grep -r) використовуйте ag. Для конвертації HTML в текст: lynx -dump -stdin Для конвертації різних типів розмітки (HTML, Markdown та ін.) спроробуйте утиліту pandoc. Якщо нуобхідно працювати з XML, є стара, але хороша утиліта - xmlstarlet. Для роботи з JSON використовуйте jq. Для YAML використовуйте shyaml. Для Excel і CSV файлів csvkit надає in2csv, csvcut, csvjoin, csvgrep і т.д. Для Amazon S3 s3cmd є зручним і s4cmd є швидшим. Для решти сервісів Амазону використовуйте стандартний aws і удосконалений saws. Знайте про sort і uniq, включаючи опції -u і -d, дивіться приклади нижче. Ще спробуйте comm. Знайте про cut, paste, і join для роботи з текстовими файлами. Багато людей використовують cut, забувши про join. Знайте про wc: для підрахунку нових рядків (-l), символів (-m), слів (-w) і для байтового підрахунку (-c). Знайте про tee для копіювання в файл з stdin і stdout, щось типу ls -al | tee file.txt. Не забувайте, що ваші налаштування консолі та мовні/регіональні налаштування (локаль) впливають на багато команд, включаючи порядок сортування, порівняння і продуктивність. Багато дистрибутиви Linux автоматично виставляють LANG або будь-яку іншу змінну в підходящу для вашого регіону. Через це результати функцій сортування можуть працювати непередбачувано. Знайте що i18n можуть значно знизити продуктивність сортувань. У деяких випадках можна повністю цього уникати (за винятком рідкісних випадків), сортуючи традиційно побайтово, використовуйте export LC_ALL = C. Ви можете встановити спецефічне середовище для команди за допомогогю префікса, а саме: TZ=Pacific/Fiji date. Знайте основи awk і sed для простих маніпуляцій з даними. Наприклад, щоб отримати суму всіх чисел, які знаходяться в третій колонці текстового файлу, можна використати awk &#39;{ x += $3 } END { print x }&#39;. Швидше за все, це вийде в рази 3 швидше і рази в 3 простіше, ніж робити це в Пітоні. Щоб замінити всі входження підрядка в одному або декількох файлах: 1perl -pi.bak -e 's/old-string/new-string/g' my-files-*.txt Щоб перейменувати відразу багато файлів за шаблоном, використовуйте rename. Для складних перейменувань може допомогти repren: 1234# Recover backup files foo.bak -&gt; foo:rename 's/\.bak$//' *.bak# Full rename of filenames, directories, and contents foo -&gt; bar:repren --full --preserve-case --from foo --to bar . Як говорить man сторінка, rsync дійсно є швидким і універсальним інструментом копіювання файлів, для синхронізації між машинами, але в рівній мірі корисні на локальному рівні. Також швидке рішення що б видалити велику кількість файлів: 1mkdir empty &amp;&amp; rsync -r --delete empty/ some-dir &amp;&amp; rmdir some-dir Використовуйте shuf, щоб перемішати або вибрати випадкові рядки з файлу. Знайте опції для команди sort. Для чисел використовуйте -n або -h, для роботи з числами (наприклад du -h). Знайте як працюють ключі (-t і -k). Зокрема, не забувайте, що вам потрібно писати -k1,1 для того, щоб впорядкувати тільки перше поле; -k1 - це означає сортування враховуючи цілий рядок. Може бути корисною (sort -s). Наприклад для того, щоб відсортувати найважливіше по другому полю, а другорядне по першому, можна використовувати sort -k1,1 | sort -s -k2,2. Якщо вам коли-небудь доведеться написати код символу табуляції в терміналі, наприклад, для сортування за табуляції з прапором -t, використовуйте скорочення ctrl-v [Tab] або напишіть $&#39;\t&#39;. Останнє краще, тому що його можна скопіювати/вставити. Стандартні інструменти для виправлення вихідного коду це diff і patch. Також зверніть увагу на diffstat для перегляду статистики diff і sdiff для крок за кроком diff. Запамятайте diff -r працює рекурсивно по всій директорії. Використовуйте diff -r tree1 tree2 | diffstat для повного зведення змін. Використовуйте vimdiff порівняти і редагувати файли. Для бінарних файлів використовуйте hd, hexdump або xxd для простих hex-дампом, і bvi, hexedit або biew для зміни бінарників. Також для бінарних файлів, strings (плюс grep, і т.п.) дозволить вам знайти біти тексту. Щоб подивитися різницю в бінарниках (дельта-кодування): xdelta3. Для конвертування кодувань використовуйте iconv. Для більш складних завдань - uconv, він підтримує деякі складні фічі Юникода. Наприклад, ця команда переводить рядки з файлу в нижній регістр і прибирає наголоси (наприклад в іспанській мові) 1uconv -f utf-8 -t utf-8 -x '::Any-Lower; ::Any-NFD; [:Nonspacing Mark:] &gt;; ::Any-NFC; ' &lt; input.txt &gt; output.txt Для того, щоб розбити файл на шматки, використовуйте split (розбиває на шматки за розміром), або csplit (за шаблоном або по регулярному виразу). Для дати і часу використовуйте dateadd, datediff, strptime ще можете знайти на dateutils. Використовуйте zless, zmore, zcat, і zgrep для роботи зі стиснутими файлами. Відладка Для відладки веб сторінок використовуйте curl і curl -I, або альтернативу - wget або httpie. Щоб отримати інформацію про диск/CPU/мережі використовуйте iostat, netstat, top (краще htop) і dstat. Використовуйте iostat -mxz 15 для отримання основної інформації CPU. Для інформації про мережу використовуйте netstat і ss. Для більш детальної інформації використовуйте glances. Ця програма показує відразу кілька різних статистик в одному вікні терміналу. Корисно, коли стежите за відразу декількома системами. Для того, щоб стежити за пам’яттю вокористовуйте free і vmstat. Зокрема, не забувайте, що значення кешування (“cached” value) - Це пам’ять, яку тримає ядро і ці значення є частиною free. Використовуйте mtr для збору статистики трасування(простежити маршрут до віддаленого сервера), щоб знаходити проблеми мережі. Для того, щоб дізнатися, чому диск повністю забитий, використовуйте ncdu, це зберігає час у порівнянні з тим же du -sh *. Для того, щоб дізнатися, який сокет або процес використовує інтернет, використовуйте iftop або nethogs. Додаток ab який поставляється разом з apache, корисний для швидкої і поверхневої перевірки продуктивності веб-сервера. Для більш серйозного лоад-тестінгу використовуйте siege. Для більш серйозної відладки мережі використовуйте wireshark, tshark, і ngrep. Знайте про strace та ltrace. Ці команди можуть бути корисні, якщо програма падає або висить, і ви не знаєте чому або якщо ви хочете протестувати продуктивність програми. Не забувайте про можливість відладки (-c) і можливість причепитися до процесу по pid (-p). ldd для перевірки системних бібліотек. Знайте як причепитися до працюючого процесу через gdb і отримати трасування стека. Використовуйте /proc. Іноді він неймовірно корисний для налагодження запущених програм. Приклади: /proc/cpuinfo, /proc/xxx/cwd, ​​/proc/xxx/exe, /proc/xxx/fd/, /proc/xxx/smaps (де xxx id or pid процесу). Коли дебажите щось, що зламалося в минулому, використовуйте sar буває дуже корисно. Показує історію та статистику CPU, пам’яті, мережі і т.д. Для аналізу більш складних систем і продуктивності використовуйте stap (SystemTap), perf) і sysdig. Дізнайтеся, яка у вас операційна система, через uname або uname -a (інформація про ядро) або lsb_release -a (інформація про дистрибутив Linux). Використовуйте dmesg, коли щось відбувається зовсім дивне (це можуть бути проблеми із залізом, драйверами, тощо). Одним рядкомКілька прикладів склеювання команд: Це досить круто, що можна знайти множинни перетину файлів, з’єднати відсортовані файли і подивитися різницю декількох файлів через sort/uniq. Це швидкий підхід і працює на файлах будь-якого розміру (включаючи багатогігабайтні файли). (Сортування не обмежено пам’яттю, але можливо вам доведеться додати -T, якщо /tmp знаходиться на невеликому логічному диску). Ще подивіться на те, що було сказано вище про LC_ALL. Опція сортування -u не використовується нижче, щоб було зрозуміліше: 123cat a b | sort | uniq &gt; c # c is a union bcat a b | sort | uniq -d &gt; c # c is a intersect bcat a b b | sort | uniq -u &gt; c # c is set difference a - b Використовуйте grep . * для того, щоб подивитися вміст всіх файлів в директорії. Це може бути корисно для директорій заповнених конфігураціями як ці в /sys, /proc, /etc. Просумувати всі числа, які знаходяться в третій колонці текстового файлу (це в 3 рази швидше і 3 рази простіше, ніж робити це в Пітоні) можна наступним чином: 1awk '&#123; x += $3 &#125; END &#123; print x &#125;' myfile Щоб побачити розмір/дату файлів в дереві, це як рекурсивний ls -l але легше ls -lR: 1find . -type f -ls Скажемо що у нас є якийсь текстовий файл, наприклад лог веб сервера і на якихось рядках з’являється значення, рядки з яким нам цікаві. Наприклад, acct_id. Давайте підрахуємо, скільки таких запитів в нашім логу: 1cat access.log | egrep -o 'acct_id=[0-9]+' | cut -d= -f2 | sort | uniq -c | sort -rn Використовуйте xargs (або parallel). Зверніть увагу, що ви можете контролювати кількість команд на кожен рядок, а так само паралельність. Якщо ви не впевнені, що робите правильно, почніть з xargs echo. Ще -I {} - корисна штука. Приклади: 12find. -name '* .py' | xargs grep some_functioncat hosts | xargs -I &#123;&#125; ssh root @ &#123;&#125; hostname Запустіть цю функцію, щоб отримати випадкову вибірку із цього документа: 1234567function taocl() &#123; curl -s https://raw.githubusercontent.com/jlevy/the-art-of-command-line/master/README.md | pandoc -f markdown -t html | xmlstarlet fo --html --dropdtd | xmlstarlet sel -t -v "(html/body/ul/li[count(p)&gt;0])[$RANDOM mod last()+1]" | xmlstarlet unesc | fmt -80&#125; Складно але корисно expr: для виконання арифметичних і булевих операцій, а також регулярних виразів m4: простий макро-процесор yes: безкінечно виводить рядок зі словом “yes” cal: хороший календар env: показує змінні середовища (корисно в Bash-скриптах) printenv: показує змінні оточення (корисно в скриптах або при відладці) look: виведе рядки у файлі які починаються із заданого слова/підрядка cut, paste і join: маніпуляції з даними fmt: форматування параграфів у тексті pr: відформатовує текст в сторінки/колонки fold: (обернути) обмежити довжину рядків у файлі column: форматувати текст в колонки або таблиці expand і unexpand: конвертація між табами і пробілами nl: додає номери до рядків seq: вивести послідовність чисел bc: калькулятор factor: піднести число в степінь gpg: зашифрувати і підписати файли toe: таблиця терміналів terminfo з описом nc: відладка мережі і передачі даних socat: перемикач сокетів і перенаправлення tcp-портів (схоже на netcat) slurm: візуалізація трафіку мережі dd: перенесення інформації між файлами або пристроями file: визначає тип файлу tree: показує директорії і піддиректорії у вигляді дерева, як ls, але рекурсивно stat: інформація про файл time: виведе інформацію про час виконання команди/програми timeout: зупиняє виконання команди після того як завершиться вказаний час в аргументі lockfile: створює позначку в файлі який може бути видаленим тільки через команду rm -f logrotate: змінити, зжати і відправити логи. watch: запустити команду повторно, показуючи результати і/або виділення змін tac: вивести файли посимвольно навпаки shuf: випадкова вибірка рядків з файлу comm: порядково порівняти відсортовані файли pv: моніторинг прогресу проходження інформації через пайп hd, hexdump, xxd, biew і bvi: дамп і редагування бінарних файлів strings: витягнути текст із бінарних файлів tr: маніпуляція з char (символьним типом) iconv або uconv: конвертація кодувань split і csplit: розбити файли sponge: прочитати весь інпут перед тим, як його записати. Корисно, коли читаєш з того ж файлу, куди записуєш. Наприклад, ось так: grep -v something some-file | sponge some-file units: використовується для конвертації одиниць вимірювання (дивіться /usr/share/units/definitions.units) apg: генерація паролів 7z: архіватор з високим ступенем стиснення ldd: показує залежності програми від системних бібліотек nm: symbols from object files ab: вбудований в Apache бенчмарк веб-серверів strace або wrk: відладка системних викликів mtr: трасування для відладки мережі cssh: паралельне виконання команд в графічному інтерфейсі rsync: синхронізація файлів і папок через SSH або на локальній файловій системі wireshark і tshark: перехоплення пакетів і відладка мережі ngrep: grep мережевого рівня host і dig: пошук в DNS lsof: інформація про файлові дескриптори та сокети dstat: корисна статистика ОС glances: сумарна статистика багатьох підсистем iostat: статистика системи вводу/виводу жорстких дисків mpstat: статистика використання CPU vmstat: статистика використання оперативної пам’яті htop: вдосконалена версія top last: історія входів у систему w: хто є залогіненим id: інформація про користувача/групу sar: historic system stats iftop або nethogs: використання мережі конкретним сокетом або процесом ss: статистика сокетів dmesg: помилки завантаження і помилки системи sysctl: перегляду і налаштування параметрів ядра Linux коли воно запущене hdparm: маніпуляція/налаштування SATA/ATA диску lsblk: cписок блокових пристроїв комп’ютера: дерево ваших дисків і логічних дисків lshw, lscpu, lspci, lsusb, dmidecode: інформація про апаратне забезпечення, включає CPU, BIOS, RAID, графічну карту і т.д. lsmod і modinfo: показує список і детальну інформацію модулів ядра. fortune, ddate, and sl: um, well, it depends on whether you consider steam locomotives and Zippy quotations “useful” Тільки для OS XДеякі речі, які підходять тільки для Мака. Система управління пакетами - brew (Homebrew) і port (MacPorts) можуть бути використані для того, щоб встановити більшість програм, згаданих у цьому документі. Копіюйте вивід будь-якої консольної команди до графічної за допомогою pbcopy і вставляйте вивід за допомогою pbpaste. Щоб відкрити файл або десктопну програму, використовуйте open або open -a /Applications/Whatever.app. Spotlight: Шукає файли в консолі, через mdfind, і дивиться метадані (наприклад EXIF ​​інформацію із фотографії) із mdls. Не забувайте, що MacOS створений на основі BSD Unix і багато команд (наприклад ps, ls, tail, awk, sed) мають невеликі відмінності від лінуксових. Це обумовлено впливом UNIX System V і GNU Tools. Різницю можна помітити, побачивши заголовок “BSD General Commands Manual.” Інколи на MacOS можна поставити GNU-версії програм, наприклад gawk і gsed. Коли пишете кросплатформені Bash-скрипти, намагайтеся уникати використовувати команди, які можуть відрізнятися (наприклад, краще використовуйте Python або perl), або ретельно все перевіряйте. Тільки для Windows Ви можете використовувати Unix shell у Windows, встановивши Cygwin. Встановіть ще Unix програми за допомогою менеджера пакетів Cygwin. Використовуйте mintty в якості термінала. Ви можете працювати із буфером обміну Windows за допомогою /dev/clipboard. Запустіть cygstart, щоб відкрити файл за допомогою програми, що встановлена за замовчуванням. Працювати з реєстром Windows можна за допомогою regtool. Майте на увазі, що диск C:\ доступний в Cygwin за шляхом /cygdrive/c, / являється папкою C:\cygwin. Конвертуйте шляхи до файлів за допомогою cygpath. Ви можете запускати і автоматизувати більшість задач з адміністрування Windows із командного рядка, оволодівши wmic. Інші джерела awesome-shell: Розширює Shell. awesome-osx-command-line: Поглиблений посібник до командного рядка OS X. Strict mode щоб краще писати Shell скрипти. shellcheck: A shell script static analysis tool. Essentially, lint for bash/sh/zsh. Filenames and Pathnames in Shell: The sadly complex minutiae on how to handle filenames correctly in shell scripts. Відмова від відповідальностіЗа невеликим винятком, весь код написаний так, щоб інші його змогли прочитати.Той факт, що щось може бути написано на Bash, зовсім не означає, що воно має бути на ньому написано. ;) Ліцензія Ця работа і переклад на Українську мову розповсюджується за ліцензією Creative Commons Attribution-ShareAlike 4.0 International License.]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%9A%84%E8%89%BA%E6%9C%AF%2FREADME-sl%2F</url>
    <content type="text"><![CDATA[🌍Čeština ∙ Deutsch ∙ Ελληνικά ∙ English ∙ Español ∙ Français ∙ Indonesia ∙ Italiano ∙ 日本語 ∙ 한국어 ∙ Português ∙ Română ∙ Русский ∙ Slovenščina ∙ Українська ∙ 简体中文 ∙ 繁體中文 Umetnost ukazne vrstice Meta Osnove Vsakodnevna uporaba Procesiranje datotek in podatkov Sistemsko razhroščevanje V eni vrstici Nepregledno vendar uporabno Samo za macOS Samo za Windows Več virov Pogoji uporabe Jedrnatost v ukazni vrstici je znanje, ki je pogostokrat zanemarjeno ali smatrano za zastarelo, vendar izboljša vašo fleksibilnost in produktivnost kot inženir na očitne in neočitne načine. To so izbrani zapiski in nasveti glede uporabe ukazne vrstice, ki smo jo našli uporabno pri delu z Linux-om. Nekateri nasveti so elementarni in nekateri so precej določeni, sofisticirani ali nepregledni. Ta stran ni dolga, vendar če lahko uporabite in se spomnite vseh elementov tu, boste vedeli veliko. To delo je rezultat mnogih avtorjev in prevajalcev.Nekaj tegase je prvotnopojavilona Quori,vendar se je premaknilo na GitHub, kjer so ljudje bolj talentirani od prvotnega avtorja naredili številne izboljšave.Vprašajte, če imate vprašanje povezano z ukazno vrstico. Prosimo, prispevajte, če vidite napako ali nekaj, kar bi lahko bilo boljše! MetaObseg: Ta vodič je tako za začetnike kot za poznavalce. Cilji so širina (vse pomembno), specifičnost (podaja konkretne primere najpogostejših primerov uporabe) in kratkost (izogiba se stvarem, ki niso bistvene ali se odmikajo, kar lahko enostavno pogledate drugje). Vsak nasvet je bistven v določeni situaciji ali bistveno prihrani čas pred alternativami. To je napisano za Linux z izjemo sekcij “Samo za macOS“ in “Samo za Windows“. Mnogi ostali elementi veljajo ali pa so lahko nameščeni na drugih Unix-ih ali macOS (ali celo Cygwin). Poudarek je na interaktivnosti Bash-a, čeprav mnogo nasvetov velja za ostale lupine in splošno skriptanje Bash-a. Vključuje tako “standardne” ukaze Unix-a kot tudi tiste, ki zahtevajo namestitev posebnih paketov – dokler so dovolj pomembni, da zaslužijo vključitev. Opombe: Da se obdrži to na eni strani, je vsebina implicitno vključena z referencami. Ste dovolj pametni, da poiščete več podrobnosti drugje, ko enkrat poznate idejo ali ukaz za iskanje na Google-u. Uporabite apt-get, yum, dnf, pacman, pip ali brew (kot je ustrezno), da namestite nove programe. Uporabite Explainshell, da dobite uporabne razčlenitve, kaj ukazi, opcije, cevi itd. naredijo. Osnove Naučite se osnovni Bash. Dejansko vtipkajte man bash in vsaj prelistajte celotno stvar; slediti je precej enostavno in ni tako dolgo. Alternativne lupine so lahko lepe, vendar Bash je močan in vedno na voljo (učenje samo zsh, fish itd., medtem ko poskušate na lastno pest na vašem prenosniku, vas omeji v mnogih situacijah, kot je uporaba obstoječih strežnikov). Dobro se naučite vsaj enega izmed tekstovnih urejevalnikov. Urejevalnik nano je eden izmed najenostavnejših za osnovno urejanje (odpiranje, urejanje, shranjevanje, iskanje). Vendar za bolj vešče uporabnike v tekstovnem terminalu, ni zamenjave za Vim (vi), težko priučljiv vendar častljiv, hiter urejevalnik poln možnosti. Mnogi uporabljajo tudi klasični Emacs, še posebej za večja opravila urejanja. (Seveda, katerikoli moderni razvijalec, ki dela na razširljivem projektu, ne bo uporabljal samo čisto tekstovnega urejevalnika in bi moral biti seznanjen tudi z modernimi IDE in orodji z grafičnimi vmesniki.) Spoznajte, kako brati dokumentacijo z man (za radovedne, man man izpiše številke sekcij, npr. 1 so “splošni” ukazi, 5 so datoteke/konvencije in 8 je za administracijo). Najdite strani man z apropos. Vedite, da nekateri ukazi niso izvršljivi, vendar vgrajeni v Bash in pomoč zanje lahko dobite s help in help -d. Z uporabo type command lahko izvedete, ali je ukaz izvršljiv, vgrajen v lupino ali pa je alias. Naučite se o preusmeritvi izpisa in vnosa z uporabo &gt; in &lt; ter uporabo cevi |. Vedite, da &gt; prepiše izpis datoteke in &gt;&gt; ga pripne. Naučite se o stdout in stderr. Naučite se o razširitvi datotek glob z * (in mogoče ? ter […]) in citiranje ter razliko med dvojnim &quot; in enojnim &#39; citatom. (Poglejte več o razširitvi spremenljivk spodaj.) Seznanite se z upravljanjem nalog Bash-a: &amp;, ctrl-z, ctrl-c, jobs, fg, bg, kill itd. Spoznajte ssh in osnove avtentikacije brez gesla, preko ssh-agent, ssh-add itd. Osnovno upravljanje datotek: ls in ls -l (še posebej se naučite, kaj vsak stolpec v ls -l pomeni), less, head, tail in tail -f (ali celo boljše, less +F), ln in ln -s (naučite se razlike in prednosti trdih in mehkih povezav), chown, chmod, du (za hiter povzetek uporabe diska: du -hs *). Za upravljanje datotečnega sistema, df, mount, fdisk, mkfs, lsblk. Naučite se, kaj je inode (ls -i or df -i). Osnovno upravljanje omrežja: ip ali ifconfig, dig, traceroute, route. Naučite se in uporabljajte sistem za nadzor različic, kot je git. Poznajte tudi splošne izraze in različne zastavice za grep/egrep. Opcije -i, -o, -v, -A, -B in -C so vredne poznavanja. Naučite se uporabljati apt-get, yum, dnf ali pacman (odvisno od distribucije), da najdete in namestite pakete. In zagotovite, da imate pip, da lahko nameščate orodja ukazne vrstice na osnovi Python-a (nekaj spodnjih je najenostavneje namestiti preko pip). Vsakodnevna uporaba V Bash-u uporabite Tab za dokončanje argumentov ali izpis vseh ukazov, ki so na voljo, in ctrl-r, da iščete skozi zgodovino ukazov (po pritiski, vtipkajte za iskanje, pritisnite ctrl-r s ponavljanjem za kroženje skozi več ujemanj, pritisnite Enter, da izvršite najdeni ukaz, ali pritisnite desno puščico, da date trenutni rezultat v trenutno vrstico in omogočite urejanje). V Bash-u uporabite ctrl-w, da izbrišete zadnjo besedo in ctrl-u, da izbrišete vse do začetka vrstice. Uporabite alt-b in alt-f, da se premikate po besedah, ctrl-a, da premaknete kurzor na začetek vrstice, ctrl-e, da premaknete kurzor na konec vrstice, ctrl-k, da ubijete do začetka vrstice, ctrl-l, da počistite zaslon. Glejte man readline za vse privzete vezave tipk v Bash-u. Na voljo jih je veliko. Na primer alt-. kroži skozi prejšnje argumente in alt-* razširi glob. Alternativno, če imate radi vi-stilske vezave tipk, uporabite set -o vi (in set -o emacs za povrnitev nazaj). Za urejanje dolgih ukazov, po nastavitvi vašega urejevalnika (na primer export EDITOR=vim), ctrl-x ctrl-e bo odprlo trenutni ukaz v urejevalniku za več vrstično urejanje. Ali v stilu vi, escape-v. Če si želite ogledati nedavne ukaze, uporabite history. Nadalje !n (kjer je n številka ukaza), da ga ponovno izvedete. Na voljo je tudi veliko okrajšav, najuporabnejša verjetno !$ za zadnji argument in !! za zadnji ukaz (glejte “HISTORY EXPANSION” na man straneh). Vendar so le-te pogostokrat enostavno zamenjane s ctrl-r in alt-.. Pojdite v vaš domači direktorij s cd. Dostopajte do datotek relativno glede na vaš domači direktorij s predpono ~ (npr. ~/.bashrc). V sh skriptah se sklicujte na domači direktorij kot $HOME. Da greste nazaj na prejšnji delovni dirketorij: cd - Če ste na pol poti skozi vpisovanje ukaza, vendar si premislite, vtipkajte alt-#, da dodate # na začetek in ga vnesete kot komentar (ali uporabite ctrl-a, #, enter). Nato se lahko vrnete k njemu kasneje preko zgodovine ukazov. Uporabite xargs (ali parallel). Je zelo močan. Bodite pozorni, da lahko kontrolirate, kolikokrat izvršite na vrstico (-L) kot tudi paralelnost (-P). Če niste prepričani, da bo naredilo pravilno stvar, uporabite najprej xargs echo. Tudi -I{} je priročen. Primeri: 12find . -name '*.py' | xargs grep some_functioncat hosts | xargs -I&#123;&#125; ssh root@&#123;&#125; hostname pstree -p je priročen prikaz drevesa procesov. Uporabite pgrep in pkill, da najdete ali signalizirate procese po imenu (-f je v pomoč). Poznajte različne signale, katerim lahko pošljete procese. Na primer, da suspendirate proces, uporabite kill -STOP [pid]. Za celotni seznam glejte man 7 signal Uporabite nohup ali disown, če želite, da proces iz ozadja vedno poteka. Preverite, kateri procesi se poslušajo preko netstat -lntp ali ss -plat (za TCP; dodajte -u za UDP) ali lsof -iTCP -sTCP:LISTEN -P -n (kar deluje tudi na macOS). Glejte tudi lsof in fuser za odprte priključke in datoteke. Glejte uptime ali w, da izveste, koliko časa se sistem poganja. Uporabite alias, da ustvarite bližnjice za pogosto uporabljene ukaze. Na primer, alias ll=&#39;ls -latr&#39; ustvari nov alias ll. Shranite aliase, nastavitve lupine in funkcije, ki jih pogosto uporabljate v ~/.bashrc in uredite prijave lupin za izvorno kodo. To bo naredilo vašo namestitev na voljo v vseh sejah vaše lupine. Dajte nastavitve spremenljivk okolja kot tudi ukaze, ki bi morali biti izvršeni, ko se prijavite v ~/.bash_profile. Ločena nastavitev bo potrebna za lupine, ki jih zaženete iz prijave grafičnega okolja in s periodičnimi opravili cron. Sinhronizirajte vaše nastavitvene datoteke (npr. .bashrc in .bash_profile) med različnimi računalniki s pomočjo Git. Razumite, da je potrebna skrb, ko spremenljivke in imena datotek vsebujejo prazne znake. Obdajte vaše spremenljivke Bash s citati, npr. &quot;$FOO&quot;. Raje cenite opciji -0 ali -print0, da omogočite razmejevanje imen datotek z ničelnimi znaki, npr. locate -0 pattern | xargs -0 ls -al ali find / -print0 -type d | xargs -0 ls -al. Za iteracijo v for zanki na imenih datotek, ki vsebujejo prazne znake, nastavite da vaš IFS za nove vrstice uporablja samo IFS=$&#39;\n&#39;. V skriptah Bash uporabite set -x (ali varianto set -v, ki beleži dnevnik surovega izpisa, vključno z nerazširjenimi spremenljivkami in komentarji) za razhroščevanje izpisa. Uporabite striktni način razen, če imate dober razlog, da ga ne: Uporabite set -e, da preskočite napake (neničelna koda izhoda). Uporabite set -u, da zaznate uporabo nenastavljenih spremenljivk. Premislite tudi o set -o pipefail, da na napakah znotraj pip, (vendar preberite o tem več, če boste to uporabili, saj je ta tema nekoliko subtilna). Za bolj vključene skripte, uporabite tudi trap pri EXIT ali ERR. Uporabna navada je tako začeti skripto, kar bo naredilo, da lahko zazna ali prekliče na pogostih napakah in izpiše sporočilo: 12set -euo pipefailtrap "echo 'error: Script failed: see failed command above'" ERR V skriptah Bash so podlupine (napisane z oklepaji) priročen način za grupiranje ukazov. Skupen primer je začasno premakniti na različen delovni direktorij, npr. 123# do something in current dir(cd /some/other/dir &amp;&amp; other-command)# continue in original dir V Bash-u bodite pozorni, saj je veliko vrst razširjenih spremenljivk. Preverjanje, če spremenljivka obstaja: ${name:?error message}. Na primer, če skripta Bash zahteva en argument, samo napišite input_file=${1:?usage: $0 input_file}. Uporaba privzete vrednosti, če je spremenljivka prazna: ${name:-default}. Če želite, imeti dodatni (opcijski) parameter dodan k prejšnjemu primeru, lahko uporabite nekaj takega output_file=${2:-logfile}. Če je $2 izpuščen in tako prazen, bo output_file nastavljen na logfile. Aritmetična raširitev: i=$(( (i + 1) % 5 )). Sekvence: {1..10}. Obrezovanje nizov: ${var%suffix} in ${var#prefix}. Na primer, če je var=foo.pdf, potem echo ${var%.pdf}.txt izpiše foo.txt. Lupinska razširitev zavitih oklepajev z {…} lahko pomaga zmanjšati potrebo po ponovnem vpisovanju podobnega teksta in avtomatizira kombiniranje elementov. To je v pomoč v primerih kot je mv foo.{txt,pdf} some-dir (ki premakne obe datoteki), cp somefile{,.bak} (kar razširi v cp somefile somefile.bak) ali mkdir -p test-{a,b,c}/subtest-{1,2,3} (kar razširi vse možne kombinacije in ustvari drevo direktorijev). Razširitev zavitih oklepajev je izvedena pred katerokoli drugo razširitvijo. Vrstni red razširitev je: razširitev zavitega oklepaja; razširitev tilda, razširitev parametra in spremenljivke, aritmetična razširitev in zamenjava ukaza (izvedeno na način levo proti desnem); delitev besed; in razširitev imena datoteke. Na primer, obseg kot je {1..20} ne more biti izražen s spremenljivkami z uporabo {$a..$b} ob predpostavki a=1 in b=20 in doprinese {1..20}. Uporabite seq ali for zanko, npr., seq $a $b ali for((i=a; i&lt;=b; i++)); do ... ; done. Izpis ukaza se lahko tretira kot datoteko preko &lt;(some command) (znan kot proces zamenjave). Na primer, primerjajte lokalno /etc/hosts z oddaljeno: 1diff /etc/hosts &lt;(ssh somehost cat /etc/hosts) Ko pišete skripte, boste morda želeli dati vašo kodo v zavite oklepaje. Če zapirajoči se oklepaj manjka, se vaša skripta ne bo izvršila zaradi sintaktične napake. To je smiselno, ko se vašo skripto prenese iz spleta, saj preprečuje izvrševanje delno prenešene skripte: 123&#123; # Vaša koda&#125; T.i. “here document” omogoča preusmeritev večih vrstic vnosa kot da gre za datoteko: 1234cat &lt;&lt; EOFThese lines willprint to stdoutEOF V Bash-u je preusmeritev obeh standardov izpisa in standardnih napak preko: some-command &gt;logfile 2&gt;&amp;1 ali some-command &amp;&gt;logfile. Pogosto zagotavlja, da ukaz ne pusti ročaja odprte datoteke za standardni vnos, kar ga veže na terminal v katerem se nahajate, je tudi dobra praksa, da dodate &lt;/dev/null. Uporabite man ascii za dobro tabelo ASCII s heksadecimalnimi in decimalnimi vrednostmi. Za splošne informacije enkodiranja so priročni man unicode, man utf-8 in man latin1. Uporabite screen ali tmux, da muliplicirate zaslon, posebej uporabno na oddaljenih sejah ssh in da odstranite in se ponovno pripnete k seji. byobu lahko poveča t.i. screen ali tmux s ponujanjem več informacij in enostavnejšim upravljanjem. Bolj minimalna alternativa za samo obstojnost sej je dtach. V ssh je poznavanje, kako usmeriti tunel z -L ali -D (in občasno -R) je uporaben, npr. za dostopanje do spletnih strani iz oddaljenega strežnika. Lahko je uporabno, da se naredi nekaj optimizacij na vaših nastavitvah ssh; na primer, ta ~/.ssh/config vsebuje nastavitve za izogib padle povezave v določenih okoljih omrežja, uporablja kompresijo (ki je v pomoč s scp preko nizko pasovnih povezav) in multiplicira kanale na isti strežnik z lokalno krmilno datoteko: 1234567TCPKeepAlive=yesServerAliveInterval=15ServerAliveCountMax=6Compression=yesControlMaster autoControlPath /tmp/%r@%h:%pControlPersist yes Nekaj ostalih opcij relevantnih za ssh je varnostno občutljivih in bi morale biti omogočene s pazljivostjo, npr. na podomrežju ali gostitelju ali v zaupljivih omrežjih: StrictHostKeyChecking=no, ForwardAgent=yes Premislite o mosh kot alternativi za ssh, ki uporablja UDP, da se izognete padlim povezavam in dodate priročnost, ko ste na poti (zahteva nastavitev strežniške strani). Da dobite pravice na datoteki v osmiškem zapisu, ki je uporaben za nastavitve sistema vendar ni na voljo pri ls in enostaven za mešanje, uporabite nekaj takega kot je 1stat -c '%A %a %n' /etc/timezone Za interaktivno izbiro vrednosti iz izpisa drugega ukaza, uporabite percol ali fzf. Za interakcijo z datotekami osnovanimi na izpisu drugega ukaza (kot je git), uporabite fpp (PathPicker). Za enostaven spletni strežnik za vse datoteke v trenutnem direktoriju (in poddirektorijih), ki so na voljo komurkoli v vašem omrežju, uporabite:python -m SimpleHTTPServer 7777 (za port 7777 in Python 2) in python -m http.server 7777 (za port 7777 in Python 3). Za pogon ukaza pod drugim uporabnikom, uporabite sudo. Privzeto požene kot root; uporabite -u, da določite drugega uporabnika. Uporabite -i za prijavo tega uporabnika (vprašalo vas bo za vaše geslo). Za preklop lupine na drugega uporabnika, uporabite su username ali su - username. Pripona - dobi okolje, kakor da bi se drug uporabnik ravnokar prijavil. Izpustitev uporabniškega imena pomeni privzeto root. Vprašani boste za geslo uporabnika na katerega preklapljate. Spoznajte omejitev 128K v ukaznih vrsticah. Ta napaka “Argument list too long” je pogosta, ko se nadomestni znak ujema z velikim številom datotek. (Ko se to zgodi, lahko pomagajo alternative kot sta find in xargs.) Za osnovni kalkulator (in seveda splošni dostop do Python-a) uporabite interpreter python. Na primer, 12&gt;&gt;&gt; 2+35 Procesiranje datotek in podatkov Da locirate datoteko po imenu v trenutnem direktoriju, find . -iname &#39;*something*&#39; (ali podobno). Da najdete datoteko kjerkoli po imenu, uporabite locate something (vendar imejte v mislih, da updatedb morda ni poindeksiral nazadnje ustvarjenih datotek). Za splošno iskanje skozi izvorne ali podatkovne datoteke, na voljo je nekaj možnosti bolj naprednih in hitrejših možnosti od grep -r, vključno z (po surovem vrstnem redu od starejših do novejših) ack, ag (“t.i. silver searcher”) in rg (ripgrep). Da pretvorite HTML v tekst: lynx -dump -stdin Za Markdown, HTML in vse vrste pretvorb dokumentov poskusite pandoc. Če morate upravljati z XML, je xmlstarlet star vendar dober. Za JSON, use jq. Za interaktivnost glejte tudi jid in jiq. Za YAML, uporabite shyaml. Za Excel ali CSV datoteke, csvkit ponuja in2csv, csvcut, csvjoin, csvgrep itd. Za Amazon S3 je priročen s3cmd in s4cmd je hitrejši. Amazon-ov aws in izboljšan saws sta bistvena za druga AWS-povezana opravila. Naučite se o sort in uniq vključno z uniq-ovima opcijama -u in -d – glejte spodaj sekcijo v eni vrstici. Glejte tudi comm. Naučite se o cut, paste in join za manipuliranje tekstovnih datotek. Mnogi uporabljajo cut vendar pozabijo na join. Naučite se o wc, da preštejete nove vrstice (-l), znake (-m), besede (-w) in bajte (-c). Naučite se o tee, da prekopirate iz stdin v datoteko in tudi v stdout, kot pri ls -al | tee file.txt. Za kompleksnejše kalkulacije, vključno z združevanjem, obračanjem polj in statističnimi izračuni, razmislite o datamash. Vedite, da lokalizacija vpliva na veliko orodij ukazne vrstice na subtilne načine, vključno z vrstnim redom (kolokacijo) in uspešnostjo. Večina namestitev Linux-a bo nastavila LANG ali druge spremenljivke lokalizacije na lokalne nastavitve kot je US English. Vendar bodite pozorni, saj se bo vrstni red spremenil, če spremenite lokalizacijo. In vedite, da rutine i18n lahko naredijo sortiranje ali poganjanje drugih ukazov nekajkrat počasnejše. V nekaterih situacijah (kot je skupek operacij ali unikatnih operacij spodaj) lahko v celoti varno ignorirate počasne rutine i18n in uporabite tradicionalne vrstne rede na osnovi bajtov z uporabo export LC_ALL=C. Nastavite lahko določeno okolje ukaza s predpono njegovega sklicevanja na nastavitve spremenljivk okolja, kot pri TZ=Pacific/Fiji date. Spoznajte osnove awk in sed za enostavno manipuliranje podatkov. Za primere glejte sekcijo v eni vrstici. Da zamenjate vsa pojavljanja niza na mestu v eni ali večih datotekah: 1perl -pi.bak -e 's/old-string/new-string/g' my-files-*.txt Da preimenujete več datotek in/ali poiščete in poiščete in zamenjate znotraj datotek, poskusite repren. (V nekaterih primerih ukaz rename tudi omogoča preimenovanje, vendar bodite pozorni, saj funkcionalnost ni enaka na vseh distribucijah Linux). 123456# Full rename of filenames, directories, and contents foo -&gt; bar:repren --full --preserve-case --from foo --to bar .# Recover backup files whatever.bak -&gt; whatever:repren --renames --from '(.*)\.bak' --to '\1' *.bak# Same as above, using rename, if available:rename 's/\.bak$//' *.bak Kot pravi stran vodiča, je rsync resnično hiter in izredno vsestransko orodje kopiranja datotek. Znano je po sinhronizaciji med napravami vendar je enakovredno uporaben tudi lokalno. Ko omejitve varnosti omogočajo, uporaba rsync namesto scp omogoča povrnitev prenosa brez ponovnega zagona od začetka. Je tudi eden izmed najhitrejših načinov za izbris velikega števila datotek: 1mkdir empty &amp;&amp; rsync -r --delete empty/ some-dir &amp;&amp; rmdir some-dir Za spremljanje napredka med kopiranjem datotek uporabite pv, pycp, pmonitor, progress, rsync --progress, ali za kopiranje na nivoju blokov dd status=progress. Uporabite shuf za naključno mešanje ali izbiro naključnih vrstic iz datoteke. Poznajte opcije za sort. Za številke uporabite -n ali -h za upravljanje številk človeku prijaznih za branje (npr. iz du -h). Vedite, kako delujejo ključi (-t in -k). Še posebej pazite, da morate zapisati -k1,1, da razvrstite samo po prvem polju; -k1 pomeni razvrščanje glede na celotno vrstico. Stabilno razvrščanje (sort -s) je lahko uporabno. Na primer, da sortirate najprej po polju 2 in nato po polju 1, lahko uporabite sort -k1,1 | sort -s -k2,2. Če kadarkoli potrebujete zapisati tabulator dobesedno v ukazni vrstici v Bash-u (npr. za sortiranje argumenta -t), pritisnite ctrl-v [Tab] ali zapišite $&#39;\t&#39; (slednji je boljši, saj ga lahko kopirate in prilepite). Standardna orodja za popravljanje izvorne kode so diff in patch. Glejte tudi diffstat za povzetek statistike diff-a in sdiff za diff drug ob drugem. Bodite pozorni, saj diff -r deluje za celotne direktorije. Uporabite diff -r tree1 tree2 | diffstat za povzetek sprememb. Uporabite vimdiff za primerjanje in urejanje datotek. Pri binarnih datotekah uporabite hd, hexdump ali xxd za enostavne heksadecimalne izpise in bvi, hexedit, ali biew za binarno urejanje. strings (plus grep itd.) vam omogoča najti bite v tekstu tudi za binarne datoteke. Za binarne diff-e (delta kompresije) uporabite xdelta3. Da pretvorite enkodiranje teksta, poskusite iconv. Ali uconv za bolj napredno uporabo; podpira nekaj naprednih Unicode stvari. Na primer: 12345# Prikaže hex kode ali dejanska imea znakov (uporabno za razhroščevanje):uconv -f utf-8 -t utf-8 -x '::Any-Hex;' &lt; input.txtuconv -f utf-8 -t utf-8 -x '::Any-Name;' &lt; input.txt# Male črke in odstrani vsa naglasna znamenja (z razširitvijo in opustitvijo):uconv -f utf-8 -t utf-8 -x '::Any-Lower; ::Any-NFD; [:Nonspacing Mark:] &gt;; ::Any-NFC;' &lt; input.txt &gt; output.txt Da razcepite datoteke na dele, glejte split (da razcepite po velikosti) in csplit (da razcepite po vzorcu). Datum in čas: Da dobite trenutni datum in čas v priročnem ISO 8601 formatu, uporabite date -u +&quot;%Y-%m-%dT%H:%M:%SZ&quot; (ostale opcije so problematične). Za manipuliranje izrazov datuma in časa, uporabite dateadd, datediff, strptime itd. iz dateutils. Uporabite zless, zmore, zcat in zgrep za operiranje na kompresiranih datotekah. Atributi datotek so nastavljivi preko chattr in ponujajo nizko nivojsko alternativo pravicam datotek. Na primer za zaščito pred ponesrečenim brisanjem datoteke se uporabi nespremenljiva zastavica: sudo chattr +i /critical/directory/or/file Uporabite getfacl in setfacl, da shranite in povrnete pravice datotek. Na primer: 12getfacl -R /some/path &gt; permissions.txtsetfacl --restore=permissions.txt Za hitro ustvarjanje praznih datotek, uporabite truncate (ustvari t.i. sparse file), fallocate (ext4, xfs, btrfs in ocfs2 datotečni sistemi), xfs_mkfile (skoraj katerikoli datotečni sistem, pride skupaj s paketom xfsprogs), mkfile (za Unix in podobne sisteme kot sta Solaris in Mac OS). Sistemsko razhroščevanje Za spletno razhroščevanje, sta priročna curl in curl -I ali pa njun ekvivalent wget, ali bolj moderen httpie. Da izveste trenutni status diska/procesorja/omrežja, so na voljo klasična orodja top, (ali bolje htop), iostat in iotop . Uporabite iostat -mxz 15 za osnovno statistiko CPU in podrobno na particijo statistiko diska in vpogled v uspešnost. Za podrobnosti omrežne povezave uporabite netstat in ss. Za hiter pregled, kaj se dogaja na sistemu, je dstat posebno uporaben. Za širši pregled s podrobnostmi uporabite glances. Da izveste status spomina, poženite in razumite izpis free in vmstat. Še posebej bodite pozorni, da je vrednost “cached” držana v spominu s strani jedra Linux-a kot datoteka predpomnilnika, tako da efektivno šteje proti vrednosti “free”. Sistemsko razhroščevanje Java je drugačen tip, vendar enostaven trik na JVM-jih Oracle-a in nekaterih ostalih je, da lahko poženete kill -3 &lt;pid&gt; in sledite celotnemu stack-u in povzetku kopic (vključno s podrobnostmi zbirke splošnih smeti, ki so lahko zelo informativne), ki bodo oddane v stderr/logs. JDK-jevi jps, jstat, jstack, jmap so uporabni. SJK Tools so bolj napredni. Uporabite mtr kot boljši usmerjevalnik sledenja za identifikacijo težav omrežja. Za iskanje, zakaj je disk poln, vam ncdu prihrani čas preko običajnih ukazov kot je du -sh *. Da najdete katera vtičnica ali proces uporablja pasovno širino, poskusite iftop ali nethogs. Orodje ab (prihaja z Apache-jem) je v pomoč za hitro in nečisto preverjanje uspešnosti spletnega strežnika. Za bolj kompleksno testiranje nalaganja poskusite siege. Za bolj resno razhroščevanje omrežja, wireshark, tshark ali ngrep. Poznajte strace in ltrace. Ta sta v pomoč, če program ni uspešen, se ustavlja ali poruši in ne veste zakaj, ali če želite dobiti splošno idejo o uspešnosti. Bodite pozorni na opcijo profiliranja (-c) in zmožnost dodajanja k procesu, ki se poganja (-p). Uporabite podrejene opcije trace (-f), da se izognete manjkajočim pomembnim klicem. Poznajte ldd, da preverite deljene knjižnice itd. — vendar nikoli ne poženite na nezaupljivih datotekah. Vedite, kako se povezati k procesu v pogonu z gdb in dobiti njegove sledi skladovnice. Uporabite /proc. Včasih je izjemno v pomoč, ko se razhroščuje probleme v živo. Primeri: /proc/cpuinfo, /proc/meminfo, /proc/cmdline, /proc/xxx/cwd, /proc/xxx/exe, /proc/xxx/fd/, /proc/xxx/smaps (kjer je xxx id procesa ali pid). Ko se razhroščuje, zakaj je šlo nekaj narobe v preteklosti, je lahko zelo uporaben sar. Prikazuje statistiko zgodovine na procesorju, spominu, omrežju itd. Za globlje analize sistema in uspešnosti, poglejte stap (SystemTap), perf in sysdig. Preverite na katerem operacijskem sistemu ste z uname ali uname -a (splošne informacije Unix-a/jedra) ali lsb_release -a (informacije distribucuje Linux). Uporabite dmesg kadarkoli gre nekaj dejansko čudno (lahko je težava strojne opreme ali gonilnika). Če izbrišete datoteko in se prostor na voljo ne poveča, kot je pričakovano s poročilom du, preverite ali datoteko uporablja proces:lsof | grep deleted | grep &quot;filename-of-my-big-file&quot; V eni vrsticiNekaj primerov sestavljanja ukazov skupaj: Včasih je izredno v pomoč, da lahko nastavite presek, unijo in razliko tekstovnih datotek preko sort/uniq. Predpostavimo a in b sta tekstovni datoteki, ki sta že unikatni. To je hitro in deluje na datotekah arbitrarnih velikosti do nekaj gigabajtov. (Urejanje ni omejeno glede na spomin, čeprav morda potrebujete uporabiti opcijo -T, če je /tmp na majhni root particiji.) Glejte tudi opombo o LC_ALL zgoraj in sort-ovo opcijo -u (puščeno zaradi jasnosti spodaj). 123sort a b | uniq &gt; c # c is a union bsort a b | uniq -d &gt; c # c is a intersect bsort a b b | uniq -u &gt; c # c is set difference a - b Uporabite grep . *, da hitro preučite vsebine vseh datotek v direktoriju (vsaka vrstica ima par z imenom datoteke) ali head -100 * (da iima vsaka datoteka glavo). To je lahko uporabno za direktorije napolnjene s konfiguracijskimi nastavitvami, kot so tiste v /sys, /proc, /etc. Povzetje vseh številk v tretjem stolpcu tekstovne datoteke (to je verjetno 3X hitrejše in 3X manj kode kot Python-ov ekvivalent): 1awk '&#123; x += $3 &#125; END &#123; print x &#125;' myfile Da vidite velikost/datume v drevesu datotek, je to kot rekurzivni ls -l vendar enostavnejše za branje kot ls -lR: 1find . -type f -ls Recimo, da imate tekstovno datoteko, kot dnevnik spletnega strežnika in določena vrednost se pojavi na nekaterih vrsticah, kot parameter acct_id, ki je prisoten v URL-ju. Če želite ujemanja, koliko je zahtevkov za vsak acct_id: 1egrep -o 'acct_id=[0-9]+' access.log | cut -d= -f2 | sort | uniq -c | sort -rn Da neprekinjeno nadzirate spremembe, uporabite watch, npr. preverite spremembe datotek v direktoriju z watch -d -n 2 &#39;ls -rtlh | tail&#39; ali med odpravljanjem težav vaših nastavitev wifi z watch -d -n 2 ifconfig. Poženite to funkcijo, da dobite naključni nasvet iz tega dokumenta (razčleni Markdown in izvleče element): 12345678function taocl() &#123; curl -s https://raw.githubusercontent.com/jlevy/the-art-of-command-line/master/README.md | sed '/cowsay[.]png/d' | pandoc -f markdown -t html | xmlstarlet fo --html --dropdtd | xmlstarlet sel -t -v "(html/body/ul/li[count(p)&gt;0])[$RANDOM mod last()+1]" | xmlstarlet unesc | fmt -80 | iconv -t US&#125; Nepregledno vendar uporabno expr: izvede aritmetične ali logične operacije ali oceni splošne izraze m4: enostaven makro procesor yes: velikokrat izpiše niz cal: lep koledar env: požene ukaz (uporabno v skriptah) printenv: izpiše spremenljivke okolja (uporabno pri razhroščevanju in v skriptah) look: najde angleške besede (ali vrstice v datoteki) začenši z nizom cut, paste in join: manipulacija podatkov fmt: oblikuje odstavke teksta pr: oblikuje tekst v strani/stolpce fold: ovije vrstice teksta column: oblikuje tekstovna polja v poravnane stolpce s fiksno širino ali tabele expand in unexpand: pretvori med tabulatorji in presledki nl: doda vrstice številk seq: izpiše številke bc: kalkulator factor: celo številski faktorji gpg: enkriptira in podpiše datoteke toe: tabela vnosov terminfo nc: rahroščevanje omrežja in prenos podatkov socat: rele vtičnice in odpravnik tcp porta (podobno kot netcat) slurm: vizualizacija prometa omrežja dd: premikanje podatkov med datotekami in napravami file: identifikacija tipa datoteke tree: prikaže direktorije in poddirektorije kot gnezdeno drevo; kot ls vendar rekurzivno stat: informacije datoteke time: izvrši in da ukaz v čas timeout: izvršite ukaz za določen čas in ustavite proces, ko se določen čas konča. lockfile: ustvari semaforno datoteko, ki je lahko odstranjena samo z rm -f logrotate: rotiranje, kompresiranje in pošiljanje dnevnikov po e-pošti. watch: večkrat požene ukaz in prikazuje rezultate in/ali poudari spremembe when-changed: požene kateri koli ukaz, ki ga določite, kadarkoli opazi spremembo datoteke. Glejte tudi inotifywait in entr. tac: izpiše datoteke v obratnem redu comm: primerja sortirane datoteke vrstico za vrstico strings: izvleče tekst iz binarnih datotek tr: prevod znakov ali manipulacija iconv ali uconv: pretvorba enkodiranja teksta split in csplit: cepljenje datotek sponge: prebere vse vnose pred pisanjem, uporabno za branje iz njih in nato za pisanje v isto datoteko, npr. grep -v something some-file | sponge some-file units: pretvorba enot in kalkulacije; pretvori furlonge (osmino milje) na štirinajst dni v dvajsetine točke na blink (glejte tudi /usr/share/units/definitions.units) apg: generira naključna gesla xz: kompresija datoteke visokega razmerja ldd: informacije dinamične knjižnice nm: simboli iz datotek objekta ab ali wrk: merjenje uspešnosti spletnih strežnikov strace: razhroščevanje sistemskega klica mtr: boljše sledenje usmerjanja za razhroščevanje omrežja cssh: vizualna sočasna lupina rsync: sinhronizacija datotek in map preko SSH ali v lokalnem datotečnem sistemu wireshark in tshark: zajem paketov in razhroščevanje omrežja ngrep: grep za nivo omrežja host in dig: pogled DNS lsof: procesira deskriptorje datoteke in informacije vtičnice dstat: uporabna statistika sistema glances: visoko nivojski, večkratni podsistemski pregled iostat: statistika uporabe diska mpstat: statistika uporabe procesorja vmstat: statistika uporabe spomina htop: izboljšana verzija top last: zgodovina prijav w: kdo je prijavljen id: informacije identifikacije uporabnika/skupine sar: statistika zgodovine sistema iftop ali nethogs: izkoriščenost omrežja po vtičnici ali procesu ss: statistika vtičnice dmesg: sporočila napak zagona in sistema sysctl: ogled in nastavitev parametrov jedra Linux pri pogonu hdparm: manipulacija/uspešnost SATA/ATA disk-a lsblk: izpiše blokovne naprave: drevesni pogled vaših diskov in particij diska lshw, lscpu, lspci, lsusb, dmidecode: informacije strojne opreme, vključno s procesorjem, BIOS-om, RAID-om, grafiko, napravami itd. lsmod in modinfo: izpišeta in prikažeta podrobnosti o modulih jedra. fortune, ddate in sl: hm, torej zavisi glede na to ali smatrate parne lokomotive in dinamične kotacije “uporabne” Samo za macOSTo so elementi pomembni samo za macOS. Upravljanje paketov z brew (Homebrew) in/ali port (MacPorts). Te so lahko uporabljeni za namestitev mnogih zgornjih ukazov na macOS. Kopirajte izpis katerega koli ukaza na namizno aplikacijo s pbcopy in prilepite vnos iz ene s pbpaste. Da omogočite uporabo tipke Option v macOS terminalu kot tipka alt (kot je uporabljena v ukazih zgoraj kot alt-b, alt-f itd), odprite Preferences -&gt; Profiles -&gt; Keyboard in izberite “Use Option as Meta key”. Da odprete datoteko z namizno aplikacijo, uporabite open ali open -a /Applications/Whatever.app. Spotlight: Poiščite datoteke z mdfind in izpišite meta podatke (kot so EXIF informacije fotografije) z mdls. Bodite pozorni, saj je macOS osnovan na BSD Unix in mnogi ukazi (na primer ps, ls, tail, awk, sed) imajo mnoge subtilne različice iz Linux-a, na katerega je večinoma vplival System V-style Unix in GNU tools. Pogostokrat lahko poveste razliko tako, da opazite, da ima stran man naslov “BSD General Commands Manual.” V nekaterih primerih se lahko namestijo tudi GNU različice (kot so gawk in gsed za GNU awk in sed). Če pišete skripte Bash za vse platforme, se izogibajte takim ukazom (na primer, z upoštevanjem Python ali perl) ali pazljivo testirajte. Da dobite informacije o izdaji macOS, uporabite sw_vers. Samo za WindowsSledeče velja samo za Windows. Načini pridobitve Unix orodij na Windows Dostopajte do moči lupine Unix na Microsoft Windows z namestitvijo Cygwin. Večina stvari opisanih v tem dokumentu bo delala “Out of the Box”. Na Windows 10 lahko uporabite Windows Subsystem for Linux (WSL), ki ponuja znano okolje Bash z orodji ukazne vrstice Unix. Če želite v glavnem uporabljati GNU razvojna orodja (kot je GCC) na Windows, premislite o MinGW in njegovem paketu MSYS, ki ponuja orodja, kot so bash, gawk, make in grep. MSYS nima vseh funkcij v primerjavi s Cygwin. MinGW je posebej uporaben za ustvarjanje izvornih Windows prenosov orodij Unix. Druga opcija, da dobite izgled in občutek Unix-a na Windows-u, je Cash. Upoštevajte, da so v tem okolju na voljo le nekateri ukazi Unix in opcije ukazne vrstice. Uporabna Windows orodja ukazne vrstice Izvajate in kodirate lahko večino sistemskih opravil Windows iz ukazne vrstice, če se naučite uporabljati wmic. Izvorna mrežna orodja ukazne vrstice Windows, ki jih morda najdete uporabne, vključujejo ping, ipconfig, tracert in netstat. Izvajate lahko mnoga upporabna opravila Windows s klicem ukaza Rundll32. Cygwin nasveti in triki Namestite dodatne programe Unix z upraviteljem paketov Cygwin. Uporabite mintty za vaše okno ukazne vrstice. Do odložišča Windows dostopajte preko /dev/clipboard. Poženite cygstart, da odprete poljubno datoteko preko njene registrirane aplikacije. Do registra Windows dostopajte z regtool. Upoštevajte, da pot diska Windows C:\ postane v Cygwin /cygdrive/c in Cigwin-ov / se na Windows pojavi pod C:\cygwin. Pretvorite med Cygwin in Windows stilom poti datotek s cygpath. To je najbolj uporabno v skriptah, ki se sklicujejo na programe Windows. Več virov awesome-shell: urejan seznam orodij lupine in virov. awesome-osx-command-line: Bolj poglobljen vodič za macOS ukazno vrstico. Strict mode za pisanje boljših skript lupine. shellcheck: lupinska skripta orodja statične analize. V osnovi, lint za bash/sh/zsh. Filenames and Pathnames in Shell: Na žalost kompleksne podrobnosti, kako pravilno ravnati z imeni datotek v lupinskih skriptah. Data Science at the Command Line: Več koristnih ukazov in orodij za uporabo v znanosti podatkov iz knjige z enakim imenom. Pogoji uporabeZ izjemo zelo majhnih opravil je koda napisana tako, da jo lahko ostali berejo. Z močjo pride odgovornost. Dejstvo, da lahko naredite nekaj v Bash-u ne pomeni nujno, da bi morali! ;) Licenca To delo je izdano pod Creative Commons Attribution-ShareAlike 4.0 International License.]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%9A%84%E8%89%BA%E6%9C%AF%2FREADME-ru%2F</url>
    <content type="text"><![CDATA[🌍Čeština ∙ Deutsch ∙ Ελληνικά ∙ English ∙ Español ∙ Français ∙ Indonesia ∙ Italiano ∙ 日本語 ∙ 한국어 ∙ Português ∙ Română ∙ Русский ∙ Slovenščina ∙ Українська ∙ 简体中文 ∙ 繁體中文 Искусство командной строки Описание Основы Ежедневное использование Обработка файлов и информации Отладка системы В одну строчку Сложно, но полезно OS X only Windows only Больше информации по теме Дисклеймер Продвинутому использованию командной строки зачастую не уделяют достаточного внимания. О терминале говорят как о чем-то мистическом. На самом же деле, это умение очевидно (и не очевидно) увеличивает Вашу продуктивность в работе. Данный документ является подборкой заметок и советов, которые я нашел для себя полезными, работая с командной строкой в Linux. Некоторые из них – простые и очевидные, но некоторые - довольно сложные. И предназначены для решения конкретных задач. Это небольшая публикация, но если Вы уже знаете обо всем, что тут написано, и можете вспомнить, как это все использовать – вы много знаете! Этот гайд является результатом работы большого числа авторов и переводчиковМногое из того, что тут написано,изначальнопоявилосьна Quora,начав идею там, похоже, что стоит развить ее на Github, где обитают люди, которые талантливее меня и могут предлагать улучшения данной подборки. Если Вы заметили ошибки (во всех вариантах перевода), пожалуйстаоставьте тикет или добавьте пулл-реквест (заранее изучив описание и посмотрев на уже созданнные тикеты и пулл-реквесты). ОписаниеОсновное: Данная публикация предназначена как для новичков, так и для опытных людей. Цели: объемность (собрать все важные аспекты использования командной строки), практичность (давать конкретные примеры для самых частых юзкейсов) и краткость (не стоит углубляться в неочевидные вещи, о которых можно почитать в другом месте). Этот документ написан для пользователей Linux, за исключеним секций “OS X only“ и “Windows only“. Все остальное подходит и может быть установлено под все UNIX/OS X системы (и даже Cygwin). Фокусируемся на интерактивном Баше, но многие вещи также могут быть использованы с другими шеллами; и в общем применимы к Баш-скриптингу. Эта инструкция включает в себя стандартные Unix команды и те, для которых нужно устанавливать сторонние пакеты. Они настолько полезны, что стоят того, чтобы их установили. Заметки: Для того, чтобы руководство оставалось одностраничным, вся информация вставлена прямо сюда. Вы достаточно умные для того, чтобы самостоятельно изучить вопрос более детально в другом месте. Используйте apt-get, yum, dnf, pacman, pip или brew (в зависимости от вашей системы управления пакетами) для установки новых программ. На Explainshell можно найти простое и подробное объяснение того, что такое команды, флаги, пайпы и т.д. Основы Выучите основы Баша. Просто возьмите и напечатайте man bash в терминале и хотя бы просмотрите его; он довольно просто читается и он не очень большой. Другие шеллы тоже могут быть хороши, но Баш – мощная программа, и Баш всегда под рукой (использование исключительно zsh, fish и т.д., которые наверняка круто выглядят на Вашем ноутбуке, во многом Вас ограничивает, например, Вы не сможете использовать возможности этих шеллов на уже существующем сервере). Выучите как использовать хотя бы один консольный редактор текста. Идеально Vim (vi), ведь у него нет конкурентов, когда вам нужно быстренько что-то подправить (даже если Вы постоянно сидите на Emacs/какой-нибудь тяжелой IDE или на каком-нибудь модном хипстерском редакторе). Знайте как читать документацию через man (для любознательных – man man; man по углам документа в скобках добавляет номер, например: 1 – для обычных команд, 5 – для файлов, конвенций, 8 – для административных команд). Ищите мануалы через apropos, и помните, что некоторые команды – не бинарники, а встроенные команды Баша, и помощь по ним можно получить через help и help -d. С помощью type command можно определить, чем является команда - исполняемым файлом, алиасом или встроенной командой шелла. Узнайте о том, как перенаправлять ввод и вывод через &gt; и &lt; и пайпы |. Помните, что &gt; переписывает выходной файл, а &gt;&gt; дописывает в конец. Узнайте побольше про stdout и stderr. Узнайте побольше про раскрытие file glob элементов * (а также ? и {…}), кавычки, а также разницу между двойными &quot; и одинарными &#39; кавычками (больше о расширении переменных читайте ниже). Освойте управление процессами в Bash: &amp;, ctrl-z, ctrl-c, jobs, fg, bg, kill и т.д. Знайте ssh и основы беспарольной аутентификации через ssh-agent, ssh-add и т.д. Основы работы с файлами: ls и ls -l (в частности, узнайте, что значит каждый столбец в ls -l), less, head, tail и tail -f (или даже лучше – less +F), ln и ln -s (узнайте разницу между символьными ссылками и жёсткими ссылками, и почему жёсткие ссылки лучше), chown, chmod, du (для быстрой сводки по использованию диска: du -hk *). Для менеджмента файловой системы, df, mount, fdisk, mkfs, lsblk. Узнайте что такое inodes (ls -i или df -i). Основы работы с сетью: ip или ifconfig, dig. Освойте работу с системой контроля версий, например, git. Хорошо знайте регулярные выражения и разные флаги к grep/egrep. Такие флаги, как -i, -o, -v, -A, -B и -C стоит знать. Обучитесь использованию систем управления пакетами apt-get, yum, dnf или pacman (в зависимости от дистрибутива), чтобы искать и устанавливать пакеты и обязательно имейте установленым pip для установки командных утилит, написанных на Python (некоторые из тех, что вы найдёте ниже, легче всего установить через pip). Ежедневное использование Используйте таб в Баше для автодополнения аргументов к командам и ctrl-r для поиска по истории командной строки (после нажатия введите запрос, нажмите ctrl-r снова, чтобы найти следующее совпадение, нажмите Enter для выполнения текущей найденной команды или стрелку вправо, чтобы отредактировать команду). Используйте ctrl-w в Баше для того, чтобы удалить последнее слово в команде; ctrl-u для того, чтобы удалить команду полностью. Используйте alt-b и alt-f для того, чтобы бегать между словами команды, ctrl-a и ctrl-e для того, чтобы переместиться к началу и концу строки соответственно, ctrl-k для того, чтобы удалить часть команды от текущей позиции до конца строки, ctrl-l для того, чтобы очистить экран. Гляньте на man readline, чтобы узнать о всех клавиатурных сочетаниях Баша. Их много! Например, alt-. бежит по предыдущим аргументам команды, а alt-* раскрывает глоб (globbing). Если Вам нравятся клавиатурные сочетания vim, сделайте set -o vi (и set -o emacs, чтобы вернуться обратно). Для редактирования длинных команд после установки другого редактора (например export EDITOR=vim), нажатие ctrl-x ctrl-e откроет текущую команду в редакторе для многострочного редактирования. Или, как в vi, escape-v. Для просмотра последних команд используйте history. Повторить команду: !n (где n - порядковый номер истории). Также есть много сокращений, например, !$ (последний аргумент) и !! (последняя команда) (сверьтесь со страницей man “HISTORY EXPANSION”). Впрочем, их часто проще заменить с помощью ctrl-r и alt-.. Перейти в домашнюю директорию можно с помощью cd. Для указания пути к файлам из домашней директории можно воспользоваться префиксом ~ (например, ~/.bashrc). В sh скриптах для обращения к домашней директории можно использовать переменную $HOME. Для того, чтобы перейти к предыдущей рабочей директории, используйте cd -. Если вы написали команду наполовину и вдруг передумали, нажмите alt-# для того, чтобы добавить # к началу, и отправьте команду как комментарий (или используйте ctrl-a, #, enter). Потом вы сможете вернуться к ней через историю. Не забывайте использовать xargs (или parallel). Это очень мощная штука. Обратите внимание, что вы можете контролировать количество команд на каждую строку (-L), а также параллельность (-P). Если вы не уверены, что делаете что-то правильно, начните с xargs echo. Еще -I{} – полезная штука. Примеры: 12find . -name '*.py' | xargs grep some_functioncat hosts | xargs -I&#123;&#125; ssh root@&#123;&#125; hostname pstree -p – полезный тип вывода дерева процессов. Используйте pgrep или pkill для того, чтобы находить/слать сигналы к процессам по имени (-f помогает). Знайте разные сигналы, которые можно слать процессам. Например, чтобы приостановить процесс, используйте kill -STOP [pid]. Для полного списка посмотрите man 7 signal. Используйте nohup или disown, чтобы процесс в фоне выполнялся бесконечно. Узнайте, какие процессы слушают порты через netstat -lntp или ss -plat (для TCP; добавьте -u для UDP). Используйте lsof для того, чтобы посмотреть открытые сокеты и файлы. Используйте uptime или w для того, чтобы узнать продолжительность работы системы. Используйте alias, чтобы поименовать часто используемые команды. Например, alias ll=&#39;ls -latr&#39; создаст новое сокращение ll. Сохраняйте псевдонимы (aliases), настройки оболочки и часто используемые сокращения в ~/.bashrc, и организуйте их подгрузку. Это сделает ваши настройки доступными во всех сессиях оболочки. Пропишите настройки переменных окружения и команды, которые должны быть выполнены при входе в систему в файл ~/.bash_profile. Отдельная настройка будет необходима для оболочек, которые запускаются из GUI и cron. Синхронизируйте ваши конфигурационные файлы (например, .bashrc и .bash_profile) между разными компьютерами с помощью Git. Помните, что необходима осторожность при работе с переменными, которые содержат пробелы. Оберните свои переменные в кавычки, например &quot;$FOO&quot;. Предпочтительно использовать -0 или -print0 флаги, чтобы использовать нулевой символ для разделения имен файлов, например: locate -0 pattern | xargs -0 ls -al или find / -print0 -type d | xargs -0 ls -al. Для циклов, которые используют имена файлов, содержащие пробелы, установите IFS чтобы символом новой строки был только \n:IFS=$&#39;\n&#39;. В Баш-скриптах используйте set -x (или вариант set -v, который логгирует сырой ввод, включая нераскрытые переменные и комментарии) для того, чтобы отлаживать вывод (output). Используйте строгие режимы везде, где возможно. Используйте set -e для того, чтобы прекращать выполнение при ошибках (ненулевой код возврата). Используйте set -u, чтобы определять использование неинициализированных переменных. Используйте set -o pipefail для того, чтобы строго относиться к ошибкам (это немного глубокая тема). Для более сложных скриптов также используйте trap на EXIT или ERR. Полезная привычка - начинать скрипт примерно так (это поможет обнаружить ошибки и выведет предупреждение): 12set -euo pipefailtrap "echo 'error: Script failed: see failed command above'" ERR В Баш-скриптах подоболочки (subshells) – удобный способ группировать команды. Один из самых распространенных примеров – временно передвинуться в другую рабочую директорию, вот так: 123# do something in current dir(cd /some/other/dir &amp;&amp; other-command)# continue in original dir В Баше много типов пространства переменных. Проверить, существует ли переменная – ${name:?error message}. Например, если Баш-скрипту нужен всего один аргумент, просто напишите input_file=${1:?usage: $0 input_file}. Арифметическая область видимости: i=$(( (i + 1) % 5 )). Последовательности: {1..10}. Обрезка строк: ${var%suffix} и ${var#prefix}. Например, если var=foo.pdf тогда echo ${var%.pdf}.txt выведет foo.txt. Использование скобок {...} может уменьшить необходиость повторно вводить схожий текст и автоматизирует комбинирование элементов. Это полезно, например, здесь: mv foo.{txt,pdf} some-dir (переместит оба файла), cp somefile{,.bak} (приведется к cp somefile somefile.bak) или mkdir -p test-{a,b,c}/subtest-{1,2,3} (раскроет все возможные комбинации и создаст дерево каталогов). Вывод любой команды можно сохранить в файлоподобный контекст с помощью &lt;(some command). Например, сравнение локального файла `/etc/hosts с удалённым: 1diff /etc/hosts &lt;(ssh somehost cat /etc/hosts) Знайте про heredoc-синтаксис в Баше, работает он так: cat &lt;&lt;EOF .... В Баше перенаправляйте стандартный вывод, а также стандартные ошибки, вот так: some-command &gt;logfile 2&gt;&amp;1 или some-command &amp;&gt;logfile. Зачастую, для того, чтобы убедиться, что команда не оставит открытым файл, привязав его к открытому терминалу, считается хорошей практикой добавлять &lt;/dev/null. Используйте man ascii для просмотра хорошей ASCII таблицы с шестнадцатеричными и десятичными значениями. Для информации по основным кодировкам полезны man unicode, man utf-8 и man latin1. Используйте screen или tmux для того, чтобы иметь несколько экранов в одном терминале. Это особенно полезно, когда вы работаете с удаленным сервером по ssh, тогда вы можете подключаться/отключаться от сессий. byobu может улучшить использование screen или tmux, предоставляя больше информации и удобное управление. Более минималистичный подход для этого – использование dtach. В SSH полезно знать как сделать port tunnel с ключами -L и -D (и иногда -R). Например для того, чтобы зайти на сайт с удаленного сервера. Еще может быть полезно оптимизировать вашу SSH конфигурацию, например этот файл ~/.ssh/config содержит настройки, которые помогают избегать потерянных подключений в некоторых сетевых окружениях. Используйте сжатие (которое полезно с scp через медленные подключения) и увеличьте количество каналов к одному серверу через этот конфиг, вот так: 1234567TCPKeepAlive=yesServerAliveInterval=15ServerAliveCountMax=6Compression=yesControlMaster autoControlPath /tmp/%r@%h:%pControlPersist yes Некоторые другие настройки SSH могут сильно повлиять на безопасность и должны меняться осторожно, например, для конкретной подсети или конкретной машины или в доверенных сетях: StrictHostKeyChecking=no, ForwardAgent=yes. Рассмотрите mosh как альтернативу SSH, которая использует UDP и позволяет избежать разрывов соединений и добавляет удобства (требует настройки со стороны сервера). Чтобы получить разрешения файла в восьмеричном виде, что полезно для конфигурации систем, но нельзя получить из ls, можно использовать что-то типа: 1stat -c '%A %a %n' /etc/timezone Для интерактивного выделения результатов других команд используйте percol или fzf. Для работы с файлами, список которых дала другая команда (например, git), используйте fpp (PathPicker). Чтобы быстро поднять веб-сервер в текущей директории (и поддиректориях), который доступен для всех в вашей сети, используйте:python -m SimpleHTTPServer 7777 (если у вас Python 2 и вы хотите открыть сервер на порту 7777) или python -m http.server 7777 (для Python 3 и порта 7777). Чтобы выполнить определённую команду с привилегиями, используйте sudo (для рута) и sudo -u (для другого пользователя). Используйте su или sudo bash, чтобы запустить шелл от имени этого пользователя. Используйте su -, чтобы эмулировать свежий логин от рута или другого пользователя. Знайте про ограничение 128Кб в командной строке. Ошибка “Argument list too long” часто бывает, когда маска по имени включает большое количество файлов (в таких случаях помогают варианты с find или xargs). В качестве простого калькулятора (и, конечно, вообще для работы с Python) используйте интерпретатор python. Например, 12&gt;&gt;&gt; 2+35 Обработка файлов и информации Для того, чтобы найти файл в текущей директории, сделайте find . -iname &#39;*something*&#39;. Для того, чтобы искать файл по всей системе, используйте locate something (но не забывайте, что updatedb мог еще не проиндексировать недавно созданные файлы). Для основного поиска по содержимому файлов (более сложному, чем grep -r) используйте ag. Для конвертации HTML в текст: lynx -dump -stdin. Для конвертации разных типов разметки (HTML, Markdown и др.) попробуйте pandoc. Если нужно работать с XML, есть старая, но хорошая утилита – xmlstarlet. Для работы с JSON используйте jq. Для работы с YAML используйте shyaml. Для работы с Excel и CSV-файлами используйте csvkit (программа предоставляет команды in2csv, csvcut, csvjoin, csvgrep и т.д.) Для работы с Amazon S3 удобно работать с s3cmd и s4cmd (последний работает быстрее). Для остальных сервисов Амазона используйте стандартный aws или улучшенный saws. Знайте про sort и uniq, включая флаги -u и -d, смотрите примеры ниже. Также попробуйте comm. Знайте про cut, paste и join для работы с текстовыми файлами. Многие люди используют cut, забыв про join. Знайте о wc: для подсчёта переводов строк (-l), для символов – (-m), для слов – words (-w), для байтового подсчёта – (-c). Знайте про tee для копирования из stdin и в stdout, и в файл, например ls -al | tee file.txt. Для более сложных вычислений, включающих групповые операции с данными, преобразование матриц и статистические функции, имейте в виду datamash. Не забывайте, что локализация вашей системы влияет на многие команды, включая порядки сортировки, сравнение и производительность. Многие дистрибутивы Linux автоматически выставляют LANG или любую другую переменную в подходящую для Вашего региона. Из-за этого результаты функций сортировки могут работать непредсказуемо. Рутины i18n могут значительно снизить производительность сортировок. В некоторых случаях можно полностью этого избегать (за исключением редких случаев), сортируя традиционно побайтово, для этого export LC_ALL=C. Вы можете установить специфическое окружение для команды с помощью префикса перед ее вызовом, например TZ=Pacific/Fiji date. Знайте основы awk и sed для простых манипуляций с данными. Например, чтобы получить сумму всех чисел, которые находятся в третьей колонке текстового файла, можно использовать awk &#39;{ x += $3 } END { print x }&#39;. Скорее всего, это получится раза в 3 быстрее и раза в 3 проще, чем делать это в Питоне. Чтобы заменить все вхождения подстроки в одном или нескольких файлах: 1perl -pi.bak -e 's/old-string/new-string/g' my-files-*.txt Для того, чтобы переименовать сразу много файлов по шаблону, используйте rename. Для сложных переименований может помочь repren. В некоторых ситуациях rename тоже позволяет совершать множественное переименование, но будьте осторожны, т.к. его функциональность может меняться в зависимости от дистрибутива.123456# Full rename of filenames, directories, and contents foo -&gt; bar:repren --full --preserve-case --from foo --to bar .# Recover backup files whatever.bak -&gt; whatever:repren --renames --from '(.*)\.bak' --to '\1' *.bak# Same as above, using rename, if available:rename 's/\.bak$//' *.bak Как говорит man, rsync на деле - быстрая, с множеством возможностей, утилита для копирования файлов. Но она хороша не только для синхронизации между машинами, но и локально. Если есть доступ, то rsync, в отличие от scp, позволяет возобновить процесс копирования, не начиная заново. Он также является самым быстрым способом удалить большое количество файлов: 1mkdir empty &amp;&amp; rsync -r --delete empty/ some-dir &amp;&amp; rmdir some-dir Используйте shuf, чтобы перемешать строки или выбрать случайную строчку из файла. Знайте флаги sortа. Для чисел используйте -n, для работы с человекочитаемыми числами используйте -h (например du -h). Знайте как работают ключи (-t и -k). В частности, не забывайте, что вам нужно писать -k1,1 для того, чтобы отсортировать только первое поле; -k1 - это сортировка, учитывая всю строчку. Также стабильная сортировка может быть полезной (sort -s). Например для того, чтобы отсортировать самое важное по второму полю, а второстепенное по первому, можно использовать sort -k1,1 | sort -s -k2,2. Если вам когда-нибудь придётся написать код символа табуляции в терминале, например, для сортировки по табуляциям с флагом -t, используйте сокращение ctrl-v [Tab] или напишите $&#39;\t&#39;. Последнее лучше, потому что его можно скопировать. Стандартные инструменты для патчинга исходников это diff и patch. Также посмотрите на diffstat для просмотра статистики изменений (диффа) и sdiff для сравнения бок-о-бок (side-by-side). diff -r работает рекурсивно по всей директории. Используйте diff -r tree1 tree2 | diffstat для полной сводки изменений. Используйте vimdiff для сравнения и редактирования файлов. Для бинарных файлов используйте hd, hexdump или xxd для простых hex-дампов, и bvi для двоичного изменения бинарных файлов. strings (в связке с grep или чем-то похожим) помогает найти строки в бинарных файлах. Чтобы посмотреть разницу в бинарниках (дельта-кодирование) используйте xdelta3. Для конвертирования кодировок используйте iconv. Для более сложных задач – uconv, он поддерживает некоторые сложные фичи Юникода. Например, эта команда переводит строки из файла в нижний регистр и убирает ударения (которые бывают, например, в испанском языке) 1uconv -f utf-8 -t utf-8 -x '::Any-Lower; ::Any-NFD; [:Nonspacing Mark:] &gt;; ::Any-NFC; ' &lt; input.txt &gt; output.txt Для того, чтобы разбить файл на куски, используйте split (разбивает на куски по размеру), или csplit (по шаблону или регулярному выражению). Для операций с датами и временем используйте dateadd, datediff, strptime и т.д. из dateutils. Используйте zless, zmore, zcat и zgrep для работы со сжатыми файлами. chattr устанавливает атрибуты файлов, которые также являются низкоуровневой альтернативой правам доступа. Например, от случайного удаления файла защитит атрибут неизменяемости: sudo chattr +i /critical/directory/or/file. Используйте getfacl и setfacl для сохранения и восстановления файловых прав доступа. Например: 12getfacl -R /some/path &gt; permissions.txtsetfacl --restore=permissions.txt Отладка системы Для веб-отладки используйте curl и curl -I, или их альтернативу - wget. Также есть более современные утилиты, например httpie. Чтобы узнать текущее состояние процессора/диска, можно использовать классический top (или улучшенную альтернативу htop) и iostat, iotop. Используйте iostat -mxz 15 для получения базовой информации о процессоре и детализированной о каждом разделе жесткого диска. Для получения информации о сетевых соедиениях используйте netstat и ss. Для получения краткой информации о происходящем в системе используйте dstat, для более детальной информации – glances. Эта программа показывает сразу несколько разных статистик в одном окне терминала. Полезно, когда следите за сразу несколькими системами. Для того, чтобы следить за памятью, научитесь понимать free и vmstat. В частности, не забывайте, что кешированые значения (“cached” value) – это память, которую держит ядро и эти значения являются частью free. Отладка Java – совсем другая рыбка, но некоторые манипуляции над виртуальной машиной Оракла, или любой другой, позволят вам использовать kill -3 &lt;pid&gt; и трассировать сводки стека и хипа (включая детали работы сборщика мусора, которые бывают очень полезными), и их можно сдампить в stderr или логи. jps, jstat, jstack, jmap также полезны. SJK tools более продвинуты. Используйте mtr для лучшей трассировки, чтобы находить проблемы сети. Для того, чтобы узнать, почему диск полностью забит, используйте ncdu, это сохраняет время по сравнению с тем же du -sh *. Для того, чтобы узнать, какой сокет или процесс использует интернет, используйте iftop или nethogs. ab, которая поставляется вместе с apache, полезна для быстрой и поверхностной проверки производительности веб-сервера. Для более серьезного нагрузочного тестирования используйте siege. Для более серьёзной отладки сетей используйте wireshark, tshark и ngrep. Знайте про strace и ltrace. Эти команды могут быть полезны, если программа падает или висит, и вы не знаете почему. Или если вы хотите протестировать производительность программы. Не забывайте про возможность отладки (-c) и возможность прицепиться к процессу по pid (-p). Не забывайте про ldd для проверки используемых библиотек. Знайте как прицепиться к работающему процессу через gdb и получить трассировку стека. Используйте /proc. Иногда он невероятно полезен для отладки запущенных программ. Примеры: /proc/cpuinfo, /proc/meminfo, /proc/cmdline, /proc/xxx/cwd, /proc/xxx/exe, /proc/xxx/fd/, /proc/xxx/smaps (где xxx это pid). Когда отлаживаете что-то, что сломалось в прошлом, используйте sar – бывает очень полезно. Показывает историю CPU, памяти, сети и т.д. Для анализа более сложных систем и производительности посмотрите на stap (SystemTap), perf), и sysdig. Узнайте, какая у вас ОС, через uname или uname -a (основная Unix-информация/информация о ядре), или lsb_release -a (информация о дистрибутиве). Используйте dmesg, когда что-то ведет себя совсем странно (например, железо или драйвера). Если вы удалили файл и это вопреки ожиданиям не освободило место на диске, как показывает du, проверьте, использует ли файл какой-нибудь процесс:lsof | grep deleted | grep &quot;filename-of-my-big-file&quot;. В одну строчкуДавайте соберем все вместе и напишем несколько команд: Это довольно круто, что можно найти множественные пересечения файлов, соединить отсортированные файлы и посмотреть разницу в нескольких файлах через sort/uniq. Это быстрый подход и работает на файлах любого размера, включая многогигабайтные файлы (сортировка не ограничена памятью, но, возможно, вам придется добавить -T, если /tmp находится на небольшом логическом диске). Еще посмотрите то, что было сказано выше о LC_ALL. Флаг сортировки -u не используется ниже, чтобы было понятнее: 123cat a b | sort | uniq &gt; c # c is a union bcat a b | sort | uniq -d &gt; c # c is a intersect bcat a b b | sort | uniq -u &gt; c # c is set difference a - b Используйте grep . * для того, чтобы посмотреть содержимое всех файлов в директории. Особенно полезно, когда у вас много конфигов типа /sys, /proc, /etc. Получить сумму всех чисел, которые находятся в третьей колонке текстового файла (скорее всего, это раза в 3 быстрее и раза в 3 проще, чем делать это в Питоне): 1awk '&#123; x += $3 &#125; END &#123; print x &#125;' myfile Чтобы посмотреть размеры и даты в дереве файлов, есть почти как рекурсивная ls -l, но легче читаемая, чем ls -lR: 1find . -type f -ls Скажем, у нас есть какой-то текстовый файл, например лог какого-то сервера и на каких-то строках появляется значение, строки с которым нам интересны. Например, acct_id. Давайте подсчитаем, сколько таких запросов в нашем логе: 1cat access.log | egrep -o 'acct_id=[0-9]+' | cut -d= -f2 | sort | uniq -c | sort -rn Для непрерывного мониторинга измененний используйте watch, например, проверка измений файлов в директории: watch -d -n 2 &#39;ls -rtlh | tail&#39; или сетевых настроек во время устранения проблем с вашей wifi сетью: watch -d -n 2 ifconfig. Запустите этот скрипт, чтобы получить случайный совет из этой инструкции: 1234567function taocl() &#123; curl -s https://raw.githubusercontent.com/jlevy/the-art-of-command-line/master/README.md | pandoc -f markdown -t html | xmlstarlet fo --html --dropdtd | xmlstarlet sel -t -v "(html/body/ul/li[count(p)&gt;0])[$RANDOM mod last()+1]" | xmlstarlet unesc | fmt -80&#125; Сложно, но полезно expr: для выполнения арифметических и булевых операций, а также регулярных выражений m4: простенький макро-процессор yes: вывод строки в бесконечном цикле cal: классный календарь env: для того, чтобы выполнить команду (полезно в Bash-скриптах) printenv: показать переменные окружения (полезно в скриптах или отладке) look: найти английские слова (или строки) в файле cut, paste и join: манипуляции с данными fmt: форматирование параграфов в тексте pr: отформатировать текст в страницы/колонки fold: (обернуть) ограничить длину строк в файле column: форматировать текст в колонки или таблицы expand и unexpand: конвертация между табами и пробелами nl: добавить номера строк seq: вывести последовательность чисел bc: калькулятор factor: возвести числа в степень gpg: зашифровать и подписать файлы toe: таблица терминалов terminfo с описанием nc: отладка сети и передачи данных socat: переключатель сокетов и перенаправление tcp-портов (похоже на netcat) slurm: визуализация трафика сети dd: перенос информации между блочными устройствами file: узнать тип файла tree: показать директории и поддиректории в виде дерева, как ls, но рекурсивно stat: информация о файле time: время выполнения команды timeout: выполнять команду указанное количество времени и остановить процесс по его истечении lockfile: создание семафорного файла, который может быть удален только с помощью rm -f logrotate: ротация, сжатие и отправка логов по почте watch: повторный запуск команды с выводом результата или подсветкой изменений tac: вывести файл построчно в обратном порядке shuf: случайная выборка строк из файла comm: построчно сравнить отсортированные файлы pv: мониторинг прогресса прохождения информации через пайп hd, hexdump, xxd, biew и bvi: hex-дамп и редактирование бинарных файлов strings: найти текст в бинарниках tr: манипуляция с char (символьным типом) iconv и uconv: конвертация кодировок split и csplit: разбить файлы sponge: прочитать весь входной поток перед тем, как его записать. Полезно, когда читаешь из того же файла, куда записываешь. Например, вот так: grep -v something some-file | sponge some-file units: конвертер. Метры в километры, версты в пяди (смотрите /usr/share/units/definitions.units) apg: генерация случайных паролей 7z: архиватор с высокой степенью сжатия ldd: показывает зависимости программы от системных библиотек nm: получаем названия всех функций, которые определены в .o или .a (объектные файлы) ab: бенчмаркинг веб-серверов strace: отладка системных вызовов mtr: лучшая трассировка для отладки сети cssh: несколько терминалов в одном UI rsync: синхронизация файлов и папок через SSH wireshark и tshark: перехват пакетов и отладка сети ngrep: grep для слоя сети (network layer). Перехват пакетов по заданной маске. host и dig: узнать DNS lsof: информация о дескрипторах и сокетах процесса dstat: полезная статистика ОС glances: высокоуровневая статистика по многим подсистемам iostat: статистика процессора и использования жёсткого диска mpstat: статистика использования процессора vmstat: статистика использования памяти htop: улучшенная версия top last: история логинов в систему w: под каким пользователем вы сидите id: информация о пользователе/группе sar: история системной статистики iftop или nethogs: использование сети конкретным сокетом или процессом ss: статистика сокетов dmesg: ошибки загрузки и ошибки системы sysctl: просмотр и конфигурирование параметров ядра Linux hdparm: манипуляции с SATA/ATA lsblk: cписок блочных устройств компьютера: дерево ваших дисков и логических дисков lshw, lscpu, lspci, lsusb, dmidecode: информация о железе, включая CPU, BIOS, RAID, графику, девайсы, и т.д. lsmod и modinfo: информация о модулях ядра fortune, ddate, и sl: хм, не знаю, будут ли вам “полезны” веселые цитатки и поезда, пересекающие ваш терминал :) OS X onlyНекоторые вещи, подходящие только для OS X. Системы управлением пакетами – brew (Homebrew) и port (MacPorts). Они могут быть использованы для того, чтобы установить большинство программ, упомянутых в этом документе. Копируйте выдачу консольных программ в десктопные через pbcopy и вставляйте входные данные через pbpaste. Чтобы использовать в OS X кнопку Options как Alt (для использования команд alt-b, alt-f и т.д.) в настройках Терминала откройте Профили -&gt; Клавиатура и выберите “Использовать клавишу Option в качестве метаклавиши” (“Use Option as Meta key”). Для того, чтобы открыть файл или десктопную программу типа Finder, используйте open. Вот так: open -a /Applications/Whatever.app. Spotlight: Ищите файлы в консоли, через mdfind, и смотрите метаданные (например EXIF информацию фотографий) через mdls. Не забывайте, что OS X основана на BSD Unix и многие команды (например ps, ls, tail, awk, sed) имеют небольшие различия с линуксовыми. Это обусловлено влянием UNIX System V и GNU Tools. Разницу можно заметить, увидев заголовок “BSD General Commands Manual.” в манах программ. В некоторых случаях, на Мак можно поставить GNU-версии программ, например gawk и gsed. Когда пишите кроссплатформенные Bash-скрипты, старайтесь избегать использовать команды, которые могут различаться (например, лучше используйте Python или perl), или тщательно все тестируйте. Чтобы получить информацию о версии OS X используйте sw_vers. Windows only Используйте силу Unix shell в Microsoft Windows, установив Cygwin. Большая часть описанных в этом документе возможностей заработает сразу. Установите еще Unix программ с помощью встроенного в Cygwin менеджера пакетов. Используйте mintty в качестве терминала. Работайте с буфером обмена Windows с помощью /dev/clipboard. Запустите cygstart, чтобы открыть файл в приложении по умолчанию. Работайте с реестром Windows с помощью regtool. Имейте в виду, что виндовый диск C:\ доступен в Cygwin по пути /cygdrive/c, и cygwin’’ский / является папкой C:\cygwin в Windows. Конвертируйте файловые пути в виндовые и обратно с помощью cygpath. Это самый полезный скрипт, который запускает программы Windows. Вы можете запускать и автоматизировать большинство задач по администрированию Windows из командной строки, освоив wmic. Больше информации по теме awesome-shell: Дополняемый список инструментов и ресурсов для командной строки. awesome-osx-command-line: Более детальные гайды по терминалу в OS X. Strict mode: Для того, чтобы писать шелл-скрипты лучше. shellcheck: Статический анализатор скриптов. Filenames and Pathnames in Shell: Сборник мелочей о правильной обработке имен файлов в скриптах. Data Science at the Command Line: Обзор команд и утилит, используемых для обработки данных, из одноименной книги. ДисклеймерЗа небольшим исключением, весь код написан так, чтобы другие смогли его прочитать. Чем больше сила, тем больше и ответственность. Тот факт, что вы способны что-то сделать в Баше, вовсе не означает, что это нужно делать! ;) Лицензия Оригинальная работа и перевод на русский язык распространяется под лицензией Creative Commons Attribution-ShareAlike 4.0 International License.]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%9A%84%E8%89%BA%E6%9C%AF%2FREADME-ro%2F</url>
    <content type="text"><![CDATA[🌍Čeština ∙ Deutsch ∙ Ελληνικά ∙ English ∙ Español ∙ Français ∙ Indonesia ∙ Italiano ∙ 日本語 ∙ 한국어 ∙ Português ∙ Română ∙ Русский ∙ Slovenščina ∙ Українська ∙ 简体中文 ∙ 繁體中文 Arta liniei de comandă Meta Bazele Folosire zilnică Procesarea fișierelor și a datelor Depanarea sistemului Comenzi de o linie Obscure dar utile Doar pentru OS X Doar pentru Windows Mai multe resurse Anunț legal A folosi linia de comandă în mod eficient este o abilitate ignorată și/sau considerată obscură, dar ajută la creșterea flexibilității și productivității ca inginer. Acest ghid reprezintă o selecție de note și sfaturi pe care le-am găsit utile lucrului în Linux. Unele sfaturi sunt elementare, altele sunt foarte specifice, sofisticate sau obscure. Pagina nu este foarte lungă, dar dacă memorați și folosiți lucrurile de aici atunci știți o cantitate semnificativă de informație. Această muncă este rezultatul eforturilor multor autori și translatori.Multe dintre aceste sfaturiau apărutoriginalpe Quora,și au fost mutate pe GitHub ulterior, unde oameni mai talentați au produs numeroase îmbunătățiri.Vă rugăm întrebați dacă aveți nelămuriri legate de linia de comandă. Contribuiți dacă identificați o eroare sau ceva ce ar putea fi îmbunătățit! MetaScop: Acest ghid este atât pentru începători cât și pentru avansați. Scopurile sunt acoperire (tot ce este important), specificitate (oferirea exemplelor concrete pentru cazurilor comune) și brevitate (neincluderea lucrurilor neesențiale sau a digresiunilor ce pot fi găsite ușor în alte părți). Fiecare sfat este esențial în câteva situații sau reduce semnificativ timpul necesar efectuării unei cerințe comparativ cu celelalte alternative. Ghidul este scris pentru Linux, cu excepția secțiunilor “Doar pentru OS X“ și “Doar pentru Windows“. Majoritatea sfaturilor din celelalte secțiuni se aplică/pot fi instalate pe alte sisteme Unix sau OS X (chiar și în Cygwin). Se pune accent pe Bash interactiv, chiar dacă unele sfaturi sunt aplicabile și altor shell-uri sau pentru Bash-scripting în general. Atât comenzile Unix “standard” cât și cele care necesită instalarea de pachete speciale sunt incluse – cât timp sfaturile sunt destul de importante cât să merite incluziunea. Note: Pentru a păstra totul într-o singură pagină, conținutul este inclus implicit doar prin referințe. Suntem siguri că puteți căuta mai multe detalii după ce aveți ideea/comanda după care să căutați. Folosiți apt-get, yum, dnf, pacman, pip sau brew (după caz) pentru a instala programe noi. Folosiți Explainshell pentru a obține explicații utile despre ce fac anumite comenzi, opțiuni, etc. Bazele Învățați folosirea de bază a Bash. De fapt, tastați man bash și treceți măcar pe diagonală prin tot conținutul; este ușor de citit și nu este prea lung. Shell-uri alternative pot fi mai interesante, dar Bash este puternic și disponibil mereu (a învăța doar zsh, etc., chiar dacă e tentant pe laptopul propriu, vă restricționează în anumite situații, cum ar fi în folosirea unor servere existente). Învățați cel puțin un editor de text. Ideal Vim (vi), cum nu există un competitor real pentru editarea în terminal (chiar dacă folosiți Emacs, sau un editor modern în majoritatea timpului). Învățați să citiți documentație cu man (pentru curioși, man man listează secțiunile, de exemplu 1 este pentru comenzi “uzuale”, 5 este pentru fișiere/convenții și 8 pentru administrare). Găsiți pagini de manual cu apropos. Rețineți că anumite comenzi nu sunt programe executabile ci comenzi interne în Bash și că puteți obține ajutor despre ele cu help sau help -d. Puteți vedea dacă o comandă este internă, executabilă sau doar un alias prin folosirea type command. Învățați despre redirecționarea intrării și ieșirii folosind &gt; și &lt; și pipe-uri cu |. Rețineți că &gt; suprascrie fișierul și &gt;&gt; adaugă la final. Învățați despre ieșirea standard și ieșirea de eroare standard. Învățați despre expandarea numelor de fișiere cu * (și poate ? și […]) și despre folosirea și diferențele dintre &quot; și &#39;. (Vedeți mai multe în secțiunea despre expandarea variabilelor mai jos). Familiarizați-vă cu managementul job-urilor în Bash: &amp;, ctrl-z, ctrl-c, jobs, fg, bg, kill, etc. Învățați ssh, și bazele autentificării fără parolă, via ssh-agent, ssh-add, etc. Managementul de bază al fișierelor: ls și ls -l (în special, învățați ce reprezintă fiecare coloană din ls -l), less, head, tail și tail -f (sau, mai bine, less +F), ln și ln -s (aprofundați diferențele și avantajele între link-urile hard și cele soft), chown, chmod, du (scurt sumar de folosire: du -hs *). Pentru managementul sistemului de fișiere: df, mount, fdisk, mkfs, lsblk. Învățați ce este un inode (ls -i sau df -i). Concepte de bază de rețea: ip sau ifconfig, dig. Învățați și folosiți un sistem de versionare, precum git. Învățați expresii regulare foarte bine, precum și diversele opțiuni pentru grep/egrep. Relevante sunt -i, -o, -v, -A, -B, și -C. Învățați să folosiți apt-get, yum, dnf sau pacman (în funcție de distribuție) pentru a găsi și instala pachete. Fiți siguri că aveți pip pentru a instala comenzile bazate pe Python (câteva din utilitarele de mai jos sunt mai ușor de instalat cu pip). Folosire zilnică În Bash, folosiți Tab pentru a completa argumente sau a lista comenzile disponibile și ctrl-r pentru a căuta în istoricul comenzilor (după apăsare, tastați ce căutați și apăsați repetat ctrl-r pentru a cicla prin lista de potriviri, apăsați Enter pentru a executa comanda găsită sau săgeată dreapta pentru a putea edita linia curentă). În Bash, folosiți ctrl-w pentru a șterge ultimul cuvânt și ctrl-u pentru a șterge până la începutul liniei. Folosiți alt-b și alt-f pentru a naviga cuvânt-cu-cuvânt, ctrl-a pentru a muta cursorul la începutul liniei, ctrl-e pentru a-l muta la final, ctrl-k pentru a șterge până la finalul liniei, ctrl-l pentru a curăța tot ecranul. Vizualizați man readline pentru a vedea toate tastele implicite din Bash. Sunt o mulțime. De exemplu, alt-. ciclează prin toate argumentele anterioare și alt-* expandează un glob pattern. Alternativ, dacă doriți să folosiți tastele ca în vi, folosiți set -o vi (și set -o emacs pentru a vă întoarce). Pentru a edita comenzi lungi, după setarea editorului (de exemplu export EDITOR=vim), ctrl-x ctrl-e va deschide un editor cu comanda curentă pentru editare. În stilul vi puteți folosi escape-v. Comenzile recente le găsiți folosind history. Dacă folosiți !n (unde n este numărul comenzii) atunci o veți executa din nou. Sunt mai multe scurtături pe care le puteți folosi, foarte utile fiind !$ pentru ultimul argument și !! pentru ultima comandă (vedeți “HISTORY EXPANSION” în manual). Acestea pot fi înlocuite ușor cu ctrl-r și alt-.. Navigați către directorul personal cu cd. Accesați fișiere relative la acest director cu prefixul ~ (e.g. ~/.bashrc). În scripturile sh, referiți-vă la directorul personal cu $HOME. Pentru a ajunge înapoi în directorul anterior: cd -. Dacă sunteți în mijlocul editării unei comenzi dar vreți să renunțați, folosiți alt-# pentru a adăuga un # la început și a o introduce ca un comentariu (alternativ, ctrl-a, #, enter). Vă puteți întoarce la comandă mai târziu, folosind istoria comenzilor. Folosiți xargs (sau parallel). Este foarte puternic. Puteți controla câte comenzi execută pe o linie (-L) și paralelismul (-L). Dacă nu sunteți siguri că ați dat comanda corectă, folosiți întâi xargs echo. De asemenea, -I{} este foarte ultil. Exemple: 12find . -name '*.py' | xargs grep some_functioncat hosts | xargs -I&#123;&#125; ssh root@&#123;&#125; hostname pstree -p este o modalitate ușoară de a afișa lista de procese Folosiți pgrep și pkill pentru a găsi și semnala procesele după nume (-f poate fi util). Învățați ce semnale pot fi trimise proceselor. De exemplu, pentru a suspenda un proces puteți folosi kill -STOP [pid]. Pentru a obține lista completă, vedeți man 7 signal. Folosiți nohup sau disown dacă doriți să trimiteți un proces în fundal sau să-l mențineți rulând permanent. Verificați ce procese ascultă pe rețea folosind netstat -lntp sau ss -plat (pentru TCP; adăugați -u pentru UDP). Vedeți lsof pentru fișiere și socket-uri deschise. Vedeți uptime sau w pentru a afla cât timp sistemul a fost funcțional. Folosiți alias pentru a crea scurtături pentru comenzile folosie des. De exemplu, alias ll=&#39;ls -latr&#39; creează un nou alias ll. Salvați alias-uri, setări shell, și funcții folosite frecvent în ~/.bashrc, și instruiți shell-ul de login să-l citească. Asftel, veți avea aceleași setări în toate terminalele. Salvați setările variabilelor de mediu și comenzile care ar trebui executate la login în ~/.bash_profile. Configurări separate sunt necesare pentru shell-uri lansate prin logarea în mediul grafic sau din task-uri cron. Sincronizați fișierele de configurare (e.g. .bashrc and .bash_profile) între mai multe calculatoare folosind Git. Tratați cu atenție cazurile când variabilele și fișierele conțin spații. Folosiți ghilimele în acest caz, de exemplu &quot;$FOO&quot;. Preferați să folosiți opțiunile -0 sau -print0 pentru a folosi caracterul null pentru a delimita fișierele, de exemplu locate -0 pattern | xargs -0 ls -al sau find / -print0 -type d | xargs -0 ls -al. Pentru a parcurge o listă de fișiere conținând spații într-o buclă for, setați variabile IFS la terminatorul de linie, IFS=$&#39;\n&#39;. În scripturile Bash, folosiți set -x (sau varianta set -v, care produce informație neprocesată, inclusiv variabile neexpandate și comentarii) pentru a depana outputul. Folosiți modurile strice exceptând când aveți un motiv foarte bun împotrivă: folosiți set -e pentru a termina execuția în caz de eroare (cod de ieșire nenul). Folosiți set -u pentru a detecta variabile nesetate. Considerați folosirea set -o pipefail pentru erorile cauzate de folosirea eronată a pipe-urilor. Pentru scripturi mai complicate, folosiți trap pentru EXIT sau ERR. Un obicei util este să începeți scriptul într-o modalitate care va permite detecția facilă a erorilor și terminarea execuției cu un mesaj: 12set -euo pipefailtrap "echo 'error: Script failed: see failed command above'" ERR În scripturile Bash, subshell-urile (delimitate de paranteze) sunt un mod convenabil pentru a grupa comenzi. De exemplu, va puteți muta într-un alt director: 123# do something in current dir(cd /some/other/dir &amp;&amp; other-command)# continue in original dir În Bash, există mai multe variante de expandare a variabilelor. Verifacți dacă o variabilă există: ${name:?error message}. De exemplu, dacă un script necesită un argument unic, folosiți input_file=${1:?usage: $0 input_file}. Folosți o valoare implicită pentru cazul când o variabilă este goală: ${name:-default}. Pentru parametri opționali în exemplul anterior, folosiți output_file=${2:-logfile}. Dacă $2 este omis (gol), output_file va fi setat la logfile. Expandare aritmetică: i=$(( (i + 1) % 5 )). Secvențe: {1..10}. Tăierea unor secvențe din șiruri: ${var%suffix} și ${var#prefix}. De exemplu, dacă var=foo.pdf, atunci echo ${var%.pdf}.txt va scrie foo.txt. Expandarea parantezelor folosind {…} previne re-tastarea textelor similare, automatizând combinațiile de elemente. Este util în exemple precum mv foo.{txt,pdf} some-dir (care mută ambele fișiere), cp somefile{,.bak} (care se expandează la cp somefile somefile.bak) sau mkdir -p test-{a,b,c}/subtest-{1,2,3} (care expandează toate combinațiile posibile și creează arborele de directoare). Outputul unei comenzi poate fi tratat ca un fișier cu &lt;(some command). De exemplu, pentru a compara fișierul /etc/hosts local cu unul la distanță: 1diff /etc/hosts &lt;(ssh somehost cat /etc/hosts) Când scrieți cod, puteți prefera să încadrați tot codul în acolade. Dacă acolada de final lipsește, scriptul nu va rula. Este un lucru util, în special pentru scripturile de pe web pentru că previne execuția scripturilor parțial descărcate: 123&#123; # Your code here&#125; Folosiți “here documents”, de exemplu cat &lt;&lt;EOF .... În Bash, redirecționați ieșirea standard și eroarea standard cu some-command &gt;logfile 2&gt;&amp;1 sau some-command &amp;&gt;logfile. De regulă, pentru a vă asigura că o comandă nu lasă un fișier deschis, fiind legată de terminalul curent, este o practică bună să adăugați &lt;/dev/null. Folosiți man ascii pentru o tabelă ASCII foarte bună, cu valori în hex și decimal. Pentru informatii generale de codificare, man unicode, man utf-8, și man latin1 sunt utile. Folosiți screen sau tmux pentru a multiplexa terminalul, în special în cazul sesiunilor ssh. byobu poate îmbunătăți screen sau tmux fiind mai ușor de folosit. O interfață minimală pentru persistența sesiunilor este dtach. În ssh, este util să știți cum să creați un tunel cu -L sau -D (și ocazional -R), e.g. pentru a accesa site-urile de pe un server aflat la distanță. Este foarte util să optimizați configurațiile ssh, de exemplu, setarea următoare din ~/.ssh/config permite prevenirea sesiunilor eșuate în anumite condiții de rețea, folosește compresia (utilă pentru scp sau conexiuni peste rețele cu lățime de bandă redusă) și multiplexează canale către același server folosind un fișier de control local: 1234567TCPKeepAlive=yesServerAliveInterval=15ServerAliveCountMax=6Compression=yesControlMaster autoControlPath /tmp/%r@%h:%pControlPersist yes Un număr de alte opțiuni sunt relevante pentru securitate și trebuiesc tratate cu atenție, de exemplu, setări pe rețea sau mașină: StrictHostKeyChecking=no, ForwardAgent=yes Considerați folosirea mosh ca o alternativă la ssh care folosește UDP, prevenind conexiunile eșuate (necesită setări pe partea de server). Pentru a obține permisiunile unui fișier în forma octală, lucru util pentru configurarea sistemului, dar nedisponibil în ls, folosiți ceva precum: 1stat -c '%A %a %n' /etc/timezone Pentru selecția interactivă a valorilor dintr-o altă comandă, folosiți percol sau fzf. Pentru interacțiunea cu fișiere rezultate din outputul unei alte comenzi (like git), folosiți fpp (PathPicker). Un simplu server web pentru fișierele din directorul curent și subdirectoare, disponibil pentru toți din rețeaua dumneavoastră, folosițipython -m SimpleHTTPServer 7777 (pentru port 7777 și Python 2) și python -m http.server 7777 (pentru port 7777 și Python 3). Puteți rula o comandă ca un alt utilizator folosind sudo. Implicit se va rula ca root, folosiți -u pentru a specifica utilizatorul. Folosiți -i pentru a vă loga ca acel utilizator, folosind parola voastră. Pentru a schimba tot shellul către alt utilizator, folosiți su utilizator sau su - utilizator. Versiunea cu - obține și mediul, ca si cum utilizatorul tocmai s-a logat. Username-ul implicit este root. Veți fi întrebat parola utilizatorului către care faceți schimbarea. Amintiți-vă că orice linie de comandă are o limită de 128K. Eroarea “Argument list too long” (listă de argumente prea lungă) este comună dacă un număr mare de fișiere se potrivesc unui șablon. (În acest caz, alternative precum find și xargs ajută.) Un calculator simplu poate fi accesat utilizând python. De exemplu: 12&gt;&gt;&gt; 2+35 Procesarea fișierelor și a datelor Pentru a localiza un fișier după nume, în directorul curent, find . -iname &#39;*something*&#39; (sau similar). Pentru a găsi un fișier oriunde, locate something (dar țineți cont de faptul că updatedb s-ar putea să nu fi indexat fișierele recente). Pentru a căuta în interiorul fișierelor (mai avansat decât grep -r), folosiți ag. Pentru a converti HTML la text: lynx -dump -stdin Pentru Markdown, HTML, și alte conversii de documente, folosiți pandoc. Dacă trebuie să folosiți XML, xmlstarlet e vechi dar util. Pentru JSON, folosiți jq. Pentru YAML, folosiți shyaml. Pentru Excel sau CSV files, csvkit oferă in2csv, csvcut, csvjoin, csvgrep, etc. Pentru Amazon S3, s3cmd este ușor de folosit și s4cmd este mai rapid. aws de la Amazon și varianta îmbunătățită saws sunt esențiale pentru alte task-uri legate de AWS. Învățați sort și uniq, inclusiv opțiunile -u și -d pentru uniq – mai multe exemple în secțiunea de comenzi de o linie, mai jos. Vedeți și comm. Aflați despre cut, paste, și join pentru a manipula fișiere text. Mulți oameni folosesc cut dar uită de join. Informați-vă despre wc pentru a număra liniile (-l), caracterele (-m), cuvintele (-w) și octeții (-c) dintr-un fișier. Folosți tee pentru a copia de la intrarea standard (stdin) într-un fișier și la ieșirea standard (stdout) simultan, ca în ls -al | tee file.txt. Pentru operații mai complexe, inclusiv grupare, inversare de câmpuri și statistică, considerați folosirea datamash. Țineți minte că localizarea (locale) influențează foarte multe comenzi în moduri subtile, inclusiv sortare sau performanță. Majoritatea instalărilor Linux setează LANG și alte variabile de localizare la o setare precum US English. Sortarea se va schimba dacă schimbați localizare. De asemenea, rutinele de internaționalizare (i18n) pot face comenzile să se execute mult, mult mai încet. În unele situații (precum operațiile pe mulțimi de mai jos), puteți ignora rutinele încete de la i18n și folosi sortarea bazată pe octeți, folosind export LC_ALL=C. Puteți seta localizarea specifică unei comenzi prin prefixarea acesteia cu variabila de mediu corespunzătoare, ca în TZ=Pacific/Fiji date. Pentru procesare de bază a textelor, folosiți awk și sed. De exemplu, pentru a aduna suma numerelor din coloana a treia a unui fișier awk &#39;{ x += $3 } END { print x }&#39; este de 3 ori mai rapid și mai scurt decât codul echivalent în Python. Pentru a înlocui toate aparițiile unui șir, în cel puțin un fișier: 1perl -pi.bak -e 's/old-string/new-string/g' my-files-*.txt Pentru a redenumi fișiere multiple și/sau căuta în fișiere încercați repren. (În unele cazuri, comanda rename permite redenumiri multiple, dar țineți cont că funcționalitatea ei nu este aceeași în toate distribuțiile Linux) 123456# Full rename of filenames, directories, and contents foo -&gt; bar:repren --full --preserve-case --from foo --to bar .# Recover backup files whatever.bak -&gt; whatever:repren --renames --from '(.*)\.bak' --to '\1' *.bak# Same as above, using rename, if available:rename 's/\.bak$//' *.bak După cum zice și pagina de manual, rsync este un utilitar foarte rapid, eficient și versatil de a copia fișiere. Este cunoscut pentru sincronizarea între calculatoare dar poate fi folosit și local. Dacă setările de securitate permit, folosirea rsync în loc de scp permite continuarea unui transfer eșuat fără a-l reporni. Este și una dintre cele mai rapide metode de a șterge un număr masiv de fișiere: 1mkdir empty &amp;&amp; rsync -r --delete empty/ some-dir &amp;&amp; rmdir some-dir Folosiți shuf pentru a permuta sau selecta linii aleatoare dintr-un fișier. Învățați opțiunile lui sort. Pentru numere folosiți -n, sau -h pentru numere în format human-readable (de exemplu numere produse de du -h). Învățați cum funcționează cheile de sortare (-t și -k). În special, țineți cont că trebuie să scrieți -k1,1 pentru a sorta doar prima coloană, -k1 înseamnă sortare după toată linia. Sortarea stabilă (sort -s) poate fi utilă. De exemplu, pentru a sorta după câmpul 2 și apoi după 1: sort -k1,1 | sort -s -k2,2. Dacă sunteți nevoiți să scrieți un caracter tab în terminal (de exemplu pentru argumentul -t al sort) apăsați ctrl-v [Tab] sau scrieți $&#39;\t&#39; (ultima versiune e mai bună pentru că permite și copy/paste). Utilitarele standard pentru patch-uirea codului sunt diff și patch. De asemenea diffstat poate fi folosit pentru sumarizarea unui diff și sdiff pentru un diff side-by-side. Țineți cont că diff -r operează pe directoare întregi. Folosiți diff -r tree1 tree2 | diffstat pentru un sumar al modificărilor. Folosiți vimdiff pentru a compara și edita fișiere. Pentru fișiere binare, folosiți hd, hexdump sau xxd pentru operații simple și bvi sau biew pentru editare binară Tot pentru fișiere binare, strings (plus grep, etc.) permite găsirea bucăților de text. Pentru diff-uri binare (compresie delta), folosiți xdelta3. Pentru a converti codificarea textului, folosiți iconv sau uconv pentru utilizări mai avansate. Ambele suportă același set de Unicode. De exemplu, comanda următoare transformă în minuscule și elimină accentele (prin expandare sau coborâre): 1uconv -f utf-8 -t utf-8 -x '::Any-Lower; ::Any-NFD; [:Nonspacing Mark:] &gt;; ::Any-NFC; ' &lt; input.txt &gt; output.txt Pentru a împărți un text în fragmente, folosiți split (după dimensiune) și csplit (după un șablon). Folosiți dateadd, datediff, strptime etc. din dateutils pentru a manipula expresii legate de timp, dată și oră. Pentru a opera pe fișiere comprimate: zless, zmore, zcat, and zgrep Atributele fișierelor pot fi stabilite cu chattr și oferă o alternativă de nivel scăzut la permisiunile unui fișier. De exemplu, pentru a vă proteja împotriva ștergerii accidentale puteți folosi flag-ul immutable: sudo chattr +i /critical/directory/or/file Folosiți getfacl și setfacl pentru a salva și restaura permisiunile unui fișier. De exemplu: 12getfacl -R /some/path &gt; permissions.txtsetfacl --restore=permissions.txt Depanarea sistemului Pentru depanarea problemelor legate de internet/web, curl și curl -I sunt foarte utile, la fel și echivalentele bazate pe wget sau pe modernul httpie. Pentru a vedea starea curentă a CPU-ului sau discului, instrumentele clasice sunt top (mai bine htop), iostat, și iotop. Folosiți iostat -mxz 15 pentru informații de bază despre CPU și detaliate depsre partițiile fiecărui disc, împreună cu sfaturi pentru îmbunătățirea performanței. Pentru detalii legate de conexiunile la rețea, folosiți netstat și ss. O vedere de ansamblu a sistemului poate fi obținută folosind dstat. Pentru detalii, folosiți glances. Pentru a vedea starea curentă a memoriei, folosiți și analizați rezultatele free și vmstat. În particular, țineți cont că valoarea “cached” este memorie reținută de Linux ca un spațiu cache pentru fișiere, deci este efectiv spațiu “liber”. Depanarea sistemului Java este deosebită dar un truc simplu pe anumite JVM-uri (inclusiv Oracle) este că puteți rula kill -3 &lt;pid&gt; și veți obține un stack trace complet și informații despre memoria heap, inclusiv detalii despre garbage collector. Utilitarele jps, jstat, jstack, jmap din JDK pot fi utile. Utilitarele SJK sunt mai avansate. Folosiți mtr ca un traceroute mai bun pentru a identifica problemele de rețea. Pentru a identifica de ce un disc este plin, ncdu salvează timp comparativ cu folosirea comenzilor uzuale precum du -sh *. Pentru a identifica socket-ul sau procesul care consumă cea mai mare bandă din rețea folosiți iftop sau nethogs. Utilitarul ab (vine cu Apache) este util pentru a testa rapid performanța serverului web. Pentru testare mai complexă folosiți siege. Pentru depanarea și mai serioasă a rețelei folosiți wireshark, tshark, sau ngrep. Învățați despre strace și ltrace. Aceste utilitare sunt utile dacă un program eșuează, se blochează sau crapă și nu știți de ce, sau dacă vreți să obțineți detalii generale despre performanță. Evidențiem opțiunea de profiling (-c), și abilitatea de atașare la un proces care rulează (-p). Folosiți ldd pentru a verifica bibliotecile dinamice, etc. Folosiți gdb pentru a vă conecta la un proces care rulează și a obține un stack trace. Folosiți /proc. Este foarte util în depanarea problemelor pe viu. Exemple: /proc/cpuinfo, /proc/meminfo, /proc/cmdline, /proc/xxx/cwd, /proc/xxx/exe, /proc/xxx/fd/, /proc/xxx/smaps (unde xxx este id-ul procesului - PID-ul lui). Pentru a depana ceva ce a fost greșit în trecut, sar poate fi foarte util. Arată statistici istorice despre CPU, memorie, rețea, etc. Pentru analize de detaliu pentru performanța sistemului, folosiți stap (SystemTap), perf), și sysdig. Verificați ce sistem de operare folosiți cu uname sau uname -a (detalii generale despre nucleu) sau lsb_release -a (Linux distro). Folosiți dmesg oricând ceva funcționează total aiurea (probabil din cauza hardware-ului sau a dispozitivelor fizice). Dacă ștergeți un fișier și nu se eliberează cantitatea de spațiu de pe disc la care vă așteptați (conform du), verificați să nu cumva aveți fișierul folosit de un proces:lsof | grep deleted | grep &quot;filename-of-my-big-file&quot; Comenzi de o linieCâteva exemple de a construi comenzi complicate din comenzi simple: Este foarte util uneori că puteți trata fișierele ca mulțimi de rânduri și puteți implementa operațiile pe mulțimi – intersecție, reuniune și diferență – folosind sort/uniq. Presupunând că a și b sunt fișiere text fără linii duplicate, următoarele comenzi sunt foarte rapide și procesează fișiere de dimensiuni gigantice (sort nu este limitat de memorie dar este preferabil să folosiți -T dacă /tmp este pe o partiție mică). De asemenea, nu uitați de nota despre LC_ALL (localizare) de mai sus și de opțiunea -u (eliminată mai jos pentru claritate): 123cat a b | sort | uniq &gt; c # c is a union bcat a b | sort | uniq -d &gt; c # c is a intersect bcat a b b | sort | uniq -u &gt; c # c is set difference a - b Folosiți grep . * pentru a examina rapid conținutul fișierelor din director (fiecare linie este împerecheată cu fișierul din care provine) sau head -100 * (fiecare fișier are un header). Este un sfat util pentru directoare conținând setări precum /sys, /proc, /etc. Suma tuturor numerelor din a 3-a coloană a unui fișier (probabil de 3 ori mai rapid și de 3 ori mai puțin cod decât codul Python echivalent): 1awk '&#123; x += $3 &#125; END &#123; print x &#125;' myfile Pentru a vedea dimensiunile și data fiecărui fișier dintr-un arbore, metoda următoare este ca un ls -l recursiv dar cu un output mai clar decât ls -lR: 1find . -type f -ls Presupunând că aveți un fișier text, de exemplu un jurnal al unui server web, și o anumită valoare apare pe câteva linii, precum o valoare pentru parametrul acct_id prezent în URL, dacă doriți un sumar pentru fiecare valoare a lui acct_id: 1cat access.log | egrep -o 'acct_id=[0-9]+' | cut -d= -f2 | sort | uniq -c | sort -rn Pentru a monitoriza schimbările folosiți watch. De exemplu, verificați schimbările dintr-un director cu watch -d -n 2 &#39;ls -rtlh | tail&#39; sau setările de rețea în timp ce depanați probleme cu conexiunea wireless: watch -d -n 2 ifconfig. Folosiți această funcție pentru a obține un sfat aleator din acest document (parsează formatul Markdown și extrage un item): 1234567function taocl() &#123; curl -s https://raw.githubusercontent.com/jlevy/the-art-of-command-line/master/README.md | pandoc -f markdown -t html | xmlstarlet fo --html --dropdtd | xmlstarlet sel -t -v "(html/body/ul/li[count(p)&gt;0])[$RANDOM mod last()+1]" | xmlstarlet unesc | fmt -80&#125; Obscure dar utile expr: execută operații aritmetice sau logice și expandează expresii regulate m4: procesor simplu de macro-uri yes: afișează un șir de un număr infinit de ori cal: calendar env: execută o comandă (util în scripturi) printenv: afișează variabilele de mediu (util pentru depanare și scripturi) look: idenfică cuvinte în engleză (sau linii de fișier) care încep cu un șir cut, paste and join: manipulează date fmt: formatează paragrafe de text pr: formatează textul în paragrafe și coloane fold: înfășoară liniile unui text column: formatează textul în coloane de lungime fixă, în tabele expand și unexpand: convertește între tab-uri și spații nl: adaugă numere liniilor seq: afișează numere bc: calculator factor: factorizează întregi gpg: criptează și semnează fișiere toe: tabel de informații despre terminal nc: depanare rețea și transfer de date socat: socket relay și forwarder pentru porturi tcp (similar cu netcat) slurm: vizualizează traficul de rețea dd: mută datele între fișiere și device-uri file: identifică tipul unui fișier tree: arată un arbore de directoare și subdirectoare, ca ls dar recursiv stat: informații despre fișier time: execută și cronometrează o comandă timeout: execută o comandă până la expirarea unui timp definit, omorând procesul la finalul timpului alocat lockfile: creează un fișier semafor care nu poate fi șters decât cu rm -f logrotate: rotește, comprimă și trimite jurnalele pe mail watch: execută o comandă în mod repetat, arătând rezultatele și/sau evidențiind diferențele tac: afișează conținutul fișierelor în ordine inversă shuf: selectează linii in mod aleator din fișier comm: compară fișiere sortate, linie cu linie pv: monitorizează progresul datelor într-un pipe hd, hexdump, xxd, biew și bvi: afișează sau editează fișiere binare strings: extrage șiruri din fișiere tr: translatează și manipulează caractere iconv sau uconv: conversie între codificările posibile ale unui text split și csplit: sparge fișiere în componente sponge: citește tot inputul înainte de a-l afișa, util pentru a citi și apoi a scrie în același fișier: grep -v something some-file | sponge some-file units: conversii între unități de măsură (vedeți și /usr/share/units/definitions.units) apg: generateză parole aleatoare xz: compresor de fișiere foarte eficient ldd: informații despre bibliotecile dinamice nm: simboluri din fișierele obiect ab: benchmarking pentru servere web strace: depanare apeluri de sistem mtr: alternativă mai bună pentru traceroute pentru depanarea rețelei cssh: shell vizual, concurent rsync: sincronizează fișiere peste SSH sau local wireshark și tshark: capturează trafic de rețea și depanează rețeaua ngrep: grep pentru rețea host și dig: interogări DNS lsof: informații despre descriptorii de fișiere și sockeți dstat: statistici utile despre sistem glances: statistici utile despre sistem, la nivel înalt iostat: statistici despre folosirea discului mpstat: statistici despre folosirea CPU vmstat: statistici despre folosirea memoriei htop: versiune îmbunătățită a top last: istoria login-urilor w: cine este logged-in id: informații despre utilizatori/grupuri sar: istoria statisticilor despre sistem iftop sau nethogs: utilizarea rețelei de fiecare socket sau proces ss: statistici socket dmesg: erori de sistem sau de pornirea sistemului sysctl: vizualizează și configurează parametrii nucleului Linux hdparm: manipulare/performanță pentru discuri SATA/ATA lsblk: afișează dispozitivele block: discuri și partiții lshw, lscpu, lspci, lsusb, dmidecode: informații hardware, incluzând CPU, BIOs, RAID, plăci grafice, dispozitive, etc. lsmod și modinfo: afișează module de kernel fortune, ddate, și sl: depinde dacă considerați locomotive și citate “utile” (utilitare distractive) Doar pentru OS XAceste sfaturi sunt relevante doar pentru OS X. Managementul pachetelor cu brew (Homebrew) și/sau port (MacPorts). Aceste comenzi pot fi folosite pentru a instala multe din comenzile de mai sus pe un Mac. Copiați outputul unei comenzi către aplicații desktop cu pbcopy și lipiți conținutul de la una cu pbpaste. Pentru a mapa tasta Option în OS X Terminal ca o tastă Alt (pentru comenzile de mai sus precum alt-b, alt-f, etc.), deschideți Preferences -&gt; Profiles -&gt; Keyboard și selectați “Use Option as Meta key” (“Folosește Option ca tastă Meta”). Pentru a deschide un fișier cu o aplicație desktop folosițiopen sau open -a /Applications/Whatever.app. Spotlight: Găsiți fișiere cu mdfind și listați meta-date (de exemplu informații EXIF din fotografii) cu mdls. Țineți minte că OS X este la bază un BSD Unix, și multe comenzi (de exemplu ps, ls, tail, awk, sed) au un număr de variațiuni subtile comparativ cu Linux, un fapt influențat de diferențele între System V-style Unix și utilitarele GNU. Puteți vedea diferențele observând dacă pagina de manual are antetul “BSD General Commands Manual” (“Manual de comenzi generale BSD”). În unele cazuri, versiunile GNU pot fi instalate în paralel (precum gawk și gsed pentru GNU awk și sed). În scrierea de aplicații independente de platformă, evitați aceste comenzi (de exemplu folosiți Python sau perl) sau testați cu atenție. Informații despre versiunea OS X se pot obține cu sw_vers. Doar pentru WindowsAceste sfaturi sunt relevante doar pentru Windows. În Windows 10, puteți folosi Bash în Ubuntu în Windows, pentru a obține mediul Bash familiar cu comenzile și utilitățile Unix descrise anterior. Ca bonus, acest lucru permite ca programele Linux să ruleze pe Windows. Pe de altă parte, nu puteți rula programe Windows din prompt-ul Bash. Puteți accesa shell-ul Unix sub Windows prin instalarea Cygwin. Multe din lucrurile descrise aici vor funcționa implicit. Programele Unix adiționale se vor instala cu managerul de pachete al lui Cygwin. Folosiți mintty ca fereastra de comenzi. Accesați clipboard-ul Windows prin intermediul dev/clipboard. Folosiți cygstart pentru a deschide un fișier arbitrar cu aplicația corespunzătoare Accesați registrele Windows cu regtool. Observați că o cale de tip C:\ în Windows devine /cygdrive/c sub Cygwin, și că root-ul Cygwin, /, apare ca C:\cygwin pe Windows. Convertiți între căile Cygwin și Windows cu cygpath. Acest lucru este util în scripturile care apelează programe Windows. Puteți executa majoritatea task-urilor de administrare a sistemului Windows din linia de comandă prin învățarea și folosirea wmic. O altă opțiune de a obține un sistem similar Unix sub Windows este Cash. Țineți cont că doar câte utilitare Unix sunt în prezent disponibile în acest mediu. O altă opțiune alternativă este să obțineți instrumentele de dezvoltare GNU (precum GCC) cu MinGW și pachetul MSYS. Astfel veți obtine utilitare precum bash, gawk, make și grep. MSYS nu are toate beneficiile Cygwin dar este util în particular pentru a crea versiuni de Windows pentru instrumentele Unix. Mai multe resurse awesome-shell: O listă detaliată a instrumentelor și resurselor pentru shell. awesome-osx-command-line: Un ghid mai detaliat pentru folosirea liniei de comandă sub OS X Strict mode pentru a scrie scripturi mai bune.. shellcheck: Un utilitar pentru analiza statică a scripturilor. În esență, lint pentru bash/sh/zsh. Filenames and Pathnames in Shell: Detalii complete despre situația tristă în folosirea căilor către fișiere corect în scripturi independente de platformă Data Science at the Command Line: Mai multe comenzi și utilitare disponibile pentru analiza datelor, după cartea cu același nume. Anunț legalCu excepția unor task-uri foarte mici, codul scris aici este pentru ca alții să-l poate citi. Cu putere vine și responsabilitate. Faptul că puteți face ceva în Bash nu înseamnă neapărat că și trebuie să-l faceți ;) Licență Această muncă este licențiată sub Creative Commons Attribution-ShareAlike 4.0 International License.]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%9A%84%E8%89%BA%E6%9C%AF%2FREADME-pt%2F</url>
    <content type="text"><![CDATA[🌍Čeština ∙ Deutsch ∙ Ελληνικά ∙ English ∙ Español ∙ Français ∙ Indonesia ∙ Italiano ∙ 日本語 ∙ 한국어 ∙ Português ∙ Română ∙ Русский ∙ Slovenščina ∙ Українська ∙ 简体中文 ∙ 繁體中文 A arte da linha de comando Meta Básico Uso diário Processamento de arquivos e dados Debugando o sistema One-liners Obscuros mas úteis Mais conteúdo Aviso Fluência na linha de comando é uma habilidade muitas vezes negligenciada ou considerada obsoleta, porém ela aumenta sua flexibilidade e produtividade como desenvolvedor de diversas maneiras, sutis ou não. Este texto descreve uma seleção de notas e dicas de uso da linha de comando que me parecem muito uteis, quando usando o Linux. Algumas dicas são elementares, e outras são mais específicas, sofisticadas ou obscuras. Esta página é curta, mas se você souber usar e lembrar todos os items que estão aqui, então você está mandando bem. Muito do que está aqui originalmenteapareceuno Quora,mas dado o interesse por lá, me pareceu importante usar o Github, onde pessoas mais talentosas do que eu, poderiam sugerir melhorias facilmente. Se você descobrir um erro ou algo que poderia ser melhorado, por favor abra um issue ou um PR! (E claro, por favor veja as `meta sections’ e PRs/issues existentes, primeiro.) MetaEscopo: Este guia é destinado tanto aos iniciantes quanto aos usuários mais experientes. Os objetivos são abrangência (tudo que é importante), especificidade (dar exemplos concretos dos casos de usos mais comuns), e concisão (evitar coisas que não são tão essenciais ou digressões que você pode facilmente encontrar pela Internet). Todas as dicas são essenciais em alguma situação ou trazem uma economia notável de tempo em relação a outras alternativas. Este guia é escrito para o Linux. Muitos, mas não todos os items, se aplicam igualmente para o MacOS (ou mesmo o Cygwin). O foco está na interatividade com Bash, embora muitas dicas aqui sejam aplicáveis a outras `shells’ e também a scripts em Bash, em geral. Incluímos tanto comandos no Unix “padrão”, quanto comandos que requeiram instalação de pacotes adicionais – desde que estes sejam importantes o suficiente para merecerem sua inclusão nessa lista. Notas: Para manter este guia em uma única página, o conteúdo implícito será incluído por referência. Você é competente o suficiente para verificar mais detalhes em outros lugares, desde que você já tenha entendido a ideia ou saiba o que procurar no Google. Use apt-get, yum, dnf, pacman, pip ou brew (quando adequado) para instalar novos programas. Use Explainshell para encontrar informações úteis sobre o que fazem os comandos, as opções, pipes, etc. Básico Aprenda o básico sobre Bash. Na verdade, digite man bash e pelo menos entenda superficialmente o seu funcionamento; é bastante simples de ler e nem é tão grande assim. Shells alternativas podem ser legais, mas Bash é a mais poderosa e sempre está disponível (aprender somente zsh, fish, etc, é tentador quando você usa o seu próprio notebook, mas restringe você em muitas situações, por exemplo quando você quer usar servidores de outros). Aprenda bem pelo menos um editor de texto tradicional. Idealmente o Vim (vi), já que nenhum outro funciona tão bem nos terminais aleatórios que a gente encontra por aí (mesmo que você prefira usar o Emacs, um IDE, ou um editor hipster a maior parte do tempo). Saiba como ler a documentação com o man (para os curiosos, man man lista os números das seções, por exemplo, 1 se refere aos comandos “regulares”, 5 é sobre arquivos/convenções, e 8 diz respeito a administração). Procure outros documentos do manual com o apropos. Saiba que alguns dos comandos não são executáveis, mas sim built-ins (embutidos) no bash, pra esses você poderá conseguir ajuda com help e help -d. Aprenda como fazer redirecionamento de saída e entrada usando &gt; e &lt; e pipes usando |. Aprenda sobre o stdout e stdin. Aprenda sobre a expansão de arquivos glob com * ( e talvez ? e {…}) e entenda as diferenças entre aspas duplas &quot; e aspas simples &#39;. (Veja mais em variáveis de expansão abaixo.) Se familiarize com o gerenciamento de jobs em Bash: &amp;, ctrl-z, ctrl-c, jobs, fg, bg, kill, etc. Aprenda ssh, e o básico de autenticação sem senha, através do ssh-agent, ssh-add, etc. Gerenciamento básico de arquivos: ls e ls -l (em particular, aprenda o que cada coluna no ls -l significa), less, head, tail e tail -f (ou melhor ainda, less +F), ln e ln -s(aprenda as diferenças e vantagens de soft links comparados a hard links), chown, chmod, du (para um rápido resumo do uso do disco: du -sk *). Para gerenciamento do sistema de arquivos, df, mount, fdisk, mkfs, lsblk. Gerenciamento básico da rede: ip ou ifconfig, dig. Saiba bem como usar expressões regulares, e as várias flags para grep/egrep. As -i, -o, -A, e -B são opções que é importante conhecer. Aprenda a usar apt-get, yum, dnf ou pacman (dependendo da distribuição) para procurar e instalar pacotes. E garanta que você possui o pip para instalar ferramentas baseadas em Python (algumas das abaixo são mais fáceis de instalar através do pip). Uso diário Usando Bash, use Tab para completar argumentos e ctrl-r para pesquisar através a história dos comandos. Em Bash, utilize ctrl-w para deletar a última palavra, e ctrl-u para deletar tudo e voltar para o início da linha. Use alt-b e alt-f para se mover por palavras, ctrl-k para apagar até o final da linha, ctrl-l para limpar a tela. Consulte man readline para todos os keybindings padrões do Bash. Existem muitos. Por exemplo alt-. circula através dos argumentos anteriores, e alt-* expande um glob. Alternativamente, se você adora os keybinds do vi, use set -o vi. Para ver os comandos recentes, history. Existem também muitas abreviações como !$ (último argumento) e !! último comando, embora estes sejam muitas vezes facilmente substituídos por ctrl-r e alt-.. Pra voltar para o diretório anterior de trabalho: cd -. Se você está na metade do caminho ao digitar um comando, mas mudou de ideia, tecle alt-# para adicionar um # ao início da linha e definir esta como um comentário (ou use ctrl-a. #. enter). Mais tarde você poderá recuperar o comando através da history. Use xargs (ou parallel). Estes são muito poderosos. Note que você pode controlar como os vários items são executados por linha (-L) assim como o paralelismo (-P). Se você não tem certeza se isto é a coisa certa a se fazer, use xargs echo primeiro. O -I{} também é muito útil. Exemplos: 12find . -name '*.py' | xargs grep some_functioncat hosts | xargs -I&#123;&#125; ssh root@&#123;&#125; hostname pstree -p é um modo de visualização muito útil da árvore de processos. Use pgrep e pkill para procurar ou sinalizar os processo pelo seu nome (-f é muito útil). Saiba os vários sinais que você pode enviar para um processo. Por exemplo, para suspender um processo, use kill -STOP [pid]. Para saber a lista completas dos sinais, veja man 7 signal. Use nohup ou disown se você deseja por o processo no background, executando para sempre. Verifique quais processos estão escutando através de netstat -lntp ou ss -plat (para TCP; adicione -u para UDP). Veja também lsof para abrir sockets e arquivos. Em scripts Bash, use set -x para debugar a saída. Utilize modos estritos sempre que for possível. Use set -e para abortar em caso de erros. Use set -o pipefail para também ser restrito a respeito dos erros (embora este tópico seja um pouco sútil). Para scripts mais desenvolvidos, use também trap. Em Bash scripts, subshells (escrito com parênteses) são formas convenientes de agrupar comandos. Um exemplo comum é temporariamente se mover para um diretório de trabalho diferente, e.g. 123# faz algo no diretório corrente(cd /some/other/dir &amp;&amp; other-command)# continua no diretório atual No Bash, note que existem muitos tipos de variáveis de expansão. Verificando a existência de uma variável: ${name:?error_messages}. Por exemplo, se um script Bash requer um único argumento, apenas escreva input_file=${1:?usage: $0 input_file}. Expansões aritméticas: i=$(( (i + 1) % 5 )). Sequências: {1..10}. Aparando as strings: ${var%suffix} e ${var#prefix}. Por exemplo, se var=foo.pdf, então echo ${var%.pdf}.txt imprime foo.txt. A saída de um comando pode ser tratada como um arquivo através &lt;(algum comando). Por exemplo, comparar um arquivo local /etc/hosts com um remoto: 1diff /etc/hosts &lt;(ssh somehost cat /etc/hosts) Saiba sobre “documentos aqui” no Bash, como em cat &lt;&lt;EOF .... No Bash, redirecionar a saída padrão (stdout) e a saída de erro padrão (stderr) através de: algum-comando &gt;logfile 2&gt; $1. Muitas vezes, para garantir que um comando não deixa um arquivo aberto para manipular a entrada padrão, digitando isso no terminal que você está, é uma boa prática adicionar um &lt;/dev/null. Use man ascii para visualizar a tabela ASCII, com valores hexadecimais e decimais. Para informações gerais sobre codificações, man unicode, man utf-8, e man latin1 são úteis. Use screen ou tmux para multiplexar as telas, especialmente útil em sessões ssh remotas e para desplugar e replugar a uma sessão. Uma alternativa mais simples para a persistência de uma sessão é dtach. No ssh, saber como realizar um túnel de portas com -L ou -D (e ocasionalmente -R) é útil, para por exemplo acessar sites webs de um servidor remoto. Pode ser útil realizar algumas otimizações em suas configurações do ssh; por exemplo, o arquivo ~/.ssh/config contém configurações para evitar que conexões sejam dropadas em certos ambientes de rede, use compressão (muito útil quando se está usando o scp através de uma conexão lenta), e multiplexação de canais do mesmo servidor com um arquivo de controle local: 1234567TCPKeepAlive=yesServerAliveInterval=15ServerAliveCountMax=6Compression=yesControlMaster autoControlPath /tmp/%r@%h:%pControlPersist yes Algumas outras opções relevantes para o ssh tem problemas de segurança e devem ser habilitadas com muito cuidado, por exemplo somente para subrede ou host ou em redes confiaveis (de confiança): StrictHostKeyChecking=no, ForwardAgent=yes Para conseguir as permissões em arquivo em forma octal, o que é útil para a configuraçao do sistema mas não disponível no ls e fácil de se confundir, use algo como: 1stat -c '%A %a %n' /etc/timezone Para seleção interativas de valores da saída de outro comando, use percol. Para interação com arquivos baseados na saída de outro comando (like git), use fpp (PathPicker). Para um simples servidor web para todos os arquivos do diretório atual (e subdiretórios), disponível para alguém na sua rede, use:python -m SimpleHTTPServer 7777 (para a porta 7777 e Python 2) e python -m http.server 7777 (para a porta 7777 e Python 3). Processamento de arquivos e dados Para localizar um arquivo pelo nome no diretório atual, find . -iname &#39;*something*&#39; (ou similar). Para procurar um arquivo em qualquer lugar pelo nome, use locate something (mas tenha em mente que o updatedb pode não ter indexado arquivos criados recentemente). Para uma busca mais geral através de arquivos de dados ou de códigos (mais avançado do que grep -r), use ag. Para converter HTML para texto: lynx -dump -stdin. Para Markdown, HTML, e todos os demais tipos de conversão de documentos, tente pandoc. Se você precisa manipular XML, xmlstarlet é antigo mas é bom. Para JSON, jq. Para Excel ou arquivos CSV, csvkit que provê in2csv, csvcut, csvjoin, csvgrep, etc. Para a Amazon S3, s3cmd é uma forma conveniente e s4cmd é mais rápido. O aws da amazon é essencial para outras tarefas relacionadas. Aprenda a respeito do sort e uniq, incluindo as opções do -u e -d do uniq – veja os one-liners abaixo. Veja também comm. Aprenda a respeito do cut, paste, e join para manipular arquivos de texto. Muitas pessoas usam cut mas esquecem do join. Aprenda a respeito do wc para contar novas linhas (-l), caracteres (-m), palavras (-m) e bytes (-c). Aprenda a respeito do tee para copiar da entrada padrão (stdin) para um arquivo e também para a saída padrão (stdout), como no ls -al | tee file.txt. Aprenda que as configurações de localização afetam várias ferramentas da linha de comando em formas sutis, incluindo a ordem da ordenação e performance. A maioria das instalações do Linux irá definir LANG ou outras variáveis de localização para o ingles dos USA. Mas esteja ciente de que a ordem da ordenação irá mudar, caso você altere a localização. E saiba que as rotinas do i18n podem fazer o sort ou outros comandos executarem muitas vezes mais devagar. Em algumas situações (como o conjunto de operações ou as operações únicas abaixo) você pode seguramente eliminar a lentidão das rotinas do i18n inteiramente e usar a ordem baseada nos bytes, usando export LC_ALL=C. Aprenda o básico sobre awk e sed para obtenção de informações simples de dados. Por exemplo, somar todos os números na terceira coluna de um arquivo de texto: awk &#39;{ x += $3 } END { print x }&#39;. Isto é provavelmente 3X mais rápido e 3X mais curto do que o equivalente em Python. Para substituir todas as ocorrências de uma string em um lugar, em um ou mais arquivos: 1perl -pi.bak -e 's/old-string/new-string/g' my-files-*.txt Para renomear muitos arquivos de uma vez, de acordo com um padrão, use rename. Para renomeações mais complexas, repren pode ajudar. 1234# Recuperar arquivos de backup foo.bak -&gt; foo:rename 's/\.bak$//' *.bak# Renomea completamente o nome dos arquivos, diretórios, e outros conteúdos foo -&gt; bar:repren --full --preserve-case --from foo --to bar . Utilize o shuf para embaralhar ou selecionar linhas randoms de um arquivo. Para as opções do sort. Aprenda com as chaves (-t e -k). Em particular, saiba que precisa escrever -k1,1 para ordenar somente o primeiro campo; -k1 significa ordenar de acordo com a linha inteira. Ordenação estável (sort -s) pode ser útil. Por exemplo, para ordenar primeiramente pelo campo 2, então secundariamente pelo campo 1, você pode usar sort -k1,1 | sort -s -k2,2. Se você precisa escrever literalmente um tab na linha de comando no Bash (por exemplo, para o argumento -t do sort), pressione ctrl-v [Tab] ou escreva $&#39;\t&#39; (o último é melhor pois você pode copiar e colar ele). As ferramentas padrão para extrair patches de códigos fonte são diffe patch. Veja também diffstat para um resumo de estatísticas de um diff. Note que diff -r funciona para diretórios inteiros. Use diff -r tree1 tree2 | diffstat para um resumo das alterações. Para arquivos binários, use hd para um simples dump hexadecimal e bvi para edição binária. Também para arquivos binários, strings (mais grep, etc.) deixa você encontrar pedaços de texto. Para diffs binários (compressão delta), use xdelta3. Para converter a codificação de textos, tente iconv. Ou uconv para uso mais avançado; Este suporta algumas funcionalidades avançadas do Unicode. Por exemplo, este comando transforma o texto para minúsculo e remove todos os acentos (expandindo e removendo eles): 1uconv -f utf-8 -t utf-8 -x '::Any-Lower; ::Any-NFD; [:Nonspacing Mark:] &gt;; ::Any-NFC; ' &lt; input.txt &gt; output.txt Para dividir um arquivo em pedaços, veja split (para dividir por tamanho) e csplit (para dividir por um padrão). Use zsless, zmore, zcat, and zgrep para manipular arquivos comprimidos. Debugando o sistema Para web debug, curl e curl -I são úteis, ou os equivalentes wget, or uma alternativa mais moderna httpie. Para saber o status do disco/cpu/rede, use iostat, netstat, top (ou o htop como alternativa melhor), e (especialmente) dstat. Bom para obter uma ideia rápida do que está acontecendo em um sistema. Para um resumo mais aprofundado do sistema, use glances. Este lhe apresenta vários níveis de estatísticas do sistema em uma janela do terminal. Muito útil para uma rápida verificação em vários subsistemas. Para saber o status da memória, execute e entenda a saída do free vmstat. Em particular, esteja ciente de que o valor “cached”, é mantido pelo kernel Linux como um arquivo de cache, então este efetivamente conta como um valor de memória disponível. Debugar um sistema java é uma outra historia, mas um simples truque nas máquinas virtuais Oracle ou algum outro tipo de JVM é que você pode executar kill -3 &lt;pid&gt; e um completo rastreamento da pilha(stack trace) e resumo do heap (incluindo detalhes geracionais do garbage collector, os quais podem ser altamente informativos) serão vazados para stderr/logs. Use mtr como uma melhor alternativa ao traceroute, para identificar problemas na rede. Para verificar o porque de um disco estar cheio, ncdu economiza bastante tempo em comparação aos comandos usuais como du -sh *. Para procurar qual socket ou processo está utilizando a banda de rede, tente iftop ou nethogs. A ferramenta ab (que vem com o Apache) é muito útil para verificação rápida da performance do servidor web. Para mais complexos testes de carga, tente siege. Para debugs mais sérios da rede, wireshark, tshark, ou ngrep. Aprenda a respeito do stracee ltrace. Estes podem ser úteis se um programa está falhando, travado, ou quebrando, e você não sabe o por que, ou se você quer obter uma ideia geral da performance. Note que a opção de perfil (-c), e a habilidade de se plugar a um processo em execução (-p). Aprenda a respeito do ldd para verificar bibliotecas compartilhadas, e etc. Aprenda sobre como se conectar a um processo em execução com o gdb e obter informações sobre a stack trace. Utilize /proc. Este é incrivelmente útil em algumas vezes quando se deseja debugar problemas ao vivo. Exemplos: /proc/cpuinfo, /proc/xxx/cwd, /proc/xxx/exe, /proc/xxx/fd/, /proc/xxx/smaps. Quando estiver debugando o porque de algo ter dado errado no passado, sar pode ser de muita utilidade. Ele exibe as estatísticas históricas da CPU, memória, rede e etc. Para análises de performance mais profundas do sistema, dê uma olhada em stap (SystemTap), perf), e sysdig. Confirme qual a sua distribuição do Linux usando (funciona na maioria das distros): lsb_release -a. Use dmesg sempre que algo estiver agindo de maneira estranha (isto pode ser um problema de hardware ou problema de driver). One-linersAlguns exemplos de como reunir os comandos. O seguinte é notavelmente e frequentemente útil: muitas vezes você quer obter a interseção, união e a diferença de arquivos de texto através de sort/uniq. Suponha que a e b são arquivos de texto que são “uniqued” únicos. Esse modo é rápido, e funciona em arquivos de tamanhos arbitrários, podem até possuírem gigabytes. (Sorting não é limitado por memória, embora você possa precisar usar a opção -T se /tmp está em uma partição pequena.) Veja também a nota sobre LC_ALL acima e as opções -u do sort(vamos deixar isso claro abaixo). 123cat a b | sort | uniq &gt; c # c is a union bcat a b | sort | uniq -d &gt; c # c is a intersect bcat a b b | sort | uniq -u &gt; c # c is set difference a - b Use grep . * para visualmente examinar todo o conteúdo de todos os arquivos de um diretório, por exemplo, para diretórios com arquivos de configurações, como /sys, /proc, /etc. Somar todos os números em uma terceira coluna de um arquivo de texto (isto é provavelmente 3X mais rápido e 3X menos linhas de código do que o equivalente em Python). 1awk '&#123; x += $3 &#125; END &#123; print x &#125;' myfile Se você quer visualizar tamanhos/datas em uma árvore de arquivos, isto é como um ls -l recursivo, mas é mais fácil de ler do que ls -lR: 1find . -type f -ls Utilize xargs ou parallel sempre que você puder. Note que você pode controlar quantos item é executado por linha (-L) assim como o paralelismo (-P). Se você não tem certeza de que esta é a coisa certa a se fazer, utilize xargs echo primeiro. 12find . -name '*.py' | xargs grep some_functioncat hosts | xargs -I&#123;&#125; ssh root@&#123;&#125; hostname Digamos que você tenha um arquivo de texto, como um log do servidor web, e um certo valor que aparece em algumas linhas, como por exemplo o parâmetro acct_id que está presente na URL. Se você quer um cálculo de quantas requisições para este acct_id. 1cat access.log | egrep -o 'acct_id=[0-9]+' | cut -d= -f2 | sort | uniq -c | sort -rn Execute esta função para obter uma dica random deste documento (analisa a sintaxe Markdown e extrai um item) 1234567function taocl() &#123; curl -s https://raw.githubusercontent.com/jlevy/the-art-of-command-line/master/README-pt.md | pandoc -f markdown -t html | xmlstarlet fo --html --dropdtd | xmlstarlet sel -t -v "(html/body/ul/li[count(p)&gt;0])[$RANDOM mod last()+1]" | xmlstarlet unesc | fmt -80&#125; Obscuros mas úteis expr: executa operações boleanas ou aritméticas ou avalia expressões regulares. m4: simples processador de macros. yes: imprime uma string muitas vezes. cal: calendário legal. env: executa um comando (útil em scripts). printenv: imprime as variáveis de ambiente (útil em debug e scripts). look: procura palavras inglesas (ou linhas em um arquivo) começando com uma string. cut e paste e join: manipulação de dados. fmt: formata parágrafos de texto. pr: formata textos em páginas/colunas. fold: envolve linhas de texto. column: formata texto em colunas ou tabelas. expand e unexpand: converte entre tabs e espaços. nl: adiciona números as linhas. seq: imprime números. bc: calculadora. factor: fatora inteiros. gpg: criptografa e assina arquivos. toe: tabela de entradas dos tipos de terminais. nc: ferramenta de debug de rede e transferência de dados. socat: socket relay e encaminhamento de portas tcp (similar ao netcat) slurm: visualização do tráfego da rede. dd: move os dados entre arquivos ou dispositivos. file: identifica o tipo do arquivo. tree: mostra os diretórios e subdiretórios como um árvore de dependências; como ls mas recursivo. stat: informações do arquivo. tac: imprime arquivos na ordem reversa. shuf: seleção random de linhas de um arquivo. comm: compara uma lista de arquivos ordenadas linha por linha. pv: monitora o progresso dos dados através de um pipe. hd e bvi: dump ou edita arquivos binários. strings: extrai texto de arquivos binários. tr: tradução e manipulação de caracteres. iconv ou uconv: conversor de codificações de texto. split e csplit: divisão de arquivos. units: conversor de unidades e cálculos; converte furlongs por quinzena para twips per blink (veja também /usr/share/units/definitions.units) 7z: Compressor de arquivos de alto desempenho. ldd: informações dinâmicas das bibliotecas. nm: símbolos de arquivos objetos. ab: benchmarking para web servers. strace: Debug para chamadas de sistema. mtr: melhor traceroute para debugar a rede. cssh: Visualização concorrente da shell. rsync: Sincroniza arquivos e pastas através do SSH. wireshark e tshark: captura de pacotes e debug de rede. ngrep: grep para a camada de rede. host e dig: Consultas DNS. lsof: Arquivo de descritores dos processos e informações dos sockets. dstat: Estatísticas úteis do sistema. glances: Resumo de alto nível, de multi subsistemas. iostat: Estatísticas de uso do CPU e do disco. htop: Versão do top melhorada. last: histórico de logins. w: quem está logado. id: Informações sobre a identidade do user/group. sar: histórico dos estados do sistema. iftop ou nethogs: Utilização da rede por sockets ou processos. ss: Estatísticas dos sockets. dmesg: Mensagens de erro do sistema e do boot. hdparm: Manipulação/performance de discos SATA/ATA. lsblk: Lista os blocos dos dispositivos: uma visualização em forma de árvore dos seus discos e partições do disco. lshw e lspci: informações do hardware, incluindo RAID, gráficos, etc. fortune, ddate, e sl: um, bem, isto depende de você considerar locomotivas a vapor e citações Zippy “úteis”. Mais conteúdo awesome-shell: Uma lista refinada de ferramentas da shell e outros recursos. Strict mode para escrever shell scripts melhores. AvisoCom a exceção de tarefas muito pequenas, código é normalmente escrito para que outros possam ler. Junto com o poder vem a responsabilidade. O fato de você poder fazer algo usando Bash não significa necessariamente que você deve! ;) Licença Este trabalho está licenciado com uma Creative Commons Attribution-ShareAlike 4.0 International License.]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%9A%84%E8%89%BA%E6%9C%AF%2FREADME-ko%2F</url>
    <content type="text"><![CDATA[🌍Čeština ∙ Deutsch ∙ Ελληνικά ∙ English ∙ Español ∙ Français ∙ Indonesia ∙ Italiano ∙ 日本語 ∙ 한국어 ∙ Português ∙ Română ∙ Русский ∙ Slovenščina ∙ Українська ∙ 简体中文 ∙ 繁體中文 The Art of Command Line Meta Basics Everyday use Processing files and data System debugging One-liners Obscure but useful macOS only Windows only More resources Disclaimer 커맨드 라인을 능숙하게 다루는 기술은 종종 도외시되거나 신비스럽게 여겨집니다. 하지만 커맨드 라인은 명백하고도 미묘한 방법으로 엔지니어가 하는 작업의 유연성과 생산성을 향상시킵니다. 이 문서는 리눅스에서 커맨드 라인을 사용할 때 유용하게 활용할 수 있는 노트와 팁들의 모음입니다. 몇몇은 기초적인 것들이지만 몇몇은 상당히 구체적이고 세련되며 잘 알려지지 않은 것들입니다. 이 문서는 그리 길지 않지만 여기 있는 모든 것을 사용할 수 있고 기억해낼 수 있다면 당신은 많은 것을 알고 있다고 할 수 있습니다. 이 문서에는 많은 저자와 번역가가 참여했습니다.여기 중 일부 내용은원래Quora에올라온 것이지만후에 GitHub으로 옮겨졌고, 이 곳에서 원 저자들보다 더 재능있는 사람들이 무수히 많은 개선작업을 진행하였습니다.커맨드 라인에 관해 궁금한 것이 있으면 질문해 주세요. 오류가 있거나 더 나아질 수 있는 내용이 보인다면 기여해 주세요! Meta범위: 이 가이드는 초보자와 경험자 모두를 위한 것 입니다. 이 가이드의 목표는 폭넓은 지식을 제공하는 것(전부 다 중요합니다), 구체적으로 제공하는 것(가장 일반적인 사례에 대한 구체적인 예제를 제공합니다), 그리고 간결하게 제공하는 것(중요하지 않거나 다른 문서에서 쉽게 찾아볼 수 있는 지엽적인 것들을 피합니다)입니다. 모든 팁은 특정 상황에서 매우 중요하거나 여러 다른 대안들보다 시간을 확연하게 절약합니다. 이 문서는 리눅스를 위해 쓰였습니다. “macOS only“, “Windows only“ 섹션을 제외하고 말이죠. 그 밖의 대부분은 유닉스, macOS(심지어 Cygwin)에서도 적용하거나 설치할 수 있습니다. 인터랙티브 Bash에 초점이 맞추어져있습니다만, 대부분의 팁은 다른 쉘이나, general Bash 스크립트에서도 동작합니다. 이 문서는 “표준” 유닉스 커맨드와 특정 패키지 설치를 필요로 하는 것 둘 다 포함하고 있습니다 – 여기서 다룰만큼 충분히 중요하다면요. 노트: 이 문서를 하나의 파일로 유지하기 위해서 콘텐츠들은 암시적인 레퍼런스 형태로 포함되어있습니다. 한 개념이나 명령어에 대해 알게 된 후에, 구글에서 그에 대한 좀 더 자세한 정보를 찾아보세요. apt-get, yum, dnf, pacman, pip, brew (혹은 적절한 다른 것)를 이용해 새 프로그램을 설치하세요. Explainshell을 이용해서 커맨드, 옵션, 파이프, 기타 등등이 어떤 기능을 하는지 분석하는데 도움을 받으세요. Basics Bash의 기초를 배우세요. 말하자면, man bash를 실행하고 최소한 전부 훑어보기라도 하세요. 매뉴얼의 내용은 따라가기 쉬우며 그리 길지 않습니다. 다른 쉘들 또한 좋습니다만, Bash는 강력하고 언제나 사용 가능합니다(zsh, fish, 혹은 그 외의 쉘만 배운다면 개인 노트북에서는 좋겠지만 많은 경우 제한이 생길 것입니다. 이미 존재하는 서버를 사용하는 것등의 일에서 말이죠). 텍스트 기반 에디터를 최소한 하나 정도는 잘 다룰 수 있게 배우세요. nano 에디터는 기본적인 편집기능(열기, 수정하기, 저장하기, 찾기)을 제공하는 가장 단순한 에디터 중 하나입니다. 그러나 텍스트 터미널을 이용하는 고급 이용자라면 Vim(Vi)을 대체할 수 있는 것은 없습니다. Vim은 사용법을 배우기는 어렵지만 믿음직하고 빠르며 풍부한 기능을 가졌습니다. 또한 고전적인 Emacs도 많이 사용됩니다. 특히 규모가 좀 더 큰 편집 작업에서요. (물론 요즘 같은 시대에 대형 프로젝트를 진행하고 있는 소프트웨어 개발자라면 순수한 텍스트 기반 에디터만 사용하지는 않을 것이고 최신의 그래픽 기반 IDE와 도구들에도 익숙해져야 합니다.) man을 이용해서 문서를 읽는 법을 배우세요(호기심 많은 사람을 위해서 하는 얘기입니다만, man man은 섹션 번호들의 목록을 표시합니다. 예를 들어 1은 “regular” 커맨드, 5는 files/conventions, 그리고 8은 administration이죠). apropos를 이용해서 man 페이지를 찾으세요. 몇몇 커맨드는 실행파일이 아니라 Bash 빌트인 명령어임을 알아두세요. Bash 빌트인 명령어들에 대한 도움을 받으려면 help와 help -d를 이용하세요. 어떤 커맨드가 실행파일, 쉘 빌트인 명령어인지, 아니면 별칭인지는 type command를 통해 확인할 수 있습니다. &gt;와 &lt;, |를 이용한 파이프를 사용해서 입력과 출력의 리다이렉션을 배우세요. &gt;는 출력 파일을 덮어 씌우고, &gt;&gt;는 출력 파일 끝에 내용을 덧붙인다는 걸 알아두세요. stdout(역주: 표준 출력)과 stderr(역주: 표준 에러 출력)에 대해서 배우세요. *(그리고 아마도 ?와 […])을 이용하는 파일 글롭(glob) 확장을 배우세요. 그리고 쌍따옴표&quot;와 홑따옴표&#39;의 차이를 배우세요. (변수 확장에 대해서 더 보려면 아래를 참조하세요) Bash 작업 관리에 익숙해지세요. &amp;, ctrl-z, ctrl-c, jobs, fg, bg, kill 등등. ssh를 배우고, ssh-agent, ssh-add를 통해서 비밀번호 없는 인증 방식의 기본을 배우세요. 기본 파일 관리: ls와 ls -l(특별히, ls -l에서 각각의 열이 무슨 의미인지 배우세요), less, head, tail 그리고 tail -f(또는 더 좋은 less +F), ln과 ln -s(하드 링크와 소프트 링크의 차이와 각각의 장단점을 배우세요), chown, chmod, du( 디스크 사용량의 빠른 요약을 보려면 du -hs *). 파일 시스템 관리를 위해서는 df, mount, fdisk, mkfs, lsblk. inode가 무엇인지 배우세요(ls -i 또는 df -i). 기본 네트워크 관리: ip 또는 ifconfig, dig, traceroute, route. git 같은 버전 관리 시스템을 배우고 사용하세요. 정규 표현식(regular expression)을 잘 알아두세요. 그리고 grep/egrep의 다양한 플래그도 알아두세요. -i, -o, -v,-A, -B와 -C 옵션은 알아둘 가치가 있습니다. apt-get, yum, dnf 또는 pacman(배포판마다 다릅니다)을 이용하여 패키지를 찾고 설치하는 법을 배우세요. 그리고 pip가 설치되어 있는지 확인해서 파이선 기반의 커맨드 라인 도구를 설치할 수 있도록 하세요(밑에 설명된 것 중 몇 가지는 pip를 이용해 설치하는 게 제일 쉽습니다). Everyday use Bash 에서 Tab을 쓰면 argument를 완성하고, ctrl-r을 쓰면 커맨드 히스토리에서 검색합니다(누른 다음, 검색할 것을 입력하고, ctrl-r를 계속 눌러 좀 더 맞는 것을 찾을 수 있습니다. Enter를 눌러 찾은 커맨드를 실행하고 오른쪽 화살표 키를 눌러 결과를 현재 라인에 복사해 수정할 수 있습니다). Bash에서 ctrl-w는 마지막 단어를 지웁니다. ctrl-u는 라인의 처음까지 전부다 지웁니다. alt-b와 alt-f를 이용해서 단어 단위로 이동할 수 있습니다. ctrl-a로 라인의 시작점으로 이동할 수 있고 ctrl-e로 라인의 끝으로 이동할 수 있습니다. ctrl-k는 커서 위치부터 라인의 끝까지 지웁니다. ctrl-l은 화면을 깨끗하게 합니다. man readline을 이용해서 Bash의 기본 키 조합을 살펴보세요. 많은 것이 있습니다. 예를 들면 alt-.같은 경우, 이건 argument를 돌아가면서 나타내고 alt-*는 글롭을 확장합니다. vi 스타일의 키 조합을 사랑한다면, set -o vi를 사용할 수도 있습니다(set -o emacs로 되돌릴 수 있습니다). 긴 명령을 수정하려면 에디터를 설정한 다음(예를 들면, export EDITOR=vim) ctrl-x ctrl-e를 눌러 현재 명령을 에디터에서 열어 여러줄 편집을 할 수 있습니다. vi 스타일에서는 escape-v를 사용합니다. 최근 사용한 커맨드를 보려면 history를 입력하세요. 그 후 !n으로(여기서 n은 커맨드 번호를 뜻합니다) 다시 실행할 수 있습니다. !$(마지막 argument), !!(마지막 커맨드)와 같은 약어들이 매우 많습니다. 비록 이런 것들이 ctrl-r이나 alt-.명령어로 자주 대체되기 쉽지만요. cd로 홈 디렉터리로 갈 수 있습니다. 홈 디렉터리에서 상대적으로 파일을 접근하려면 ~ 접두사를 사용합니다(예: ~/.bashrc). sh 스크립트에서는 $HOME로 홈 디렉터리를 참조합니다. 이전에 작업하던 디렉터리로 돌아가려면 cd -를 사용하세요. 커맨드를 타이핑하던 도중에 마음이 바뀌었다면, alt-#을 쳐서 시작점에 #을 삽입하고, 엔터를 쳐서 코멘트로 여겨지게 하세요(또는 ctrl-a, #, enter). 나중에 커맨드 히스토리에서 찾아서 타이핑 중이었던 커맨드로 돌아올 수 있습니다. xargs(혹은 parallel)를 사용하세요. 매우 강력합니다. 라인당 몇 개의 아이템이 실행되게 할 것인지(-L) 그걸 병렬로 할 것인지(-P)를 제어할 수 있다는 걸 기억하세요. 제대로 하고 있는지 확신할 수 없다면 xargs echo를 먼저 실행해보세요. 또 -I{}도 편리합니다. 예시: 12find . -name '*.py' | xargs grep some_functioncat hosts | xargs -I&#123;&#125; ssh root@&#123;&#125; hostname pstree -p는 프로세스 트리를 표시하는데 도움이 됩니다. pgrep과 pkill을 사용해서 프로세스를 찾거나 시그널을 보내세요(-f가 유용합니다). 프로세스에 보낼 수 있는 다양한 시그널을 알아두세요. 예를 들어, 프로세스를 일시 중지 할 때는 kill -STOP [pid]를 사용합니다. 전체 목록은 man 7 signal에서 볼 수 있습니다. 백그라운드 프로세스를 영원히 돌아가게 만들고 싶다면, nohup이나 disown을 사용하세요. 어떤 프로세스가 리스닝(역주: 특정 포트로 들어오는 패킷 리스닝)을 하고 있는지 알려면 netstat -lntp나 ss -plat을 사용해서 알 수 있습니다(TCP 일 경우입니다. UDP의 경우 -u옵션을 추가하세요). lsof를 이용해서 열려있는 소켓과 파일을 볼 수 있습니다. uptime이나 w를 이용해서 시스템이 얼마나 오래 실행 중인지 알 수 있습니다. 자주 사용되는 커맨드에 대해서 alias를 이용해서 숏컷을 만드세요. 예를들어, alias ll=&#39;ls -latr&#39;은 새 단축 명령 ll을 만듭니다. 자주 사용하는 단축, 설정, 함수는 ~/.bashrc에 저장하고, 그것을 참조하는 로그인 셸을 고쳐보세요. 이렇게 하면 설정을 모든 셸 세션에서 사용할 수 있습니다. 환경 변수 설정이나 로그인할 때 실행해야 할 명령은 ~/.bash_profile에 넣으세요. 그래픽 환경의 로그인의 셸과 cron 잡의 셸을 분리하기 위해 설정을 분리할 필요가 있습니다. Git으로 여러 컴퓨터에서 같은 설정 파일을 사용하세요(예 .bashrc, .bash_profile). 공백이 들어간 변수명이나 파일명은 주의할 필요가 있습니다. Bash 변수를 따옴표로 감싸세요(예: &quot;$FOO&quot;). 파일 이름의 경계에 공백 문자를 허용하려면 -0이나 -print0 옵션을 사용하세요. 예를 들면, locate -0 pattern | xargs -0 ls -al, find / -print0 -type d | xargs -0 ls -al. for 문에서 공백문자가 포함된 파일 이름을 반복하려면, IFS=$&#39;\n&#39;로 IFS를 개행 문자만으로 설정하시면 됩니다. Bash 스크립트에서 set -x를 사용하면 디버깅용 출력을 사용하게 됩니다(아니면 다른 옵션 set -v가 있습니다. 확장되지 않은 변수와 주석을 포함한 로우 입력을 로깅합니다). 스트릭트 모드(strict mode)가 가능할 때면 사용하세요. set -e를 사용하면 에러가 났을 때 중단시키게 됩니다. set -u을 사용하면 설정되지 않은 변수를 찾아 줍니다. set -o pipefail을 사용하면 에러에 대해서 강경한 기준을 적용합니다(이 주제가 조금 미묘하지만 말이죠). 더 복잡한 스크립트의 경우 EXIT나 ERR에 trap도 사용합니다. 이렇게 스크립트를 시작하는 습관은 유용합니다. 이렇게 하면, 일반적인 에러를 찾고 중단하고, 메시지를 출력해 줍니다. 12set -euo pipefailtrap "echo 'error: Script failed: see failed command above'" ERR Bash 스크립트에서 (괄호로 둘러싸여 작성된) 서브 셸은 커맨드를 그룹으로 묶는 편리한 방법입니다. 일반적인 예로, 임시로 다른 디렉터리로 이동하여 작업하는 것이 있습니다. 123# do something in current dir(cd /some/other/dir &amp;&amp; other-command)# continue in original dir Bash 에는 다양한 변수 확장이 있다는 것을 알아두세요. 변수가 존재하는지 확인하려면 ${name:?error message}를 사용하세요. 예를 들어 Bash 스크립트가 하나의 argument를 요구한다면, input_file=${1:?usage: $0 input_file}를 사용하세요. 변수가 비어있을 때를 대비해 기본 값을 사용하세요. ${name:-default} 이전 예제에 선택적인 파라미터를 추가하길 원한다면 output_file=${2:-logfile}로 할 수 있습니다. $2가 생략되어 비어있다면, output_file은 logfile로 설정됩니다. 산술 확장은 i=$(( (i + 1) % 5 )) 처럼 사용합니다. 순열은 {1...10}처럼 사용합니다. 문자열 트리밍(trimmin)은 ${var%suffix}이나 ${var#prefix}처럼 사용할 수 있습니다. 예를 들어 var=foo.pdf라면, echo ${var$.pdf}.txt는 foo.txt를 출력합니다. {…}를 사용한 괄호 확장은 비슷한 텍스트의 재입력을 줄이고, 아이템의 조합을 자동화할 수 있습니다. mv foo.{txt,pdf} some-dir (양쪽 파일들을 옮김), cp somefile{,.bak} (cp somefile somefile.bak로 확장), mkdir -p test-{a,b,c}/subtest-{1,2,3} (모든 가능한 조합으로 확장해 디렉터리 트리를 생성) 같은 예제들은 유용합니다. 커맨드의 실행 결과 출력물은 &lt;(some command)처럼 이용해서 파일처럼 다뤄질 수 있습니다. 예를 들어 로컬의 /etc/hosts를 리모트의 것과 비교하려면 다음처럼 하면 됩니다. 1diff /etc/hosts &lt;(ssh somehost cat /etc/hosts) 스크립트를 적을 때 모든 코드를 대괄호 안에 넣을 수 있습니다. 닫는 괄호가 없으면 스크립트는 구문 에러가 되어 실행이 방지됩니다. 이는 스크립트가 웹으로부터 다운로드할 예정이라 할 때 도중까지만 다운로드된 파일이 실행 되는 걸 예방해 줍니다. 123&#123; # 여기에 코드를 넣으세요&#125; cat &lt;&lt; EOF...같은 “here documents”에 대해서 알아두세요. Bash에서 표준 출력(standard output)과 표준 에러(standard error) 둘 다 some-command &gt; logfile 2&gt;&amp;1같은 명령어로 리다이렉트할 수 있습니다. 종종, 커맨드가 열린 파일 핸들을 남기지 않는 것을 확실히 하기 위해, 현재 작업 중인 터미널에서 명령어에 &lt;/dev/null을 덧붙이는 것은 좋은 습관입니다. man ascii를 사용해서 헥스 값과 10진 값이 같이 있는 훌륭한 ASCII 테이블을 볼 수 있습니다. 일반적인 인코딩 정보를 보려면 man unicode, man utf-8 그리고 man latin1을 이용할 수 있습니다. screen을 이용하거나 tmux를 이용해서 화면을 다중 분할할 수 있습니다. 특히 리모트 ssh 세션을 떼어내고(detach) 다시 붙이는데(re-attach) 유용합니다. byobu은 스크린이나 tmux보다 더 많은 정보를 제공하며, 관리를 편합니다. 세션을 영구히 유지하는 최소한의 대안은 오직 dtach밖에 없습니다. ssh에서 -L이나 -D(가끔 -R)를 이용해서 포트 터널링 하는 것을 알아두시면 유용합니다. 예를 들어 리모트 서버를 경유해서 웹사이트에 접속한다거나 할 때 말이죠. 몇 가지 ssh 설정을 최적화하는 것은 유용할 수 있습니다. 예를 들어 ~/.ssh/config는 특정 네트워크 환경에서 연결이 끊기는 것을 회피하기 위해 압축을 사용하는 설정들을 담고 있습니다(특히 scp 명령어를 낮은 대역폭 연결에서 사용하는 경우에 도움이 됩니다. 그리고 로컬 제어 파일에서 같은 서버로 연결하는 채널을 다중화할 수 있습니다. 1234567TCPKeepAlive=yesServerAliveInterval=15ServerAliveCountMax=6Compression=yesControlMaster autoControlPath /tmp/%r@%h:%pControlPersist yes ssh의 몇 가지 옵션들은 보안에 민감한 옵션이며 주의를 가지고 사용되어야 합니다. 예를 들어 서브넷, 호스트 또는 신뢰되는 네트워크에서 StrictHostKeyChecking=no, ForwardAgent=yes을 사용하는 것 등입니다. UDP을 사용하는 ssh의 대안으로 mosh를 고려해 보세요. 연결이 끊기는 것을 방지하고 길에 편리함이 더해집니다.(서버 사이드 설정 필요) 시스템 설정에 유용하지만 ls로 얻을 수 없고 쉽게 엉망이 되기 쉬운 파일의 권한을 8진법 형태로 얻으려면, 다음과 같은 커맨드를 사용하세요. 1stat -c '%A %a %n' /etc/timezone 다른 커맨드의 출력과 상호작용하면서 값을 선택하려면 percol이나 fzf를 사용하세요. 다른 커맨드(예를 들면 git)의 출력으로 파일과 상호작용하려면, fpp (PathPicker)를 사용하세요. 현재 네트워크에 있는 사용자들에게 현재 디렉터리에 있는 모든 파일(과 하위 디렉터리)를 위한 단순한 웹서버를 원한다면 다음을 사용하세요:python -m SimpleHTTPServer 7777 (7777포트, Python 2) 그리고 python -m http.server 7777 (7777포트, Python 3). 권한을 가지고 커맨드를 실행하려면, sudo를 사용하세요. 기본값은 root 실행하며 sudo -u로 다른 유저를 지정할 수 있습니다. -i를 이용해 다른 사람으로 로그인 할 수 있습니다.(당신의 패스워드를 물어볼 것입니다) 셸을 다른 유저로 전환하려면 su username나 su - username를 사용하세요. -를 넣으면 그 유저가 방금 로그인한 것 같은 환경을 얻을 수 있습니다. 유저 이름을 생략하면 기본값은 root가 됩니다. 당신이 전환하려하는 유저의 비밀번호를 물어볼 것입니다. 커맨드 라인의 128K 제한을 알아 두세요. “Argument list too long” 에러는 많은 파일을 와일드카드 매칭할 때 일반적으로 일어납니다. (이런 일이 일어났을 때에는 find, xargs같은 것이 도움 됩니다.) 단순한 계산에는(물론 일반적으로는 Python에 접근하기 위해) python 인터프리터를 사용하세요. 예를 들어 이렇게 사용할 수 있습니다. 12&gt;&gt;&gt; 2+35 Processing files and data 현재 디렉터리에서 파일을 이름으로 찾으려면 find . -iname &#39;*something*&#39; (또는 비슷하게)를 사용하면 됩니다. 어느 곳에 있든 파일을 이름으로 찾으려면 locate something을 사용하세요(하지만 인내를 가져야 합니다. updatedb가 최근에 생성된 파일을 인덱싱하지 않았을 수 있습니다). 소스나 데이터 파일들에서 일반적인 검색을 할 때는(grep -r보다 더 복잡할 때), ag를 사용하세요. HTML을 텍스트로 변환할 때는 lynx -dump -stdin를 사용하세요. 마크다운, HTML, 그리고 모든 종류의 문서 변환에는 pandoc을 시도해보세요. XML을 반드시 다뤄야한다면, xmlstarlet을 사용하세요. 오래되었지만 좋습니다. JSON에는 jq를 사용하세요. YAML에는 shyaml를 사용하세요. Excel이나 CSV파일에는 csvkit가 in2csv, csvcut, csvjoin, csvgrep외 다른 도구들을 제공합니다. Amazon S3를 다룰 때는 s3cmd가 편리합니다. 그리고 s4cmd는 빠릅니다. Amazon의 aws는 다른 AWS 관련 작업에 핵심적인 도구입니다. sort와 uniq에 대해서 알아두세요. uniq의 -u, -d옵션을 포함해서 말이죠. 하단의 one-liner를 보세요. 그리고 comm도 보세요. 텍스트 파일들을 다루는 cut, paste 그리고 join에 대해서 알아두세요. 많은 사람들이 cut을 사용하지만 join에 대해서는 잊고 있습니다. wc를 이용해서 행(-l), 캐릭터(-m), 단어(-w) 그리고 바이트(-c)를 세는 것을 알아두세요. tee를 이용해서 ls -al | tee file.txt처럼, 표준 입력(stdin)에서 복사해서 파일로 보내거나, 표준 출력(stdout)으로 보내는 것을 알아두세요. 그룹, 필드 뒤집기, 통계적인 계산 같은 좀 더 복잡한 계산은 datamash를 고려해보세요. 로케일이 커맨드 라인 도구에 정렬 순서(collation)와 퍼포먼스를 포함해서 미묘하게 영향을 끼치는 것을 알아두세요. 대부분의 리눅스 설치는 LANG이나 다른 로케일 변수를 US English와 같은 로컬 세팅으로 설정합니다. 하지만 로케일을 바꿀 경우 정렬도 바뀔 것이라는 것에 주의하세요. 그리고 i18n 루틴들도 정렬이나 다른 커맨드들을 몇 배 느리게 할 수 있습니다. export LC_ALL=C를 사용하여, 어떤 상황에서는( 밑에 있는 집합(set) 작업이나, 유일성 작업등) i18n의 느린 루틴들을 통째로 안전하게 무시할 수 있습니다. 그리고 전통적인 바이트 기반의 정렬 순서를 사용할 수 있습니다. TZ=Pacific/Fiji date처럼 특정 명령의 환경 변수를 실행 앞에 붙여 설정할 수 있습니다. 간단한 데이터 조작을 할 때 awk와 sed를 이용하는 것을 알아두세요. 예를 들어 텍스트 파일의 세 번째 열의 숫자들의 모든 값을 더하는 것은 이렇게 합니다: awk &#39;{ x += $3 } END { print x }&#39;. 이 방법은 같은 일을 하는 파이썬 코드보다 3배 정도 빠르고, 1/3 정도의 길이밖에 안됩니다. 여러 파일 안의 문자열을 바꾸려면 다음과 같이 하세요. 1perl -pi.bak -e 's/old-string/new-string/g' my-files-*.txt 여러 파일의 이름을 바꾸거나 검색하거나 문자열을 바꿀 때에는 repren를 써보세요. (어떤 경우에는 rename 명령을 사용해서 여러 파일의 이름을 바꿀 수도 있습니다. 하지만, 모든 리눅스 배포판에서 같은 동작을 하지 않는 것에 주의하세요.) 123456# 파일 이름, 디렉터, 컨텐츠 모두 foo에서 bar로 변경repren --full --preserve-case --from foo --to bar .# 백업 파일을 whatever.bak에서 whatever로 복원repren --renames --from '(.*)\.bak' --to '\1' *.bak# 가능하다면 rename으로 위와 같은 일을 할 수 있음rename 's/\.bak$//' *.bak man 페이지가 이야기하듯, rsync는 정말 빠르고 다재다능한 파일 복사 도구입니다. 기기 간의 동기화에 사용하는 것으로 알려져 있지만, 로컬에서도 충분히 유용합니다. 보안 규정이 허용한다면, scp 대신 rsync를 사용하면 처음부터 전송하는 대신 중단된 지점부터 재전송할 수 있습니다. 또 많은 수의 파일을 삭제하는 가장 빠른 방법이기도 합니다. 1mkdir empty &amp;&amp; rsync -r --delete empty/ some-dir &amp;&amp; rmdir some-dir shuf를 사용해서 파일 안의 임의의 행을 선택하거나, 섞을 수 있습니다. sort의 옵션을 알아두세요. -n은 숫자를 정렬할 때, -h는 사람이 읽을 수 있게 작성한 숫자의 경우(du -h와 같은 형태). 키가 어떻게 작동하는지 알아두세요(-t와 -k). 특별히, 첫 번째 필드로만 정렬해야 한다면 -k1,1을 적어야 한다는 걸 주의하세요. -k1은 모든 행에 대해서 정렬하라는 뜻입니다. 안정적인 정렬(sort -s)도 유용합니다. 예를 들어, 먼저 2번 필드로 정렬하고, 그다음에 1번 필드로 정렬할 경우, sort -k1,1 | sort -s -k2,2처럼 할 수 있습니다. 만약 탭(tab)문자를 Bash 커맨드 라인에 사용해야 할 필요가 생길 경우(예를 들면 -t argument를 이용해 정렬 할 때), ctrl-v [Tab]키를 누르거나, $&#39;\t&#39;를 쓰세요(문자쪽이 복사나 붙여넣기를 할 수 있어 더 낫습니다.). 소스 코드를 패치하는 기본 도구는 diff와 patch입니다. diff와 sdiff(새로 diff)의 통계 요약을 보려면 diffstat를 보세요. diff -r은 모든 디렉터리에 대해 작업을 수행하는 걸 알아두세요. diff -r tree1 tree2 | diffstat으로 변경 내역의 요약을 볼 수 있습니다. 바이너리 파일을 간단하게 hex 덤프를 뜨고 싶을 때는 hd, hexdump, xxd를 쓰세요. 바이너리 파일을 수정할 때는 bvi, biew를 사용하세요. strings (그리고 grep, 등) 을 사용해서 바이너리 파일 안에서 문자열 비트를 찾을 수 있습니다. 바이너리 파일을 diff하려면(델타 압축), xdelta3를 사용하세요. 텍스트 파일 인코딩을 변경하려면 iconv를 시도해보세요. 또는 uconv는 더 복잡한 목적에 사용할 수 있습니다. uconv는 몇 가지 복잡한 유니코드를 지원합니다. 예를 들어, 소문자화하고 모든 악센트를 제거하는(확장하고, 떨어트리는 것을 이용해서) 커맨드는 다음과 같습니다. 1uconv -f utf-8 -t utf-8 -x '::Any-Lower; ::Any-NFD; [:Nonspacing Mark:] &gt;; ::Any-NFC; ' &lt; input.txt &gt; output.txt 파일을 여러 조각으로 나누려면 split(파일을 사이즈로 나눔)이나 csplit(파일을 패턴으로 나눔)을 보세요. 날짜 시간 표현식을 제어하려면 dateutils의 dateadd, datediff, strptime등을 사용하세요. zless, zmore, zcat 그리고zgrep을 이용해서 압축된 파일에 대해 작업하세요. 파일 속성은 chattr로 설정할 수 있습니다. 이는 파일 권한에 대한 저레벨 대안입니다. 예를 들어 sudo chattr +i /critical/directory/or/file로 불변 플래그를 붙여 실수로 파일을 지우는 것을 방지할 수 있습니다. getfacl, setfacl를 사용해 파일 권한을 저장하고 복원할 수 있습니다. 예를 들어, 12getfacl -R /some/path &gt; permissions.txtsetfacl --restore=permissions.txt System debugging 웹 디버깅을 위해서는 curl 와 curl -I 가 도움이 되고, wget도 꽤 도움이 됩니다. 그 외에 보다 현대적인 방식으로는 httpie이 있습니다. cpu/디스크의 상태를 알기 위해서는 top (혹은 더 나은 명령어인 htop), iostat, iotop을 사용하세요. iostat -mxz 15를 사용해 기본 CPU와 파티션 디스크별 정보와 성능 정보를 알 수 있습니다. 네트워크 상태를 자세히 알려면 netstat, ss를 사용하세요. 시스템에 어떤 일이 일어났는지 보려면 dstat가 특히 유용합니다. 보다 시스템의 심층적인 면들을 보려면 glances를 사용해보세요. 메모리의 상태를 알아보려면 free 와 vmstat를 실행하고 그 결과를 해석해보세요. 특히, “cached” 값은 Linux kernel에 의해 file cache로 잡혀있는 메모리 라는 것을 알고 있어야 하고 그래서 “free”값에 대해서 보다 효율적으로 계산할 수 있습니다. Java 시스템의 디버깅은 조금 다른 상황입니다. 하지만 Oracle과 그 외의 회사에서 만든 다른 JVM들에서는 kill -3 &lt;pid&gt;를 실행하면 전체 stack trace 정보와 heap의 정보(시기별로 가비지 컬렉터의 세부적인 내용 같은 매우 유용한 정보)를 요약하여 stderr나 로그로 출력해주므로 간단하게 정보를 얻어올 수 있습니다. JDK의 jps, jstat, jstack, jmap 명령은 유용합니다. SJK tools은 더 고급 정보를 다룰 수 있습니다. 네트워크 이슈들을 알아보기 위해서는 traceroute를 사용할 수도 있지만 더 좋은 mtr를 사용하세요. 디스크가 왜 가득 찼는지 알아보기 위해서 ncdu를 사용해보세요. 일반적으로 사용하는 du -sh *와 같은 커맨드를 사용하는 것보다는 시간을 줄일 수 있습니다. 어떠한 소켓이나 프로세스가 사용하는 대역폭(bandwidth)를 찾아보려면 iftop나 nethogs를 사용하세요. ab라는 툴(Apache에 딸려있는)은 신속하고 간단하게(quick-and-dirty) 웹서버의 성능을 체크하는데 유용합니다. 보다 복잡한 부하 테스트를 할 때는 siege를 사용해보세요. 보다 심각한 경우의 네트워크 디버깅을 위해서는 wireshark, tshark, ngrep를 사용하세요. strace 와 ltrace에 대해서 알아보세요. 이 커맨드들은 만일 어떤 프로그램에서 failing, hanging 혹은 crashing이 일어나거나 그 외에 여러분이 무슨 이유인지 알지 못하는 상황이나 성능에 대한 대략적인 내용을 얻고자 할 때 유용할 것입니다. 특히 프로파일링을 위한 옵션(-c)과 현재 실행 중인 프로세스에 붙이기 위한 옵션(-p)을 기억하세요. 공유 라이브러리(shared libraries) 등을 체크하기 위해서는 ldd에 대해 알아보세요. gdb를 가지고 현재 실행 중인 프로세스에 연결하고 그 프로세스의 stack trace들을 얻는 방법을 알아보세요. /proc를 사용하세요. 이것은 현재 발생하고 있는 문제를 디버깅할 때 종종 놀랍도록 큰 도움이 될 것입니다. 예시:/proc/cpuinfo, /proc/meminfo, /proc/cmdline, /proc/xxx/cwd, /proc/xxx/exe, /proc/xxx/fd/, /proc/xxx/smaps (xxx는 프로세스 id나 pid입니다). 과거에 왜 무엇인가가 잘못되었는지를 디버깅할 때에는 sar가 매우 유용할 것입니다. 이 커맨드는 CPU, memory, network 등의 통계 내역을 보여줍니다. 시스템의 보다 깊은 곳을 보거나 퍼포먼스를 분석하기 위해서는, stap (SystemTap), perf), sysdig를 사용해보세요. 여러분이 사용하는 Linux의 배포판이 무엇인지 확인(대부분의 배포판에서 작동합니다)하려면 uname이나 uname -a 또는 lsb_release -a를 사용하세요. 언제든지 무언가가 정말로 재미있는 반응을 보인다면 dmesg를 사용해보세요(아마도 하드웨어나 드라이버의 문제일 것입니다). 파일을 삭제했는데 du로 확인해 예상한 디스크 공간을 확보하지 못했다면, 파일이 프로세스에 의해 사용 중인지 확인해보세요.lsof | grep deleted | grep &quot;filename-of-my-big-file&quot; One-liners커맨드들을 한데 묶어서 사용하는 예제들 sort/uniq를 사용하여 텍스트 파일의 교차점, 조합, 차이점을 확인이 필요할 때 상당한 도움이 될 겁니다. 가령 a와 b가 유일한 값들만을 가진 텍스트 파일이라 합시다. 이것이 임의의 크기인 파일을(그게 기가바이트라고 해도) 빠르게 작업할 수 있습니다. (Sort는 메모리 제한에 걸리지 않습니다만, 만약 루트 파티션이 작은 경우, /tmp를 사용하기 위해 -T옵션을 사용하면 됩니다.) 위의 LC_ALL에대한 내용은 sort의 -u옵션을 확인하십시오. (아래 예제에 집중하기 위해서 생략) 123cat a b | sort | uniq &gt; c # c is a union bcat a b | sort | uniq -d &gt; c # c is a intersect bcat a b b | sort | uniq -u &gt; c # c is set difference a - b grep . *을 사용해서 디렉터리 안의 모든 파일을 비주얼하게 살펴볼 수 있습니다.(r각 줄은 파일 이름과 같이 나옵니다) 아니면 head -100 *를 이용할 수도 있습니다.(각 파일의 해더만 볼 수 있습니다.) 이는 /sys, /proc, /etc 같이 설정값들로 가득한 디렉터리에서 유용합니다. 텍스트 파일의 세 번째 열의 숫자들의 모든 값을 더하는 것은 이렇게 합니다. 이 방법은 같은 일을 하는 파이썬 코드보다 3배 정도 빠르고, 1/3 정도의 길이밖에 안됩니다. 1awk '&#123; x += $3 &#125; END &#123; print x &#125;' myfile 파일 트리에서 크기와 날짜를 보려면 이렇게 하세요. 이 명령어는 ls -l을 재귀적으로 수행하는 것과 같지만, ls -lR보다 더 읽기 쉽습니다. 1find . -type f -ls 웹서버 로그 같은 텍스트 파일이 있다고 합시다. 그리고 URL 파라미터에 나타나는 acct_id같은 특정 값이 몇몇 행에 나타난다고 해보죠. 각각의 acct_id에 대해 얼마나 많은 요청이 있었는지 알고 싶다면 다음처럼 할 수 있습니다. 1cat access.log | egrep -o 'acct_id=[0-9]+' | cut -d= -f2 | sort | uniq -c | sort -rn 변경을 계속 모니터링하려면 watch를 이용하세요. 예를 들어 watch -d -n 2 &#39;ls -rtlh | tail&#39;로 한 디렉터리 내의 파일 변경을 확인하거나, watch -d -n 2 ifconfig로 와이파이 설정을 고칠 때 네트워크 설정 변경을 확인할 수 있습니다. 다음 함수를 실행하면 이 문서에 있는 팁 중 임의의 것을 얻을 수 있습니다(마크다운을 파싱하고 항목을 추출합니다). 1234567function taocl() &#123; curl -s https://raw.githubusercontent.com/jlevy/the-art-of-command-line/master/README.md | pandoc -f markdown -t html | xmlstarlet fo --html --dropdtd | xmlstarlet sel -t -v "(html/body/ul/li[count(p)&gt;0])[$RANDOM mod last()+1]" | xmlstarlet unesc | fmt -80&#125; Obscure but useful expr: 산술적이거나 논리적인 작업을 수행하거나 정규표현식을 검증할때 사용합니다 m4: 간단한 메크로 수행기를 실행합니다 yes: 어떠한 한 문장을 매우 많이 출력합니다 cal: 간단한 달력을 보여줍니다 env: 어떤 한 커맨드를 실행합니다(스크립트를 만들때 유용합니다) printenv: 환경 변수들을 출력합니다(디버깅을 할때나 스크립트를 만들때 유용합니다) look: 어떤 문자열로 시작하는 영단어(혹은 파일의 어떤 한 줄)을 찾습니다 cut, paste, join: 데이터를 수정할때 사용합니다 fmt: 문단의 서식을 지정합니다 pr: 문서의 페이지나 컬럼 서식을 지정합니다 fold: 문서의 각 라인들을 특정한 길이에 맞게 수정합니다 column: 문서의 컬럼이나 테이블의 서식을 지정합니다 expand, unexpand: 탭을 공백으로 바꾸어주거나 공백을 탭으로 바꾸어줍니다 nl: 줄 번호를 추가해줍니다 seq: 숫자들을 출력하는데 사용합니다 bc: 간단한 계산기를 실행합니다 factor: 정수들을 인수분해하는데 사용합니다 gpg: 파일들을 암호화하고 서명하는데 사용합니다 toe: terminfo 엔트리들의 테이블(table of terminfo entries) nc: 네트워크를 디버깅하거나 데이터를 전송할 때 사용합니다 socat: 소켓 릴레이나 TCP 포트로 내용을 전달할 때 사용합니다(netcat과 비슷합니다) slurm: 네트워크 상황을 시각화하여 보여줍니다 dd: 파일들이나 디바이스들 간에 데이터를 옮길때 사용합니다 file: 파일의 종류를 알아내는데 사용합니다 tree: 디렉터리들과 그 하위 디렉터리를 마치 ls를 반복적으로 입력한 것처럼 트리의 형태로 보여줍니다 stat: 파일의 정보를 보여줍니다 time: 명령을 실행하고 시간을 잽니다 timeout: 특정 시간만큼 명령을 실행하고 시간이 끝나면 프로세스를 종료합니다. lockfile: rm -f로만 지울 수 있는 세마포어 파일을 생성합니다 logrotate: 로그를 로테이트, 압축, 메일로 보냅니다 watch: 명령을 반복적으로 실행해 결과를 보여주거나 변경을 하일라이트합니다 tac: 파일의 내용을 역순으로 출력합니다 shuf: 파일의 각 줄들을 임의의 순서로 출력합니다 comm: 정렬된 파일들을 각 라인별로 비교합니다 pv: 파이프를 통해서 프로세스의 정보를 모니터링하는데 사용합니다 hd and bvi: 바이너리 파일을 수정하거나 덤프를 얻어오는데 사용합니다 strings: 바이너리 파일들에서 특정 문장을 추출하는데 사용합니다 tr: 문자를 변환하거나 조작하는데 사용합니다 iconv or uconv: 문서의 인코딩방식을 변환하는데 사용합니다 splitand csplit: 파일들을 쪼개는데 사용합니다 sponge: 쓰기 전에 모든 입력을 읽습니다. 같은 파일에서 읽은 후에 쓰기에 유용합니다. 예를 들면 grep -v something some-file | sponge some-file처럼 사용할 수 있습니다. units: 단위를 변환하거나 계산하는데 사용합니다 예를들어 furlongs/fortnight 단위를 twips/blink로 변환합니다 (/usr/share/units/definitions.units를 참고하세요) apg: 렌덤 패스워드를 생성합니다 xz: 고효율의 파일 압축프로그램입니다 ldd: 동적 라이브러리들의 정보를 보여줍니다 nm: 오브젝트 파일들에 포함된 심볼정보를 얻어옵니다 ab: 웹 서버를 벤치 마킹하는데 사용합니다 strace: 시스템 콜을 디버깅할때 사용합니다 mtr: 네트워크 디버깅시에 traceroute보다 더 낫습니다 cssh: 쉘을 동시에 여러개 사용할때 사용합니다 rsync: SSH를 이용해 원격 파일 시스템이나, 로컬 파일시스템의 파일과 폴더들을 동기화 할때 사용합니다 wireshark, tshark: 패킷정보를 가져오며 네트워킹을 디버깅하는데 사용합니다 ngrep: 네트워크 환경에서 grep과 같은 역할을 합니다 host, dig: DNS 정보를 보여줍니다 lsof: 프로세스 파일 디스크립터와 소켓의 정보를 보여줍니다 dstat: 유용한 시스템 정보를 보여줍니다 glances: 보다 고차원의 여러 서브시스템들의 정보를 한번에 보여줍니다 iostat: 디스크의 사용량 정보를 보여줍니다 mpstat: CPU 사용량 정보를 보여줍니다. vmstat: 메모리 사용량 정보를 보여줍니다. htop: 보다 개선된 형태의 top을 보여줍니다 last: 로그인 했던 정보들을 보여줍니다 w: 현재 누가 로그인했는지 보여줍니다 id: 현재 유저나 그룹에 대한 식별 정보를 보여줍니다 sar: 시스템 상태에 대한 정보를 보여줍니다 iftop, nethogs: 소켓 또는 프로세스를 이용하여 네트워크를 정보를 보여줍니다 ss: 소켓에 관한 통계자료들을 보여줍니다 dmesg: 부팅 메시지와 시스템 에러 메시지들을 보여줍니다 sysctl: 실행 시에 리눅스 커널 파라미터를 보여주거나 설정합니다 hdparm: SATA/ATA disk들의 정보를 수정하거나 그것들이 작동하도록 합니다 lsblk: 블록 디바이스들의 목록을 보여줍니다 : 여러분의 디스크들이나 디스크파티션들을 트리의 형태로 보여줍니다 lshw, lscpu, lspci, lsusb, dmidecode: CPU, BIOS, RAID, graphics, devices 등의 하드웨어 정보를 보여줍니다 lsmod, modifno: 커널 모듈의 상세정보를 목록으로 보여줍니다. fortune, ddate, sl: 에… 증기기관차를 생각하고있고 그것을 인용하고 싶다면 이것은 “유용”합니다 macOS onlyOS X에서만 해당되는 항목입니다. brew (Homebrew)나 port (MacPorts)를 패키지 매니저로 사용합니다. 위의 많은 명령어를 OS X에 설치하여 사용할 수 있습니다. pbcopy를 이용하여 데스크톱 애플리케이션에 명령어 출력물을 복사하거나 pbpaste를 이용해 붙여넣기를 할 수 있습니다. OS X 터미널에서 옵션 키를 알트 키(alt-b, alt-f 같은 위에 나온 명령)로 사용하려면 Preferences -&gt; Profiles -&gt; Keyboard를 열어 “Use Option as Meta key”를 선택하세요. 데스크톱 애플리케이션에서 파일을 열기위해, open 또는 open -a /Applications/Whatever.app을 사용하면 됩니다. Spotlight: mdfind를 이용해 파일을 찾고, mdls를 이용해 메타데이타 (사진 EXIF 정보와 같은) 목록을 볼 수 있습니다. OS X는 BSD Unix 기반이며 많은 명령어들을 (예로 ps, ls, tail, awk, sed) 사용할 수 있으며, 이것들은 Linux 버전들과 미묘한 차이가 있습니다. 그리고 크게는 System V-style Unix와 GNU 도구들에 많은 영향을 받았습니다. 이런 내용들을 man 페이지 상단의 “BSD General Commands Manual.” 라는 문구를 통해 알 수 있습니다. 가끔은 GNU 버전이 설치되기도 합니다. (예로, GNU awk와 sed인 gawk와 gsed에서). 만약 이종 플랫폼 간 Bash 스크립트를 작성하려면, 동일한 명령어 (예로, 파이썬이나 perl과 같은)나 테스트시 주의해야 합니다. OS X 릴리스 정보를 얻으시려면, sw_vers를 사용하세요. Windows onlyWindows에서만 해당되는 항목입니다. Windows 10에서는 Bash on Ubuntu on Windows를 사용할 수 있습니다. 이는 유닉스 커맨드 라인 도구와 함께 친숙한 Bash 환경을 제공합니다. 좋은 점은, 리눅스 프로그램을 Windows에서 사용할 수있게 합니다. 하지만 Bash에서 Windows 프로그램을 사용할 수는 없습니다. Cygwin를 설치해 Microsoft Windows에서 유닉스 셸을 사용할 수 있습니다. 이 문서에 기술된 대부분의 것들은 그대로 동작할 것입니다. Cygwin의 패키지 매니저로 유닉스 프로그램을 더 설치할 수 있습니다. 커맨드 라인 창으로 mintty를 사용하세요. Windows의 클립보드를 /dev/clipboard로 접근할 수 있습니다. cygstart을 실행해 등록된 애플리케이션을 사용해 임의의 파일을 열 수 있습니다. Windows 레지스트리는 regtool로 접근할 수 있습니다. C:\\ Windows 드라이브 경로는 Cygwin에서는 /cygdrive/c가 되고, Cygwin의 / Windows에서 C:\cygwin가 되는것을 알아 두세요. Cygwin과 Windows 스타일의 파일 패스는 cygpath로 변환할 수 있습니다. 이는 Windows 프로그램을 실행하는 프로그램에서 유용하게 사용됩니다. You can perform and script most Windows system administration tasks from the command line by learning and using wmic. Windows에서 유닉스 룩엔필을 얻는 다른 대안은 Cash입니다. 이 환경에는 매우 적은 유닉스 명령과 커맨드 라인 옵션만 사용가능하니 주의하세요. Windows에서 GNU 개발자 툴(GCC같은)을 얻는 다른 대안으로 MinGW와 거기에 포함된 MSYS 패키지가 있습니다. 여기에는 bash, gawk, make, grep같은 도구가 포함됩니다. MSYS는 Cygwin에 비교하면 모든 기능은 없습니다. MinGW는 유닉스 툴을 네이티브 Windows로 포팅할 때 부분적으로 유용합니다. More resources awesome-shell: 셸에 대한 툴과 리소스들이 잘 정리되어 있는 리스트입니다. awesome-osx-command-line: OS X 커맨드 라인에 관해 더 깊이 알수 있는 가이드 입니다. Strict mode: 보다 나은 셸 스크립트를 작성하기 위한 정보글입니다. shellcheck: 셸 스크립트 정적 분석 도구 입니다. 특히, bash/sh/zsh에 대한 린트입니다. Filenames and Pathnames in Shell: 셸 스크립트에서 파일 이름을 처리하는 법을 다루는 슬프도록 복잡한 미니츄어입니다. Data Science at the Command Line: 같은 이름의 책에서 나온, 데이터 사이언스를 위한 더 나은 명령과 도구들 입니다. Disclaimer매우 작은 작업을 제외한 코드들은 다른 사람이 읽을 수 있도록 작성됩니다. 큰 힘에는 책임이 따릅니다. Bash에서 뭔가를 할 수 있다는 것은 Bash로 해야 된다는 의미가 아닙니다! ;) License 이 저작물은 Creative Commons Attribution-ShareAlike 4.0 International License에 따라 이용할 수 있습니다.]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%9A%84%E8%89%BA%E6%9C%AF%2FREADME-ja%2F</url>
    <content type="text"><![CDATA[🌍Čeština ∙ Deutsch ∙ Ελληνικά ∙ English ∙ Español ∙ Français ∙ Indonesia ∙ Italiano ∙ 日本語 ∙ 한국어 ∙ Português ∙ Română ∙ Русский ∙ Slovenščina ∙ Українська ∙ 简体中文 ∙ 繁體中文 The Art of Command Line メタ情報 基本 日常的に使うもの ファイルとデータの処理 システムのデバッグ ワンライナー 目立たないが便利なもの OS X用のもの Windows専用 さらなるリソース 免責事項 コマンドラインで流れるように操作ができるということは、軽く見られたり他人から理解されないスキルだとみなされることもあるだろう。しかしそのスキルは、明らかにかすぐ分かるようかは問わず、エンジニアとしてのあなたの柔軟性や生産性を改善してくれるものだ。ここでは、Linuxでコマンドラインを使う上で便利だと思ったメモやTipsの数々を挙げてみる。あるものは基礎的だが、非常に詳しいもの、洗練されたもの、曖昧なものもある。このページはそんなに長いものではないが、ここに書いてあることの全てを使ったり思い出すことができれば、かなり詳しくなれるだろう。 このドキュメントは多くの執筆者と翻訳者による成果である。ここに書いてあることの多くは、元々Quoraに書かれていたものが多いが、より優れた人たちがすぐに改善案を出すことができるGitHubに置くのがよいのではと思った。コマンドラインについて疑問があるなら質問してみよう エラーや改善点を見つけたら貢献してみよう! メタ情報対象 : このガイドは、初心者向けでも経験者向きでもある。幅広く(書いてあることは全て重要)、かつ明確で(多くのケースに対して具体的な例を付ける)、そして簡潔(他の場所で見つけられるような重要でないことや脱線したことは省く)であることをゴールにしている。各項目は、多くの場面において必須であるか、他の方法に比べて劇的に時間を節約してくれるだろう。 OS X用のものを除き、Linux向けの内容となっており、その多くは各種LinuxおよびMacOS(あるいはCygwin)でも使えるだろう。 インタラクティブなBashを使うことを想定しているが、多くの項目は他のシェルやBashのスクリプトでも使えるだろう。 (このリポジトリへ)組み込むメリットがあるのであれば、標準Unixコマンドやパッケージインストールコマンドも含める。 注意 : 1ページ内に収めるために、内容には暗黙的に書かれていることがある。ここで取りかかりを知ったりコマンドが分かれば、詳細をどこかで調べたりするくらいはできるだろう。新しいプログラムをインストールするには、apt-get、yum、dnf、pacman、pip、brew(どれか適したもの)を使おう。 コマンドやオプション、パイプを分解して理解する手助けに、Explainshellを使おう。 基本 基本的なBashを学ぼう。実際のところ、man bashは結構簡単に理解できるしそんなに長くないので、これで一通りのことは分かる。それ以外のシェルもよいが、Bashは強力だし、常に使用可能であるという利点もある(自分のPCに入れてしまったと言ってzshやfishなどだけを学んでしまうと、既存のサーバを触らなくてはならない時などに制約が出てしまう)。 テキストエディタのどれか最低1つに習熟しよう。nanoエディタは編集の基本操作(開く、修正する、保存する、検索する)を学ぶ最もシンプルな方法のひとつだ。ターミナル内で適当にものを書くにあたって他に全く代替品がないという点で、理想的にはVim(vi)がよいだろう(通常はEmacsや高機能なIDEや最新のかっこいいエディタをメインに使っていたとしても)。 manでのドキュメントの読み方を知ろう(知りたがりのために書くと、man manでセクション番号が分かる。例えば1は「一般的な」コマンド、5はファイルやそのお作法、8は管理についてといった具合)。aproposでmanページを探そう。コマンドによっては実行可能ファイルではなくBashのビルトインコマンドであることを理解し、helpやhelp -dでヘルプが見られることを知ろう。 &gt;や&lt;、|を使ったパイプによる入出力のリダイレクションを学ぼう。&gt;は出力ファイルを上書き、&gt;&gt;は追記となる。stdout(標準出力)とstderr(標準エラー出力)を学ぼう。 *(または?や[…])を使ったファイルグロブ展開、クォーテーション、ダブルクォート&quot;とシングルクォート&#39;の違いを学ぼう(詳しくはこの後の変数展開の項を参照)。 &amp;、ctrl-z、ctrl-c、jobs、fg、bg、killなど、Bashのジョブ管理について詳しくなろう。 sshについて知るとともに、ssh-agentやssh-addを使ったパスワードなしの認証の基本について理解しよう。 ファイル管理について。lsやls -l(特に、ls -lの各列が何を意味するか理解)、less、head、tail、tail -f(またはless +F)、lnとln -s(ハードリンクとソフトリンクの違いとそれぞれの利点の理解)、chownとchmod、du(ディスク使用量まとめを簡単に見るならdu -hs *)。ファイルシステム管理については、df、mount、fdisk、mkfs、lsblk。inodeについては、ls -i(または df -i)。 基本的なネットワーク管理について。ipあるいはifconfig、dig、traceroute、 route。 gitのようなバージョン管理システムを学んで使ってみよう。 正規表現について詳しく知ろう。grepやegrepの色々なフラグも合わせて。-i、-o、-v、-A、-B、-Cといったオプションは知っておいて損はない。 apt-get、yum、dnf、pacman(ディストリビューションによって違う)といったコマンドでパッケージを探したりインストールする方法を学ぼう。Pythonベースのコマンドラインツールをインストールするのに、pipも必要だ(後に出てくるいくつかのコマンドはpipでインストールするのが一番簡単)。 日常的に使うもの Bashでは、引数を補完、または利用可能なコマンドを列挙するのにタブを使い、コマンド履歴から検索するのにctrl-rを使う。(検索キーを入力した後、ctrl-rを繰り返し入力することで次から次へと検索結果を送ることができる。Enterで見つかったコマンドの実行となり、Enterではなく右カーソルキーを押した場合は見つかったコマンドが入力された状態になる。) Bashでは、最後の単語を削除するのにはctrl-w、行頭まで全て削除するにはctrl-uを使う。単語ごとに移動するにはalt-bまたはalt-f、行頭に移動するにはctrl-a、行末に移動するにはctrl-e、行末まで削除するにはctrl-k、画面のクリアはctrl-lである。Bashにおけるデフォルトのキー割り当てを全て見るにはman readlineを参照。たくさん出てくる。例えば、alt-.は前の引数を順番に表示し、alt-*はグロブを展開する。 vi風のキー割り当てが好きなら、set -o viを実行しよう。(元に戻したいときはset -o emacs) 長いコマンドを編集するときに、エディタを設定した後で(例えばexport EDITOR=vim)、ctrl-x ctrl-eによって編集中のコマンドが複数行の編集のために指定したエディタで開かれる。vi風の場合は、escape-v。 最近実行したコマンドを確認するならhistory。!nと続けることで(nはコマンド横に表示される数字)再度実行できる。ctrl-rやalt-.で用は足りるだろうが、!$(直前の引数)や!!(直前のコマンド)といった省略形もたくさんある。 cdでホームディレクトリへの移動。ホームディレクトリに関連するファイルにアクセスする場合はプレフィックス~をつける(例: ~/.bashrc)。shスクリプトの中では$HOMEでホームディレクトリを表すことができる。 前のワーキングディレクトリに戻るならcd - 途中までコマンドを入力したけれど心変わりした時は、alt-#を打つと行頭に#が挿入され、コメントとして入力される(ctrl-a、#、enterでも同じ)。これは後でコマンド履歴から検索できる。 xargs(またはparallel)を使おう。非常に強力。行ごとにいくつのアイテムを実行するか(-L)や、並列度(-P)も制御できる。正しく実行されるか定かでないなら、まずxargs echoしてみればよい。-I{}も便利。例えば以下の通り。 12find . -name '*.py' | xargs grep some_functioncat hosts | xargs -I&#123;&#125; ssh root@&#123;&#125; hostname pstree -pはプロセスツリーを表示するのに便利。 pgrepやpkillで、プロセス名で検索したりシグナルを送れる(-fも便利)。 プロセスに送れる色々なシグナルを知っておこう。例えば、プロセスをサスペンドするにはkill -STOP [pid]を使う。全種類見るなら、man 7 signal。 バックグラウンドプロセスをずっと実行し続けたいならnohupあるいはdisownを使おう。 netstat -lntpやss -platで、どんなプロセスがリッスンしているか確認しよう(UDPなら-uを付ける)。 開かれているソケットやファイルを見るにはlsofも参照。 uptimeやwによってシステムの稼働時間を調べられる。 aliasによってよく利用するコマンドのエイリアス(ショートカット)を作成できる。例えば、alias ll=&#39;ls -latr&#39;では新しいエイリアスであるllが作成される. よく使うエイリアス、シェル設定、機能を~/.bashrcに保存し、ログインシェルに反映しよう。これで全てのセッションであなたの設定が利用できる。 ログイン時に実行されてほしいコマンド、環境変数を~/.bash_profileに記載する。画面からのログインやcronジョブで起動されるシェルには別の設定が必要だ。 Gitで様々なマシンの設定ファイル(例:.bashrcや.bash_profile)を同期させよう。 空白を含む変数やファイル名には注意が必要だ。Bash変数にはクオートをつけよう、こんな風に&quot;$FOO&quot;。ファイル名の区切りとしてヌル文字を指定する場合には-0や-print0オプションを付与しよう。例: locate -0 pattern | xargs -0 ls -al or find / -print0 -type d | xargs -0 ls -al。空白を含んだファイル名を繰り返し実行するためには、IFS=$’\n’`を使ってIFSを改行のみにしよう。 Bashスクリプトでは、set -xでデバッグ出力を出せる(set -vは、実行されるコマンドや変数名やコメントなどをそのまま出力する)。特別な理由がない限り厳格モード(strict mode)を使い、set -eでエラー時(0以外の終了コード時)に強制終了するように。set -uによって未定義の変数の利用を検知、パイプのエラーも厳格に扱うためにset -o pipefailも使おう(これはちょっと微妙かも)。より複雑なスクリプトなら、EXITまたはERRシグナルに対してtrapも使おう。使う場面としては以下の場合のようにエラーを検知してメッセージを出力するとき: 12set -euo pipefailtrap "echo 'error: Script failed: see failed command above'" ERR Bashスクリプトでは、コマンドのグループを作るのにサブシェル(丸括弧で囲まれた部分)が便利。一時的にワーキングディレクトリを移動するというよくある例。 123# カレントディレクトリで何か実行(cd /some/other/dir &amp;&amp; other-command)# 元のディレクトリで作業続行 Bashでは、たくさんの変数展開の種類があることを覚えておこう。変数が存在するかチェックするなら、${name:?error message}。例えば、Bashスクリプトが1つの引数を取る必要があるなら、input_file=${1:?usage: $0 input_file}とだけ書けばよい。算術式の展開は、i=$(( (i + 1) % 5 ))。シーケンスは{1..10}。文字列のトリミングは${var%suffix}と${var#prefix}。例えばvar=foo.pdfの時、echo ${var%.pdf}.txtとするとfoo.txtが出力に。 {…}を使った中括弧展開によって、似たようなコマンドを複数回入力しなくて済む。例えば、 mv foo.{txt,pdf} some-dir (両方のファイルを移動させる), cp somefile{,.bak} (cp somefile somefile.bak と展開される)、mkdir -p test-{a,b,c}/subtest-{1,2,3} (すべての可能な組み合わせでディレクトリが作られる). 展開の順序は括弧→チルダ、パラメータや変数、計算機号、コマンド置換(左から右)→文字の分割→ファイル名の順だ。(例えば、{1..20}のような範囲は{$a..$b}というようには表現できない。seqやforループを使ってこんな風に表すことができる。seq $a $b or for((i=a; i&lt;=b; i++)); do ... ; done) コマンドの出力を&lt;(some command)のようにしてファイルのように扱える。例えば、ローカルとリモートのの/etc/hostsを比較するなら以下のようになる。 1diff /etc/hosts &lt;(ssh somehost cat /etc/hosts) スクリプトを書く時は全てのコードを中括弧で囲まなくてはいけない。もし閉じ括弧が欠けていたらシンタックスエラーで実行が妨げられる。これはあなたがスクリプトをダウンロードしたときに判明する。（不完全なスクリプトの）実行によって部分的にwebからダウンロードしてしまうのを防ぐためだ。 123&#123; # Your code here&#125; 「ヒアドキュメント」によって、ファイルからの複数行のリダイレクトのように振る舞うことができる。 1234cat &lt;&lt;EOFinputon multiple linesEOF Bashでは、some-command &gt;logfile 2&gt;&amp;1またはsome-command &amp;&gt;logfileで標準出力と標準エラー出力の両方をリダイレクトできる。コマンドが標準入力に対してファイルハンドルを開きっぱなしにせず、ログインしているターミナルにひもづけておくため、&lt;/dev/nullするのもよい習慣。 16進と10進のASCIIテーブルを見るのにman asciiを使おう。一般的なエンコードに関する情報は、man unicodeやman utf-8、man latin1が便利。 スクリーンの分割にscreenやtmuxを使おう。特に、リモートのSSHセッションをデタッチしたりアタッチし直したりするのに有効。byobuはscreenやtmuxの情報をより多く提供してくれ、管理が容易になる。セッション永続化だけの簡単なものならdtach。 SSHで-Lあるいは-D(まれに-R)を使ったポートトンネルのやり方を覚えておくと便利。例えばリモートのサーバからウェブサイトにアクセスする時など。 SSHの設定を少しでも最適化しておくと便利。例えば以下の~/.ssh/configの設定だと、ネットワーク環境による接続断を回避し、圧縮を使用し(帯域の細い回線を使ったscpなどで便利)、ローカルの制御ファイルを指定して同一サーバとのチャネルを多重化する。 1234567TCPKeepAlive=yesServerAliveInterval=15ServerAliveCountMax=6Compression=yesControlMaster autoControlPath /tmp/%r@%h:%pControlPersist yes これ以外のSSHオプションはセキュリティ上の問題がある可能性があるため、有効にするには、サブネットごとやホストごとに指定したり、信頼できるネットワーク内でのみ使用するなど注意が必要。StrictHostKeyChecking=no、ForwardAgent=yesなど。 moshはUDPを使ったsshの代替で、(サーバー側での設定は必要であるが) 断続的な接続時に便利。 8進数表現のファイルパーミッションは、システム設定の際に便利だがlsの結果にも出てこず、間違いやすい。以下のようにして取得できる。 1stat -c '%A %a %n' /etc/timezone 何らかのコマンドの出力から、インタラクティブに値を選択したい場合は、 percol または fzfを使おう。 (gitを使うなど)何らかのコマンドの出力からファイルに関するやり取りをする場合は、fpp (PathPicker)を使おう。 カレントディレクトリ(とサブディレクトリ)全体を、ネットワーク内に公開されたWebサーバにするなら、python -m SimpleHTTPServer 7777 (ポート7777で公開。Python 2の場合)あるいはpython -m http.server 7777 (Python 3の場合)。 特権レベルでコマンドを実行するとき、rootでの実行にはsudo、他のユーザの場合はsudo -uを利用。su または sudo bashで、シェルがそのユーザで起動する。su -でrootまたは他のユーザで新たにログインした状態がシミュレートされる。 異なるユーザーのシェルに移りたいと時はsu usernameやsu - usernameを使おう。”-“を用いることでまるで他のユーザーがログインしたかのように環境を得ることができる。スイッチ先のユーザーのパスワードを求められる。 コマンドラインの128K 制限について知ろう。この”Argument list too long”エラーはワイルドカードに大量のファイルがマッチしてしまったときに出る一般的なものだ。(もしこれが起きたらfind や xargsが代替として助けになるだろう。) 基本的な計算(もちろんPythonの利用が一般的だ)にはpython interpreterを使おう。例えばこんな風に。 12&gt;&gt;&gt; 2+35 ファイルとデータの処理 カレントディレクトリ以下のファイルをファイル名で探したいなら、find . -iname &#39;*something*&#39;。場所を指定せずにファイル名で検索したいなら、locate somethingをつかおう(ただしupdatedbは最近作られたファイルはインデックスしていないであろうことに注意)。 ソースやデータファイルの(grep -rよりも高度な)一般的な検索には、ack、ag (“the silver searcher”)、そしてrg (ripgrep)を使おう。 HTMLをテキストに変換するなら、lynx -dump -stdin。 MarkdownやHTMLなど様々な種類のドキュメントの変換には、pandocを試してみるとよい。 XMLを扱わなくてはならないなら、xmlstartletは古いがいいツールだ。 JSONにはjqを使おう。 YAMLにはshyamlを。 ExcelやCSVファイルには、csvkitでin2csv、csvcut、csvjoin、csvgrepなどが使えるようになる。 Amazon S3には、s3cmdが便利で、s4cmdはさらに高速。AWS関連の処理にはAmazon公式のawsと改善版のsawsが欠かせない。 sortやuniq、さらにuniqの-uや-dオプションを知っておこう。後に出てくるワンライナーも参照。commも確認しておこう。 複数のテキストファイルを操作するのには、cutとpaste、joinは知っておこう。cutはみんな使っているが、joinは忘れられている。 wcを理解し、改行(-l)、文字(-m)、単語(-w)、バイト(-c)それぞれの数え方も知っておこう。 標準入力をファイルと標準出力の両方に出すteeを理解しよう。ls -al | tee file.txtのように使う。 グルーピング、フィールドを入れ替える、統計的な計算といったもっと複雑な作業はdatamashの利用を検討しよう。 ロケールは、ソートの順序(照合順序)やパフォーマンスなど、たくさんのコマンドラインツールに微妙なところで影響することを覚えておこう。多くのLinuxディストリビューションでは、LANGや他のロケール変数はUS Englishのようなローカルな設定になっている。ロケールを変更するとソート順序が変わることに注意しよう。また、国際化(i18n)対応のルーチンはソートやその他の処理を何倍も遅く実行するようになる点も知っておこう。場合(設定の処理や一意性を見つける処理など)によっては、export LC_ALL=Cとしてしまい遅いi18n対応の処理を完全に無視してしまうことも可能だ。 TZ=Pacific/Fiji dateのように起動時に変数を前につけることで、特定のコマンドの環境変数をセットすることができる。 単純なデータ加工のためにawkとsedの基礎を身につけよう。ワンライナーを参照。 1つあるいは複数のファイル内の文字列を直接置き換えてしまうには、 1perl -pi.bak -e 's/old-string/new-string/g' my-files-*.txt 複数のファイル名の変更やファイル内の検索や置換には、reprenを使ってみよう。(場合によってはrenameコマンドでも複数のファイル名変更ができるが、すべてのLinuxディストリビューションで挙動が同じであるわけではないので注意が必要。) 123456# foo -&gt; barへとファイル名、ディレクトリ名、ファイルの中身を変更する:repren --full --preserve-case --from foo --to bar .# バックアップファイルを元に戻す whatever.bak -&gt; whatever:repren --renames --from '(.*)\.bak' --to '\1' *.bak# 上記と同じものをrenameを使って:rename 's/\.bak$//' *.bak マニュアルページにあるように rsync は非常に高速で万能なファイルコピーの道具である。マシーン間のファイルを同期させることでよく知られているが、ローカルの場合でも同様に有用である。また、大量のファイルを削除する高速な方法としても利用できる: 1mkdir empty &amp;&amp; rsync -r --delete empty/ some-dir &amp;&amp; rmdir some-dir 実行ファイルの進捗を監視したい場合、pv、pycp、 pmonitor、progressやrsync --progressを使おう。ブロックレベルバックアップはdd status=progressだ。 ファイルからランダムな行を抜き出すにはshuf sortのオプションを理解しよう。数値に対しては-nを使い、人間にとって読みやすい形式の数値の場合(例えば、du -hの出力)は-hを使おう。キーがどのように処理されるのか(-tや-k)を知ろう。特に、最初の列だけでソートするには-k1,1と書く必要があり、-k1だと全行を見てソートされるという点に注意。 stableな(安定した)ソート(sort -s)は便利。例えば、始めに1列目でソートし、それから2列目でソートするなら、sort -k1,1 | sort -s -k2,2とすればよい。 Bashのコマンドライン上でタブを表現する必要がある場合、ctrl-v [Tab]を入力するか$&#39;\t&#39; (コピペするなら後者の方がいいかも)。 ソースコードにパッチを当てる基本のツールはdiffとpatch。diffや横並びのsdiffの統計情報を見るならdiffstatも参照しよう。diff -rだと、ディレクトリ全体に対して実行される。変更点の概要を見るならdiff -r tree1 tree2 | diffstat。vimdiffではファイルの比較と編集が可能。 バイナリファイルなら、単純な16進ダンプを見るのにhd、バイナリエディタにはbvi。 同じくバイナリファイルに関して、テキストを抽出したいならstrings(とgrepなどの組み合わせ)。 バイナリのdiff(デルタ圧縮)なら、xdelta3。 テキストエンコーディングの変換はiconvを使おう。あるいはより高度なツールとしてuconvもあり、こちらはUnicodeの高度な処理が可能。例えば以下のコマンドでは小文字に変換しアクセント記号を取り除く(展開してから削除)。 1uconv -f utf-8 -t utf-8 -x '::Any-Lower; ::Any-NFD; [:Nonspacing Mark:] &gt;; ::Any-NFC; ' &lt; input.txt &gt; output.txt ファイルを分割するならsplit(サイズで分割)とcsplit(パターンで分割)。 日時について。現在日時を取得するにはISO 8601が助けになる。date -u +&quot;%Y-%m-%dT%H:%M:%SZ&quot; を使おう。(他のオプションはこちら problematic)。日付や時間の表現を扱うには、dateutilsにあるように、dateadd、 datediff、 strptime などを使いましょう。 圧縮ファイルの操作はzless、zmore、zcat、zgrep。 chattrでファイル権限に代わる低階層のファイル属性情報をセットできる。例えば、意図しないファイル削除を防ぐフラグはこうやって立てる。sudo chattr +i /critical/directory/or/file ファイルの権限を保存、リストアするにはgetfaclとsetfaclを使おう。例は 12getfacl -R /some/path &gt; permissions.txtsetfacl --restore=permissions.txt 空ファイルを素早く作るにはtruncate(sparse fileを作成)、fallocate(ext4, xfs, btrfs とocfs2ファイルシステム)、xfs_mkfile(xfsprogs packageにあるほぼ全てのファイルシステム)、mkfile (Solaris、Mac OSといったUnix関連システム) システムのデバッグ Webのデバッグならcurlやcurl -lが便利で、wgetも同様、よりモダンなのはhttpie。 CPUやディスクのステータスを知るには、標準的なツールはtop (または、より良いhtop)、 iostat、 iotop。iostat -mxz 15を使って、基本的なCPUの情報やパーティッション単位でのディスクの詳細情報やパフォーマンスについて調べましょう。 ネットワークの状態の監視には、netstatやss。 手早くシステムで何が起きているのかを調べるには、dstatが便利。より詳しく見るには、glances。 メモリのステータスを知るには、freeあるいはvmstatを実行し、その出力の意味を理解しよう。特に、”cached”の値はLinuxカーネルにファイルキャッシュとして保持されているメモリ量であり、”free”の値を見る際に考慮すべきであることに注意しよう。 Javaのシステムのデバッグはまた違う困ったところがあるが、Oracleあるいは他のJVMにも共通しているシンプルなトリックは、kill -3 &lt;pid&gt;でフルスタックトレースとヒープの概要が標準出力あるいはログにダンプされる(世代別GCの詳細も参考程度だが含まれている)。JDKの jps、 jstat、 jstack、 jmap も便利で、SJK toolsはより高度なツールである。 改良版tracerouteとしてmtrを使ってネットワークの問題を調査しよう。 ディスクがいっぱいになっている理由を調べるには、ncduを使うとdu -sh *より時間が節約できる。 帯域を使っているのがどのソケットやプロセスなのかを見つけるには、iftopあるいはnethogsを試そう。 ab(Apacheに付属)は、Webサーバのパフォーマンスをざっくりチェックするのに便利。より複雑なテストにはsiegeを試そう。 より確実なネットワークのデバッグはwireshark、tshark、ngrep。 straceとltraceについて知っておこう。プログラムの実行に失敗したりハングしたりクラッシュしたりして、その理由が分からない、あるいはパフォーマンスに関する一般的情報を知りたいなら、このツールが役立つはずだ。プロファイリングのオプション(-c)や起動中のプロセスにアタッチする機能(-p)も覚えておこう。 共有ライブラリをチェックするならlddを覚えておこう。でも怪しいファイルを指定して実行しないように 起動中のプロセスにgdbで接続し、そのスタックトレースを取る方法を知ろう。 /proc以下のファイルを使おう。今起こっている問題をデバッグするのには素晴らしく便利だ。例えば、/proc/cpuinfo、/proc/meminfo、/proc/cmdline、/proc/xxx/cwd、/proc/xxx/ece、/proc/xxx/fd/、/proc/xxx/smaps (ここで、xxxはプロセスIDまたはPIDを意味する)。 過去に何か問題が起きたことの原因を探るなら、sarがとても便利。CPUやメモリ、ネットワークなどの過去の統計情報を見られる。 さらに深いシステムとパフォーマンスの分析には、stap (SystemTap)、perf)、sysdig。 どのOSを利用しているかをunameやuname -a (Unixカーネル情報)で確認しよう。どのディストリビューションを使っているかはlsb_release -a (ディストリビューション情報)。 何かいつもと違うおかしなこと(大抵ハードウェアかドライバ関連の問題だ)が起きていたら、dmesgを実行しよう。 duで表示されたディスクースペースがファイルを消しても空かなかった場合、そのファイルがプロセスに使われているかどうかこうやって確認しよう。lsof | grep deleted | grep &quot;filename-of-my-big-file&quot; ワンライナーコマンドをまとめて使う例をいくつか。 sortやuniqを使ってテキストファイルの共通部分、結合、差異を求める時に特に便利なのが以下のやり方。aとbはそれぞれ内容に重複のないテキストファイルとする。この方法は高速で、数GB程度までの任意のファイルサイズで動作する(/tmpが小さなルートパーティションにある場合は-Tオプションをつける必要があるが、ソートはメモリ内で行われるとは限らない)。上述のLC_ALLとsortの-uオプションも参照のこと。 123cat a b | sort | uniq &gt; c # cはaとbの和集合cat a b | sort | uniq -d &gt; c # cはaとbの共通部分cat a b b | sort | uniq -u &gt; c # cはaとbの差異 grep . *(各行にファイル名が付く)や、head -100 * (ファイル毎にヘッダーが付く)を使って手軽にディレクトリ内の全てのファイルの中身を確認できる。設定ファイルが含まれるような/sysや/procや/etc/に対して非常に便利である。 テキストファイルの3列目を全て足し合わせるには以下で(Pythonで同じことをやるに比べて3倍速く3分の1の長さで書ける)。 1awk '&#123; x += $3 &#125; END &#123; print x &#125;' myfile ファイルツリーのサイズやデータを確認したいなら、以下は再帰的なls -lと同じだがls -lRより見やすい。 1find . -type f -ls Webサーバのログのようなテキストファイルがあり、各行には例えばURLの中に出てくるacct_idのような特定の値が現れるとしよう。acct_idが何回リクエストされているかを集計するには、 1egrep -o 'acct_id=[0-9]+' access.log | cut -d= -f2 | sort | uniq -c | sort -rn 継続的に変更を監視する場合 watchを使う。例えば、ディレクトリのファイルの変更を確認するには watch -d -n 2 &#39;ls -rtlh | tail&#39; となり、wifi設定などのネットワーク設定関係のトラブルシューティングでは watch -d -n 2 ifconfig。 このドキュメントからランダムに項目を抜き出すには以下の関数を実行しよう(Markdownをパースし、アイテムを抽出する)。 1234567function taocl() &#123; curl -s https://raw.githubusercontent.com/jlevy/the-art-of-command-line/master/README.md | pandoc -f markdown -t html | xmlstarlet fo --html --dropdtd | xmlstarlet sel -t -v "(html/body/ul/li[count(p)&gt;0])[$RANDOM mod last()+1]" | xmlstarlet unesc | fmt -80&#125; 目立たないが便利なもの expr: 算術演算、論理演算、または正規表現の評価を実行 m4: シンプルなマクロプロセッサ yes: 文字列をたくさん表示 cal: いい感じのカレンダー env: コマンドを実行(スクリプト内で重宝する) printenv: 環境変数を表示する(デバッグやスクリプト内での使用に便利) look: 文字列で始まる英単語(またはファイル内の行)を見つける cut、 paste、join: データの操作 fmt: テキストの段落をフォーマットする pr: テキストをページとカラムにフォーマットする fold: テキストの行を分割 column: テキストをカラムあるいはテーブルにフォーマット expand と unexpand: タブとスペースの相互変換 nl: 行数を表示 seq: 数字を表示 bc: 計算機 factor: 整数を因数分解 gpg: ファイルの暗号化と署名 toe: terminfoのエントリのテーブルを表示 nc: ネットワークのデバッグとデータ転送 socat: ソケットリレーとTCPポートのフォワーダ(netcatと同等) slurm: ネットワークトラフィックの可視化 dd: データをファイルあるいはデバイス間で移動 file: ファイルの種類を特定 tree: ディレクトリとサブディレクトリをツリーで表示。lsに似ているが再帰的に動く stat: ファイルの情報 time: コマンドを実行して処理時間を計測 timeout: コマンドを実行し、指定時間経過後にプロセスを停止する lockfile: セマフォファイルを生成する。これはrm -fのみで削除可能。 logrotate: ログをローテート、圧縮、メール送信 watch: コマンドを繰り返し実行する。変更部分の強調表示もできる。 tac: ファイルを逆から表示 shuf: ファイルからランダムに選んだ行を表示 comm: ソート済みファイルの行を比較 pv: パイプ経由でデータの進行状況をモニタリング sponge: 書き込み前に全ての入力を読み込む。例えば、grep -v something some-file | sponge some-file のように、入力と同じファイルに書き込む際に便利。 hd、hexdump、xxd、biew、bvi: バイナリファイルのダンプと編集 strings: バイナリファイルからテキストを抽出 tr: 文字の置き換えと操作 iconv あるいは uconv: 文字エンコーディングの変換 split と csplit: ファイルを分割 units: 単位の変換と計算。2週間あたりのハロン(訳注 : 長さの単位)からまばたきごとのトゥウィップまで( /usr/share/units/definitions.unitsも参照のこと) apg: ランダムなパスワードを生成 7z: 圧縮率の高いファイル圧縮 ldd: 動的ライブラリの情報 nm: オブジェクトファイルからシンボルを表示 ab: Webサーバのベンチーマーク strace: システムコールのデバッグ mtr: ネットワークデバッグのためのより高機能なtraceroute cssh: ビジュアルな並列シェル rsync: ファイルやフォルダをSSH経由またはローカルファイルシステム内で同期 wireshark と tshark: パケットキャプチャとネットワークデバッギング ngrep: ネットワーク層のgrep host と dig: DNS名前解決 lsof:プロセスのファイルディスクリプタとソケット情報 dstat: 便利なシステム情報 glances: 高レベルに複数のサブシステムの概要を把握 iostat: ディスクの使用状況 mpstat: CPUの使用状況 vmstat: メモリの使用状況 htop: topの改良版 last: ログイン履歴 w: 誰がログインしているか id: ユーザやグループの情報 sar: システム統計情報の履歴 iftop または nethogs: ソケットあるいはプロセスごとのネットワーク使用量 ss: ソケットの統計情報 dmesg: 起動時とシステムのエラーメッセージ sysctl: Linuxカーネルパラメータの確認および設定 hdparm: SATA/ATAディスクの操作やパフォーマンス確認 lsblk: ブロックデバイスの一覧。ディスクとディスクパーティションのツリービュー lshw、lscpu、lspci、lsusb、dmidecode: CPUやBIOS、RAID、グラフィック、その他デバイスなどのハードウェア情報 lsmod、modinfo: カーネルのモジュールリストとモジュール情報 fortune、 ddate、sl: んー、あー、これは蒸気機関車やZippyの引用句が「便利」だと思うかどうかによる OS X用のものこれらはMacOS用の項目です。 パッケージ管理はbrew (Homebrew)やport (MacPorts)を使う。上記の多くのコマンドをMacOSにインストールできる。 コマンドの出力をクリップボードにコピーするpbcopyとクリップボードから出力するpbpaste。 OptionキーをaltキーとしてMac OSのターミナルで使う(上述のalt-b、alt-fなどを使う場合)には、環境設定 -&gt; 設定 -&gt; キーボード で、”メタキーとしてoptionキーを使用”を選択。 デスクトップアプリケーションでファイルを開くには、open、open -a /Applications/Whatever.app。 Spotlight: mdfindでファイルを検索し、メタデータ(画像ファイルのEXIFの情報など)をmdlsで表示。 Mac OSはBSD Unixベースであるため、多くのコマンド(例えば、ps、ls、tail、awk、sed)では、Unix System VとGNUツールの違いに影響されて、Linuxのものと比べて微妙な違いが多く含まれている。違いがあるかについては、マニュアルページのタイトルに”BSD General Commands Manual”と書かれているかどうかで判断できる。場合によっては、GNUバージョンをインストール可能である(例えば、gawkやgsedで、GNUのawkとsedに対応)。クロスプラットフォームのbashスクリプトを書く場合には、そのようなコマンドは避ける(Pythonやperlの利用を検討)か十分なテストが必要である。 Mac OSのリリース情報を取得するには、sw_vers。 Windows専用これらはWindows用の項目です。 Windows下でUnixツールを手に入れる方法 CygwinをMicrosoft WindowsでインストールしてUnixシェルの力を手にしよう。このドキュメントで説明されている大部分はびっくり箱みたいに独創的だ。 Windows10であればWindows Subsystem for Linux (WSL)を使える。Unixコマンドラインや親しみのあるBashを提供してくれる。 windows上で、主にGNUデベロッパーツール(GCCなど)を使いたい場合、MinGWやMSYSを検討しよう。bash、gawk、make、grepを提供してくれる。MSYSはCygwinと比べると全ての機能を持っているわけではない。MinGWはUnixツールのネイティブWindowsポートを作成するのに特に有効だ。 Windows配下でUnixの見た目と操作感を得るもう一つの方法はCashだ。本当に限られたUnixコマンドやコマンドラインオプションしかこの環境では利用できないので注意が必要だ。 使えるWindowsコマンドラインツール wmicを使って学ぶことで、Windowsシステム管理者タスクの大部分をコマンドラインで記述、実行することができる。 ping、ipconfig、tracert、netstatなどのWindows固有のコマンドラインも便利だと思えるはずだ。 Rundll32を実行することによって便利なWindowsタスクを利用することができる。 Cygwinの秘訣とコツ Cygwinのパッケージマネージャーで追加のUnixプログラムをインストールしよう。 minttyをコマンドラインウィンドウとして使おう /dev/clipboardでWindowsのクリップボードにアクセスしてみよう。 登録されたアプリケーションで任意のファイルを開くためにはcygstartを起動しよう。 regtoolでWindowsレジストリにアクセスしよう。 C:\WindowsドライブのパスはCygwin下では/cygdrive/cなので注意が必要だ。また、Cygwinの/はWindowsのC:\cygwinだ。cygpathを使ってCygwinスタイルとWindowsスタイルのパスを切り替えられる。これはWindowsプログラムを実行するスクリプトでとても有効だ。 さらなるリソース awesome-shell: シェルのツールやリソースのまとめ awesome-osx-command-line: より詳しいMac OSのコマンドラインガイド Strict mode: よりよいシェルスクリプトを書くために shellcheck: シェルスクリプト(本来、bash/sh/zsh用)の静的解析ツール Filenames and Pathnames in Shell: シェルスクリプトでファイル名を正しく扱うために Data Science at the Command Line: 同タイトルの書籍から引用されているデータサイエンスで役に立つコマンドやツール 免責事項ごく一部の例外はありますが、コードは誰でも読めるように書かれている。力には責任が伴う。Bashでできるからといって、そうすべき必要があるという意味ではない！ ;) ライセンス このドキュメントはCreative Commons Attribution-ShareAlike 4.0 International Liceneでライセンスされる。]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%9A%84%E8%89%BA%E6%9C%AF%2FREADME-it%2F</url>
    <content type="text"><![CDATA[🌍Čeština ∙ Deutsch ∙ Ελληνικά ∙ English ∙ Español ∙ Français ∙ Indonesia ∙ Italiano ∙ 日本語 ∙ 한국어 ∙ Português ∙ Română ∙ Русский ∙ Slovenščina ∙ Українська ∙ 简体中文 ∙ 繁體中文 The Art of Command Line (Traduzione Italiana) Meta Le Basi Uso quotidiano Processare file e dati Debug sistema One-liner Oscuri ma utili OS X Ulteriori risorse Disclaimer Saper usare con una certa facilità la linea di comando è spesso visto come una sorta di “sapere arcano”. Anche se può sembrare, in realtà non è decisamente così: può migliorare la tua produttività e la tua flessibilità in modi che neanche immagini. Questa che stai per leggere è una selezione di trucchi e di consigli che riguardano la linea di comando, che abbiamo trovato utili lavorando con Linux. Alcune di queste nozioni sono elementari, altre molto specifiche, se non sofisticate e, a volte, oscure. Non c’è da preoccuparsi, comunque: la pagina che stai scorrendo non è molto lunga e non ti ruberà molto tempo. Prenderci dimestichezza, saperla usare quando necessario, te ne renderà ancora di più. Questo lavoro è il risultato degli sforzi di svariati autori e traduttori. Una buona parte di ciò che leggi è apparsa, originariamente, su Quora. Tuttavia, visto l’interesse, mi è sembrato logico usare Github per raccogliere il tutto e creare un qualcosa a cui chiunque avrebbe potuto contribuire, anche con un piccolo suggerimento. Non abbiamo la pretesa di aver creato qualcosa di perfetto: se trovi qualche errore faccelo sapere, magari aprendo una Pull Request! MetaObiettivi: Questa guida è adatta sia a principianti che ad utenti con più conoscenze. Ci proponiamo di seguire tre principi fondamentali: ampiezza (cerchiamo di includere tutto quello che serve), specificità (dando degli esempi concreti) e brevità (evitando tutto il futile e il superfluo). Ogni consiglio viene dato con l’obiettivo di salvare del tempo prezioso. Questa guida è stata scritta per Linux, con alcune eccezioni per che abbiamo riportato nella sezione “OS X“. In ogni caso, molti dei consigli che vedrai si applicano tranquillamente ad altri sistemi operativi Unix e a MacOS. Il focus principale sarà su interactive Bash, nonostante non sia esclusivamente così. Verranno inclusi comandi “base” Unix, ma anche altri che necessiteranno di installazioni separate. Note: Per tenere tutto su una sola pagina, il contenuto è stato incluso tramite reference. Crediamo che tu sia abbastanza intelligente da cercare i dettagli su qualcosa di specifico, o su un comando, usando Google. Usa apt-get, yum, dnf, pacman, pip o brew (in base alla situazione) per installare i nuovi programmi. Se vuoi, usa Explainshell per avere uno spaccato più completo su cosa fanno comandi, pipe, opzioni e così via. Le Basi Impara le basi di Bash. Usa man bash e cerca almeno di scorrere velocemente l’intero scritto. Non è troppo lungo e neanche difficile da seguire. Altre shell possono andare bene, ma Bash è molto potente e sempre disponibile (impararne una sola tra zsh, fish e così via, per quanto ti possa tentare, ti darà problemi a lungo termine, lavorando su altre piattaforme). Impara ad usare bene almeno un editor di testo. Idealmente, potresti usare Vim (vi), con il quale non c’è praticamente competizione per questo genere di cose (sì, anche se volessi usare Emacs, oppure un altro di quei grossi IDE, o magari l’ennesimo ultimo editor ultramoderno ed hipster). Impara a leggere la documentazione usando man (per i più curiosi, man man elenca le varie sezioni. Ad esempio, 1 indica i comandi “regolari”, 5 per file/convenzioni, 8 per l’amministrazione). Trova le pagine tramite apropos. Ricorda inoltre che alcuni comandi non sono degli eseguibili, ma dei “builtin” di Bash. Usa help -d in caso di necessità. Impara tutto sul reindirizzamento dell’output e dell’input, usando &gt;, &lt; ed il pipe |. Impara anche che &gt; sovrascrive il file output, mentre &gt;&gt; aggiunge del contenuto alla fine. Impara tutto riguardo stdout e stderr. Impara anche qualcosa sul file glob, l’uso di * (e magari anche di ? e […]), oltre alla differenza tra i doppi &quot; e singoli &#39; apici. Guarda più in giù per quanto riguarda l’espansione delle variabili. Acquisisci familiarità con la gestione dei job con Bash: &amp;, ctrl-z, ctrl-c, jobs, fg, bg, kill, e così via. Impara ad usare ssh e le basi della passwordless authentication, tramite ssh-agent, ssh-add, e così via. Gestione base dei file: ls e ls -l (nello specifico, impara cosa indica ognuna delle colonne che escono fuori da ls -l), less, head, tail e tail -f (o, anche meglio, less +F), ln e ln -s (impara le differenze ed i vantaggi nell’uso di hard link o soft link), chown, chmod, du (per una panoramica veloce, usa: du -hs *). Per la gestione del filesystem, guardati df, mount, fdisk, mkfs, lsblk. Impara anche cos’è un inode (ls -i or df -i). Gestione base delle reti: ip or ifconfig, dig. Impara ad usare per bene le espressioni regolari, e le varie flag per grep/egrep. Nello specifico, varrebbe la pena anche vedersi le opzioni -i, -o, -v, -A, -B, e -C. Impara ad usare apt-get, yum, dnf o pacman (in base alla distro che usi) per trovare ed installare nuovi package. E assicurati anche di aver installato pip, in modo tale da installare agevolmente i vari tool da linea di comando basati sul linguaggio Python. Alcuni di quelli che vedrai in seguito sono più semplici da installare se usi pip. Uso quotidiano In Bash, usa Tab per completare i vari parametri dei comandi, oppure elencarli. Usa ctrl-r per effettuare una ricerca nella cronologia dei comandi inseriti (premi ctrl-r, quindi effettua la ricerca. Per vedere più risultati premi ripetutamente ctrl-r). Premi quindi Invio per eseguire il comando trovato, oppure premi su freccia destra per mettere il comando sulla linea attuale, in modo tale da poterlo modificare. In Bash, usa ctrl-w per cancellare l’ultima parola, ctrl-u per cancellare tutto fino all’inizio della riga. Usa alt-b ed alt-f per muoverti di parola in parola. ctrl-a ti permette di tornare all’inizio della riga attuale senza cancellare nulla, mentre con ctrl-e puoi spostarti direttamente alla fine. ctrl-k cancella tutto quello che c’è dal punto attualmente scelto fino alla fine della riga. Inoltre, ctrl-l pulisce lo schermo. Per vedere una lista completa di tutte le varie scorciatoie presenti (ce ne sono molte) in bash, usa man readline. Ad esempio, alt-. serve a ciclare attraverso gli argomenti precedenti. In alternativa se ti piacciono le scorciatoie in stile vi, usa set -o vi (e set -o emacs per tornare indietro se dovessi cambiare idea). Per modificare dei comandi lunghi può essere utile impostare un editor di tua scelta (esempio: export EDITOR=vim). Premendo ctrl-x ctrl-e aprirai l’attuale comando in un editor multi-line per una modifica più agevole. Oppure, se stai lavorando con uno stile vi, escape-v. Per vedere i comandi più recenti, usa history. Ci sono anche altre abbreviazioni da usare per lo stesso scopo, come !$ (per l’ultimo) e !!, nonostante questi vengano spesso rimpiazzati da ctrl-r e alt-.. Per tornare alla directory precedente: cd - Se stai digitando un comando, sei a metà e cambi idea, usa alt-# per aggiungere un # all’inizio della linea, rendendola di fatto un commento (oppure usa la sequenza ctrl-a, #, invio). Puoi quindi ritornarci dopo, tramite la cronologia. Usa xargs (o parallel). Si tratta di un tool molto potente, che ti permette di eseguire un certo comando tante volte quanti sono gli elementi restituiti da un altro comando. Quando non sei sicuro di quello che stai facendo, usa xargs echo per schiarirti le idee. Inoltre, -I{} è abbastanza utile. Ecco un esempio: 12find . -name '*.py' | xargs grep some_functioncat hosts | xargs -I&#123;&#125; ssh root@&#123;&#125; hostname pstree -p è un ottimo tool che ti mostra l’albero dei processi. Usa pgrep e pkill per trovare dei processi ed inviare loro un segnale specifico (-f è utile a riguardo). Impara a conoscere i vari segnali che puoi inviare ai processi. Ad esempio, per sospendere un processo puoi usare kill -STOP [pid]. Per una lista completa, esegui man 7 signal. Usa nohup o disown se vuoi fare in modo che un certo processo vada avanti indefinitamente. Controlla quali processi sono in ascolto tramite netstat -lntp oppure ss -plat (per TCP; aggiungere invece -u per UDP). Dai uno sguardo a lsof per un elenco di socket e file aperti. Usa uptime o w per sapere da quanto tempo il sistema è stato avviato. Usa alias per creare delle scorciatoie personalizzate. Ad esempio, puoi usare alias ll=&#39;ls -latr&#39;, che creerà un nuovo alias ll per il comando ls -latr. Negli script Bash, usa set -x (o la variante set -v, che effettua un log dell’input, includendo variabili e commenti) per un migliore debug dell’output. Comunque, cerca di usare la modalità strict a meno che tu non abbia bisogno del contrario. Una buona norma suggerisce di usare lo strict mode tranne nel caso in cui tu non possa usare set -e per annullare un comando in caso di errore (nonzero exit code). Considera anche l’uso di set -o pipefail, Puoi inoltre usare trap su EXIT o ERR. Un’abitudine piuttosto utile è quella di iniziare uno script così, facendo in modo che annulli la propria esecuzione in caso vengano rilevati degli errori. 12set -euo pipefailtrap "echo 'error: Script failed: see failed command above'" ERR Negli script Bash, le subshell (scritte tra parentesi) sono un ottimo modo di raggruppare dei comandi. Un esempio piuttosto comune è il muoversi temporaneamente verso una directory differente, per poi tornare a lavorare in quella attuale. 123# faccio qualcosa nella directory attuale(cd /some/other/dir &amp;&amp; other-command)# continuo nella directory attuale In Bash esistono svariati tipi di espansione di variabile. Come controllare se una variabile esiste: ${name:?error message}. Ad esempio, se uno script richiede un singolo parametro, scrivi input_file=${1:?usage: $0 input_file}. Espansione aritmetica: i=$(( (i + 1) % 5 )). Sequenze: {1..10}. Trim di stringhe: ${var%suffix} and ${var#prefix}. Ad esempio, se var=foo.pdf, allora echo ${var%.pdf}.txt restituisce foo.txt. Usare la brace expansion tramite {…} può essere molto comodo in caso di necessità di automazione di alcuni task simili. Un esempio è mv foo.{txt,pdf} some-dir (che con un solo comando muoverà due file, il pdf ed il txt), cp somefile{,.bak} (che si espande a cp somefile somefile.bak) o mkdir -p test-{a,b,c}/subtest-{1,2,3} (che espande tutte le possibili combinazioni, creando un albero di directory). L’output di un comando può essere trattato come un file tramite &lt;(some command). Ad esempio, per comparare il file /etc/hosts locale con uno in remoto: 1diff /etc/hosts &lt;(ssh somehost cat /etc/hosts) Impara qualcosa sugli “here documents” in Bash, come cat &lt;&lt;EOF .... In bash, redireziona gli errori standard (input ed output) usando: some-command &gt;logfile 2&gt;&amp;1 oppure some-command &amp;&gt;logfile. Spesso, per assicurarti che un certo comando non lasci un handle aperto “legandoti al terminale attuale” potrebbe essere una buona idea aggiungere &lt;/dev/null. Usa man ascii per ottenere una buona tabella ASCII, con valori decimali ed esadecimali. Per altre informazioni generali sulle codifiche, usa man unicode, man utf-8, e man latin1. Usa screen o tmux per effettuare il multiplex della schermata, cosa particolarmente utile in caso di sessioni ssh in remoto, ad esempio. byobu può inoltre migliorare screen e tmux, fornendo più informazioni e una gestione semplificata. Un’altra alternativa, minimalista, per la persistenza di sessione è dtach. In ssh, sapere come effettuare il port tunneling con -L o -D (ed occasionalmente -R) è molto utile, ad esempio per accedere a siti web da un server remoto. Può essere utile effettuare alcune ottimizzazioni alla configurazione ssh; ad esempio, questo file ~/.ssh/config contiene delle impostazioni utili ad evitare connessioni interrotte in specifiche reti ed ambienti, fa uso di compressione (utile in caso di connessioni lente), e multiplexing dei canali verso lo stesso server con un control file locale: 1234567TCPKeepAlive=yesServerAliveInterval=15ServerAliveCountMax=6Compression=yesControlMaster autoControlPath /tmp/%r@%h:%pControlPersist yes Altre opzioni sempre interessanti riguardo ssh sono sensibili in termini di sicurezza e dovrebbero essere gestite con cura: alcuni esempi sono StrictHostKeyChecking=no e ForwardAgent=yes; Considera l’uso di mosh, un’alternativa ad ssh che usa UDP, in modo tale da evitare connessioni interrotte. Per ottenere i permessi relativi ad un certo file in forma ottale, utile alla configurazione ma non disponibile in ls usa qualcosa come 1stat -c '%A %a %n' /etc/timezone Per una selezione interattiva di valori dall’output di un altro comando, valuta l’uso di percol o fzf. Per interagire con dei file in base all’output di un certo comando (come git), usa fpp (PathPicker). Se vuoi creare al volo un webserver semplice, per i file nella directory attuale (sottocartelle incluse), disponibile a tutti sulla tua rete, usa:python -m SimpleHTTPServer 7777 (per la porta 7777 e Python 2) e python -m http.server 7777 (per la porta 7777 e Python 3). Per eseguire un comando con i privilegi di un altro utente, usa sudo (per l’utente root) o sudo -u (per un altro utente). Usa su o sudo bash per eseguire la shell come tale utente. Usa su - per simulare un nuovo login con un altro utente. Processare file e dati Per trovare un file partendo dal suo nome nella directory attuale, usa find . -iname &#39;*qualcosa*&#39;. Per trovare un file in generale nel sistema, usa locate qualcosa (ma tieni a mente che updatedb potrebbe non ancora aver messo nell’indice i file creati da poco). Per una ricerca più generale, all’interno di codice sorgente o file di dati (o comunque qualcosa di più avanzato di grep -r), usa ag. Per converire del codice HTML in un testo: lynx -dump -stdin Per Markdown, HTML ed ogni tipo di conversione di documenti, prova pandoc. Se devi lavorare con l’XML ricorda: xmlstarlet è old but gold. Per il JSON, usa jq. Per YAML, usa shyaml. Per Excel o file CSV, csvkit fornisce in2csv, csvcut, csvjoin, csvgrep e così via. Per Amazon S3, s3cmd è un ottimo tool e s4cmd è invece molto più veloce. Amazon aws e la sua versione migliorata, saws sono qualcosa di fondamentale per ogni tipo di task legato ad AWS. Impara di più riguardo sort ed uniq, incluso -u e -d di uniq. Guardati anche comm. Impara a conoscere meglio anche cut, paste e join per manipolare file di testo. Molte persone spesso usano cut ma si scordano dell’esistenza di join. Impara ad usare wc per contare i ritorni a capo (-l), caratteri (-m), parole (-w) e byte (-c). Impara qualcosa di più riguardo tee per copiare da stdin ad un file ed anche verso stdout. Esempio: ls -al | tee file.txt. Ricorda che le impostazioni riguardo la localizzazione influiscono un sacco su alcuni tool da linea di comando, in molti modi. Ad esempio sugli ordinamenti (collation) e performance. Molte installazioni Linux impostano LANG ed altre variabili correlate automaticamente su US English (inglese americano). Se decidi di cambiare lingua, non è detto quindi che le cose rimangano così come sono. Alcuni comandi, addirittura, potrebbero diventare immediatamente molto più lenti. Impara le basi di awk e sed per manipolare dati. Ad esempio, per sommare tutti i numeri nella terza colonna di un file di testo, usa awk &#39;{ x += $3 } END { print x }&#39;. Probabilmente tre volte più veloce e tre volte più corto del suo equivalente in Python. Per rimpiazzare tutte le occorrenze di una stringa, in uno o più file: 1perl -pi.bak -e 's/old-string/new-string/g' my-files-*.txt Per rinominare dei file in massa e per effettuare cerca/sostituisci al loro interno, prova anche repren. (In alcuni casi il comando rename permette operazioni multiple, ma fai attenzione al risultato visto che la funzionalità non è sempre identica sulle varie distro; 123456# Full rename of filenames, directories, and contents foo -&gt; bar:repren --full --preserve-case --from foo --to bar .# Recover backup files whatever.bak -&gt; whatever:repren --renames --from '(.*)\.bak' --to '\1' *.bak# Same as above, using rename, if available:rename 's/\.bak$//' *.bak Come la pagina del manuale spiega, rsync è un ottimo tool per copiare file, versatile e velocissimo. Si, è conosciuto per sincronizzare file da una macchina all’altra, ma è ugualmente utile se viene usato localmente. Viene anche riconosciuto come uno dei modi più veloci di cancellare un grande numero di file tutti insieme: 1mkdir empty &amp;&amp; rsync -r --delete empty/ some-dir &amp;&amp; rmdir some-dir Usa shuf per selezionare una serie di linee da un file, in ordine casuale. Impara a conoscere le opzioni di sort. Per i numeri, usa -n, oppure -h per gestire numeri leggibili dal’uomo (du -h). Impara a capire come funzionano le varie chiavi (-t e -k). In particolare, fai attenzione a quando scrivi -k1,1 per ordinare solo per il valore del primo campo, visto che -k1 significa ordinare secondo l’intera riga. Lo stable sort (sort -s) può esserti utile. Immagina ad esempio di voler ordinare secondo il valore del secondo campo, e secondariamente del primo. Userai sort -k1,1 | sort -s -k2,2. Se dovessi aver bisogno di scrivere, letteralmente, un tab in Bash, premi ctrl-v [Tab] o scrivi $&#39;\t&#39;. I tool standard per il patching del codice sono diff e patch. Guarda anche Guarda anche diffstat per saperne di più su una diff e sdiff per una side-by-side diff. Nota bene che diff -r lavora con intere directory. Usa diff -r tree1 tree2 | diffstat per una panoramica dei cambiamenti. Usa vimdiff per comparare e modificare file. Per file binari, usa hd, hexdump o xxd per semplici hex dump, e bvi o biew per editing binario. Inoltre, sempre per file binari, usa strings (insieme grep, e così via) per trovare sezioni di testo al loro interno; Per diff binarie (delta compression), usa xdelta3. Per convertire un testo da una codifica ad un’altra, prova iconv. Oppure uconv in caso di necessità più avanzate; supporta svariate opzioni avanzate inerenti Unicode. Ad esempio, questo comando rimuove tutti gli accenti e trasforma le stringhe in lettere tutte minuscole: 1uconv -f utf-8 -t utf-8 -x '::Any-Lower; ::Any-NFD; [:Nonspacing Mark:] &gt;; ::Any-NFC; ' &lt; input.txt &gt; output.txt Per dividere un file in altri file più piccoli, guarda split (per dividere in base alla dimensione) e csplit (per dividere in base ad un pattern). Se devi manipolare date ed orari, usa dateadd, datediff, strptime e così via, di dateutils. Usa zless, zmore, zcat e zgrep per lavorare su file compressi. Debug sistema Per il web debugging, curl e curl -I sono decisamente utili. La stessa cosa vale anche per l’equivalente wget, o ancora per il più recente httpie. Per avere più informazioni sullo stato attuale del sistema, dalla cpu ai dischi, il tool classico più usato è top (o la sua versione migliorata htop), iostat e iotop. Usa iostat -mxz 15 per avere informazioni base sulla CPU ed informazioni dettagliate, per partizione, sui dischi e sulle loro performance. Per avere più dettagli sulle connessioni di rete, usa netstat e ss. Per una panoramica veloce di cosa sta succedendo nel sistema, dstat è ottimo. Per avere invece molte più informazioni e scendere nel dettaglio, usa glances. Per saperne di più sullo stato della memoria, esegui ed impara a capire il significato dei comandi free e vmstat. In particolare, sii consapevole del fatto che la memoria “cached” è quella mantenuta dal kernel Linux come file cache, che a tutti gli effetti poi conta come memoria libera. Il system debugging con Java è tutta un’altra cosa. Uno dei trucchi più semplici sulla JVM Oracle (ed anche altre) è che all’esecuzione di kill -3 &lt;pid&gt; verrà messo in log un trace full stack (inclusi molti dettagli sulla garbage collection). Anche jps, jstat, jstack e jmap del JDK sono molto utili. Ci sono poi i vari SJK tools, più avanzati. Usa mtr per rilevare problemi di rete. Molto meglio di traceroute. Per capire perché un disco viene visto pieno, ncdu ti evita perdite di tempo rispetto al più comune du -sh *. Per capire quale socket o processo sta usando troppa banda prova iftop o nethogs. ab (incluso in Apache) è ottimo per un test di carico veloce di un webserver. Per test di carico più avanzati, prova anche siege. Per un debug di rete più avanzato, dai uno sguardo a wireshark, tshark o ngrep. Impara qualcosa di più su strace e ltrace. Possono essere molto utili quando un programma crasha, o magari rimane in blocco e tu non capisci perché. Degne di nota le opzioni di profiling (-c), e la possibilità di agganciare un processo in esecuzione (-p). Impara qualcosa di più riguardo ldd per controllare le librerie condivise. Impara a connetterti ad un processo in esecuzione con gdb e recuperare il suo stack trace. Usa /proc. Fantastico quando devi fare un live debug in caso di problemi. Esempi: /proc/cpuinfo, /proc/meminfo, /proc/cmdline, /proc/xxx/cwd, /proc/xxx/exe, /proc/xxx/fd/, /proc/xxx/smaps (dove xxx è il nome del processo o il suo pid). Quando vuoi debuggare qualcosa che è andato storto in passato, sar può essere molto utile. Permette di controllare uno storico delle statistiche di CPU, memoria, rete e così via. Usa stap per un’analisi più approfondita del sistema in termini di performance (SystemTap), perf), e sysdig. Controlla quale OS stai usando con uname oppure uname -a (informazioni generali sul kernel) o lsb_release -a (informazioni sulla distro Linux). Usa dmesg quando il sistema si comporta in modo davvero strano (problemi hardware o legati ai driver, insomma). One-linerQualche esempio di combinazione di più comandi comandi: Decisamente è utile è sapere che puoi effettuare intersesione, unione e differenza di file di testo tramite sort/uniq. Immagina di avere a e b, due file di testo. Il metodo in questione è veloce e tra l’altro supporta anche file di svariati gigabyte. Guarda anche la nota riguardo LC_ALL e l’opzione -u di sort. 123cat a b | sort | uniq &gt; c # c is a union bcat a b | sort | uniq -d &gt; c # c is a intersect bcat a b b | sort | uniq -u &gt; c # c is set difference a - b Usa grep . * per esaminare velocemente i contenuti di tutti i file in una certa directory (in modo che ogni linea venga abbinata al nome del file), oppure head -100 *. Può essere molto utile per quelle directory piene file di configurazione, come /sys, /proc, /etc. Sommare tutti i numeri sulla terza colonna di un file di testo (probabilmente 3 volte più veloce e corto della controparte in Python): 1awk '&#123; x += $3 &#125; END &#123; print x &#125;' myfile Nel caso in cui tu voglia vedere dimensioni e date per un certo “albero” di file (un po’ come ls -l, ma ricorsivo): 1find . -type f -ls Immagina di avere un file di testo, come un log di un server, like a web server log, ed un certo valore appare di tanto in tanto tra le righe, come ad esempio un parametro acct_id in un URL.. Ecco come contare le richieste effettuate che contengono tale parametro acct_id: 1cat access.log | egrep -o 'acct_id=[0-9]+' | cut -d= -f2 | sort | uniq -c | sort -rn Per monitorare costantemente i cambiamenti ai file, usa watch. Ad esempio, per controllare i cambiamneti in una certa directory usa watch -d -n 2 &#39;ls -rtlh | tail&#39; oppure, se stai monitorando un file di configurazione inerente il WiFi, watch -d -n 2 ifconfig. Esegui questa funzione per ottenere un consiglio a caso da questo documento: 1234567function taocl() &#123; curl -s https://raw.githubusercontent.com/jlevy/the-art-of-command-line/master/README.md | pandoc -f markdown -t html | xmlstarlet fo --html --dropdtd | xmlstarlet sel -t -v "(html/body/ul/li[count(p)&gt;0])[$RANDOM mod last()+1]" | xmlstarlet unesc | fmt -80&#125; Oscuri ma utili expr: esegue operazioni aritmetiche o booleane, oltre a valutare espressioni regolari. m4: un semplice macro processor. yes: stampa una stringa per un numero indefinito di volte. cal: un calendario. env: esegue un comando (utile negli script). printenv: stampa le variabili di ambiente (utile per il debug e negli script). look: trova parole inglesi (o linee in un file) partendo da una stringa. cut, paste e join: manipolazione di dati. fmt: formatta paragrafi di testo. pr: formatta del testo in pagine/colonne. fold: sistema delle linee di testo. column: formatta del testo in colonne o tabelle dalla larghezza fissa. expand ed unexpand: converte spazi in tab, e viceversa. nl: aggiunge il conteggio delle righe. seq: stampa dei numeri. bc: calcolatrice. factor: scompone un numero in fattori. gpg: cripta e firma i file. toe: tabella di tutti i terminali disponbili. nc: per il network debugging e trasferimento dati. socat: socket relay e tcp port forwarder (simile a netcat). slurm: visualizzazione del traffico di rete. dd: spostamento dati tra file e dispositivi. file: identifica il tipo di un certo file. tree: mostra le sottodirectory con una struttura ad albero. A differenza di ls, è ricorsivo. stat: informazioni su un file. time: esegue un comando e tiene traccia del tempo di esecuzione. timeout: avvia un comando definendo anche un certo ammontare di tempo oltre il quale non si può andare. Se tale ammontare di tempo viene raggiunto, il comando viene annullato. lockfile: crea un file che può essere rimosso solo tramite rm -f. logrotate: gestie i log, la loro rotazione, compressione ed invio via mail. watch: esegue un comando più volte, mostrando i risultati ed evidenziando le differenze tra tali risultati. tac: stampa un file al contrario. shuf: sceglie casualmente delle righe da un file. comm: compara dei file ordinati riga per riga. pv: monitora i progressi dei dati attraverso un pipe. hd, hexdump, xxd, biew e bvi: dump o modifica di file binari. strings: estrae del testo da file binari. tr: manipolazione e trasformazione dei caratteri. iconv o uconv: conversione di testi in altre codifiche. split e csplit: divisione di un file in altri file più piccoli. sponge: legge tutto l’input prima di riscriverlo, utile in caso di lettura e scrittura sullo stesso file. Ad esempio: grep -v something some-file | sponge some-file. units: conversione da e verso altre unità di misura (guarda anche /usr/share/units/definitions.units). apg: genera password casuali. 7z: compressione di file ad alta ratio. ldd: informazioni su una libreria dinamica. nm: elenca i vari simboli presenti un object file. ab: benchmark di webserver. strace: debug delle chiamate di sistema. mtr: un traceroute migliore per il debug di rete. cssh: shell visuale concorrente. rsync: sincronizza file e cartelle tramite SSH oppure in locale. wireshark e tshark: packet capturing e debug di rete. ngrep: come grep… ma per il traffico di rete. host e dig: DNS lookup. lsof: descrittore dei processi ed informazioni su socket. dstat: statistiche di sistema. glances: overview di sistemi multipli ad alto livello. iostat: statistiche sull’uso dei dischi. mpstat: statistiche sull’uso della CPU. vmstat: statistiche sull’uso della memoria. htop: versione migliorata di top. last: cronologia dei login. w: mostra chi è autenticato. id: user/group identity info. sar: cronologia di alcune statistiche del sistema. iftop o nethogs: uso della rete da parte di socket e processi. ss: statistiche sui socket. dmesg: messaggi di errore di avvio e di sistema in generale. sysctl: visualizza e configura i parametri del kernel a run time. hdparm: tool di gestione dischi SATA/ATA. lsblk: visualizzazione ad albero dei dischi e relative partizioni. lshw, lscpu, lspci, lsusb, dmidecode: informazioni sull’hardware, tra cui CPU, BIOS, RAID, scheda grafica e dispositivi di ogni tipo. lsmod e modinfo: elenco e dettaglio dei vari moduli del kernel. fortune, ddate, e sl: mmmh, beh, dipende molto da quanto consideri le locomotive a vapore e le citazioni di Zippy “utili”. OS XConsiera questa sezione come un’esclusiva MacOS. I package vengono gestiti con brew (Homebrew) e/o port (MacPorts). Possono essere usati su MacOS per installare molti dei comandi visti in questo articolo. Copia l’output di un qualsiasi comando tramite pbcopy ed incollalo, invece, con pbpaste. Per abilitare l’Option key sul terminale Mac OS come un’alt key (per riprodurre comandi quali alt-b, alt-f, e così via), apri Preferenze -&gt; Profili -&gt; Tastiera e scegli “Usa Option come meta key”. Per aprire un file con un’applicazione desktop, usa open oppure open -a /Applications/LaTuaApplicazione.app. Cerca i file con mdfind ed elenca i vari metadati (come gli EXIF per le foto) con mdls. Sii consapevole del fatto che MacOS è basato su BSD Unix, e molti dei suoi comandi (ad esempio ps, ls, tail, awk, sed) presentano alcune variazioni rispetto alla loro controparte Linux. Per controllare tali differenze devi vedere se la pagina del manuale ha come titolo “BSD General Commands Manual”. Come logica conseguenza, quindi, ricorda di non usare tali comandi se hai intenzione di scrivere degli script cross-platform. Per avere più informazioni sulla tua release di MacOS, usa sw_vers. Ulteriori risorse awesome-shell: Una curatissima lista di tool e risorse awesome-osx-command-line: Una guida approfondita sulla linea di comando in Mac OSX Strict mode per scrivere script migliori shellcheck: Un tool di analisi per script shell. Praticamente lint per bash/sh/zsh. Filenames and Pathnames in Shell: Un compendio sul come gestire nomi dei file e path nella shell DisclaimerCon l’eccezione di pochi piccoli task, il codice è stato scritto per permettere agli altri di leggerlo agevolmente. Da grandi poteri derivano grandi responsabilità. Ricorda: il fatto che tu possa fare qualcosa in Bash non implica comunque che tu debba per forza! ;) License A questo lavoro è attribuita la Creative Commons Attribution-ShareAlike 4.0 International License.]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%9A%84%E8%89%BA%E6%9C%AF%2FREADME-id%2F</url>
    <content type="text"><![CDATA[🌍Čeština ∙ Deutsch ∙ Ελληνικά ∙ English ∙ Español ∙ Français ∙ Indonesia ∙ Italiano ∙ 日本語 ∙ 한국어 ∙ Português ∙ Română ∙ Русский ∙ Slovenščina ∙ Українська ∙ 简体中文 ∙ 繁體中文 Seni dalam Baris Perintah Meta Dasar-dasar Penggunaan sehari-hari Mengolah berkas dan data Analisa Sistem Perintah satu baris Tidak penting tapi bermanfaat Khusus OS X Khusus Windows Bacaan lebih lanjut Penyangkalan Mahir dalam baris perintah merupakan keahlian yang sering diabaikan atau masih dianggap misteri, tapi hal tersebut dapat meningkatkan fleksibilitas dan produktivitas sebagai seorang teknisi secara jelas. Halaman ini merupakan kumpulan catatan dan tips dalam menggunakan baris perintah sebagaimana yang kita ketahui sangat berguna ketika bekerja pada sistem Linux. Beberapa merupakan tips dasar, dan beberapa cukup spesifik, terkini, atau yang jarang digunakan. Halaman ini tidak panjang, tetapi jika anda dapat menggunakan dan mengingat semua perintah yang ada pada halaman ini, berarti anda memiliki pengetahuan yang cukup luas. Proyek ini merupakan hasil dari banyak penulis dan penerjemah.Beberapa diantaranya pertama kalimunculdi Quora,namun kemudian dialihkan ke GitHub, dimana banyak orang-orang yang lebih berbakat dari penulis awal telah membuat banyak penyempurnaan.Silakan ajukan pertanyaan jika anda memiliki pertanyaan seputar perintah baris. Silakan berkontribusi jika anda melihat ada kesalahan atau memiliki suatu ide yang lebih baik! MetaBatasan masalah: Panduan ini ditujukan bagi pemula dan yang telah berpengalaman. Tujuan utamanya cukup luas (segala hal adalah penting), spesifik (memberikan contoh kongkrit dari kasus yang umum terjadi), dan ringkas (hindari hal yang tidak penting atau menyimpang yang dapat ditemukan). Setiap tip adalah penting dalam beberapa kondisi atau dapat menjadi pilihan alternatif. Ditulis untuk Linux, dengan pengecualian dari bagian “Khusus OS X“ and “Khusus Windows“. Banyak yang menggunakan atau memasangnya dalam varian UNIX atau OS X lainnya (bahkan menggunakan Cygwin). Berfokus pada Bash interaktif, meskipun banyak tip yang dapat digunakan pada terminal lainnya dan skrip Bash secara umum. Mengandung perintah UNIX “standar” sebagaimana yang telah diketahui bahwa membutuhkan instalasi paket spesial – selama dirasa cukup penting untuk diikut sertakan. Catatan: Untuk menjaga tetap memungkinkan dalam satu halaman, materi tidak disertakan dengan referensi secara langsung. Anda cukup paham untuk mengetahui lebih detil mengenai penjelasan setiap perintah, misalnya menggunakan Google. Gunakan apt-get, yum, dnf, pacman, pip atau brew (seperlunya) untuk memasang program baru. Gunakan Explainshell untuk bantuan mengenai perintah, opsi, saluran, dan lain sebagainya. Dasar-dasar Pelajari dasar Bash. Sebenarnya dengan mengetikkan man bash anda bisa mengetahui semuanya; sangat mudah untuk dilakukan dan cukup singkat. Sebagai alternatif terminal dapat menjadi menyenangkan, tapi Bash lebih baik dan selalu tersedia (hanya mempelajari only zsh, fish, etc., ketika menggunakan laptop pribadi anda, membatasi anda dalam banyak situasi, seperti menggunakan server yang sudah ada). Pelajari setidaknya satu pengolah teks dengan baik. Secara ideal Vim (vi), yang mana merupakan pengolah teks berbasis terminal terbaik saat ini (meskipun anda menggunakan Emacs, sebuah IDE yang besar, atau pengolah teks modern yang unik sepanjang masa). Ketahui cara membaca dokumentasi dengan man (sebagai informasi tambahan, man man menampilkan daftar bagian dalam bentuk nomor, misalnya 1 adalah perintah-perintah “reguler”, 5 adalah berkas-berkas atau aturan-aturan, dan 8 adalah untuk administrasi). Temukan halaman man dengan apropos. Ketahui bahwa beberapa perintah tidak dapat dijalankan secara langsung, kecuali bawaan dari Bash, dan anda dapat mencari bantuan mengenai hal tersebut dengan help dan help -d. Anda dapat mencari tahu apakah suatu perintah dapat dijalankan langsung, perintah bawaan atau sebuah alias dapat diketahui dengan type perintah. Pelajari tentang pengalihan hasil keluaran dan masukan menggunakan &gt; dan &lt; dan saluran menggunakan |. Ketahui bahwa &gt; menimpa hasil keluaran dari sebuah berkas sedangkan &gt;&gt; menambahkan keluaran dibagian akhir dari berkas. Pelajari tentang stdout dan stderr. Pelajari tentang penyebaran berkas dengan * (dan mungkin ? dan […]) dan tanda petik dan perbedaan antara petik dua &quot; dan petik sati &#39;. (Penjelasan lebih lanjut pada penyebaran variabel dibawah.) Biasakan diri dengan pengelolaan tugas pada Bash: &amp;, ctrl-z, ctrl-c, jobs, fg, bg, kill, dan lain sebagainya. Ketahui tentang ssh, dan dasar autentikasi tanpa kata kunci, melalui ssh-agent, ssh-add, dan lain sebagainya. Dasar pengelolaan berkas: ls dan ls -l (pelajari juga maksud setiap kolom pada ls -l), less, head, tail dan tail -f (atau yang lebih baik, less +F), ln dan ln -s (pelajari perbedaan dan keuntungan menggunakan hard dan soft link), chown, chmod, du (untuk penjelasan singkat penggunaan disk: du -hs *). Untuk pengelolaan berkas sistem, df, mount, fdisk, mkfs, lsblk. Pelajari apa itu inode (ls -i atau df -i). Dasar pengelolaan jaringan: ip atau ifconfig, dig. Pelejari dan gunakan sistem pengelolaan kontrol versi, seperti git. Ketahui regular expression (regex) dengan baik, dan beberapa flags untuk grep/egrep. Flag -i, -o, -v, -A, -B, dan -C bermanfaat untuk dipelajari. Pelajari cara menggunakan apt-get, yum, dnf atau pacman (tergantung distro yang digunakan) untuk melakukan instalasi paket. Dan pastikan anda mempunyai pip untuk menginstall alat baris perintah berbasis Python (dibawah ini beberapa lebih mudah diinstall menggunakan pip). Penggunaan sehari-hari Dalam Bash, gunakan Tab untuk melengkapi secara otomatis suatu perintah atau daftar perintah yang tersedia dan ctrl-r untuk mencari riwayat perintah (setelah ditekan, ketikan kata kunci yang ingin dicari, tekan ctrl-r untuk berpindah antara perintah-perintah yang sesuai, tekan Enter untuk menjalankan perintah, atau menekan tanda panah kanan di keyboard). Dalam Bash, gunakan ctrl-w untuk untuk menghapus kata terakhir, dan ctrl-u untuk menghapus semua kata mulai dari baris pertama. Gunakan alt-b dan alt-f untuk memindahkan kata, ctrl-a untuk memindahkan kursor kebaris paling depan, ctrl-e untuk memindahkan kursor kebaris paling akhir, ctrl-k untuk menghentikan bagian akhir dari baris, ctrl-l untuk membersihkan layar tampilan. Lihat man readline untuk menampilkan semua kombinasi tombol yang ada dalam Bash. Ada cukup bnyak kombinasi. Contohnya alt-. berpindah melalui perintah sebelumnya, dan alt-* melebarkan glob. Sebagai alternatif, jika anda lebih sendang menggunakan gaya kombinasi vi, gunakan set -o vi (dan set -o emacs untuk mengembalikan kepengaturan awal). Untuk mengelola perintah yang panjang, setelah melakukan pengaturan pengolah teks (sebagai contoh export EDITOR=vim), menekan kombinasi ctrl-x ctrl-e akan membuka perintah saat ini pada pengolah teks untuk melakukan pengelolaah secara langsung. Atau dalam gaya vi, escape-v. Untuk melihat perintah terakhir yang digunakan, history. Tambahkan !n dibagian akhir (dimana n merupakan jumlah perintah) untuk dijalankan kembali. Terdapat beberapa penyingkatan yang dapat digunakan, diantaranya yang paling sering digunakan !$ untuk parameter terakhir dan !! untuk perintah terakhir (baca “HISTORY EXPANSION” pada halaman manual man). Bagaimanapun, sering digantikan dengan kombinasi ctrl-r dan alt-.. Pindah ke direktori home dengan cd. Akses berkas yang berada dibawah direktori home dengan awalan ~ (misalnya ~/.bashrc). Dalam skrip sh direktori home dinyatakan dalam $HOME. Untuk kembali ke direktori sebelumnya: cd -. Jika dalam menulis perintah anda berubah fikiran, tekan alt-# untuk menambahkan # pada awal perintah untuk menjadikannya sebuah komentar (atau ctrl-a, #, enter). Selanjutnya anda dapat mengakses perintah tersebuh dikemudian dengan menggunakan history. Gunakan xargs (atau parallel). Sangat bagus. Anda dapat mengontrol berapa banyak item yang dapat dijalankan per-baris (-L) atau menjalankannya secara bersamaan (-P). Jika anda tidak yakin hal tersebut akan berjalan dengan baik, gunakan xargs echo terlebih dahulu. Atau I{} juga sangat bermanfaat. Contohnya: 12find . -name '*.py' | xargs grep some_functioncat hosts | xargs -I&#123;&#125; ssh root@&#123;&#125; hostname pstree -p dapat membantu menampilkan daftar proses yang sedang berjalan. Gunakan pgrep dan pkill untuk mencari proses sinyal berdasarkan nama (-f juga cukup membantu). Pelajari jenis sinyal yang dapat dikirimkan ke proses. Contoh, untuk menunda sebuah proses, gunakan kill -STOP [pid]. Untuk daftar semua sinyal, lihat man 7 signal. Gunakan nohup atau disown untuk membuat proses tetap berjalan selamanya. Lihat kemana sebuah proses terhubung (listening) melalui netstat -lntp atau ss -plat (untuk TCP, gunakan -u untuk UDP). Lihat juga lsoft untuk membuka socket dan berkas. Lihat uptime atau w untuk mengetahui berapa sistem sudah berjalan (aktif). Gunakan alias untuk membuat jalan pintas untuk perintah-perintah yang sering digunakan. Misalnya, alias ll=&#39;ls -latr&#39; akan menghasilkan alias ll. Menyimpan alias, pengaturan shell, dan fungsi yang sering digunakan di ~/.bashrc, dan atur shell untuk dibaca ketika login. Hal tersebut akan membuat pengaturan dapat berjalan disemua sesi. Letakkan pengaturan dari variabel sebagai perintah yang akan dijalankan ketika login di ~/.bash_profile. Pisahkan konfigurasi yang dibutuhkan untuk menjalankan grafik login dan tugas-tugas cron. Singkronkan berkas konfigurasi (seperti .bashrc dan .bash_profile) pada banyak komputer dengan Git. Pahami bahwa dibutuhkan perhatian lebih ketika variabel dan nama berkas mengandung spasi. Batasi variabel Bash dengan tanda petik, misalnya &quot;$FOO&quot;. Sebaiknya gunakan opsi -0 atau -print0 untuk membuat karakter null dalam membatasi nama berkas, misalnya locate -0 pattern | xargs -0 ls -al atau find / -print0 -type d | xargs -0 ls -al. Untuk membuat perulangan nama berkas yang mengandung spasi dalam for, atur IFS sebagai baris baru dengan IFS=$&#39;\n&#39; . Dalam skrip Bash, gunakan set -x (atau lainnya set -v, yang mana akan menamilkan raw masukan dalam log, termasuk variabel dan komentar) untuk keperluan debugging. Gunakan mode strict kecuali ada alasan lebih baik untuk tidak menggunakan set -e untuk membatalkan perintah ketika terjadi kesalahan (kode exit tidak 0). Gunakan set -u untuk mendeteksi variabel yang belum ditentukan tapi sudah digunakan. Pertimbangkan set -o pipefail juga, untuk kesalahan didalam saluran. Untuk skrip terkait, gunakan trap pada EXIT atau ERR. Disarankan untuk memulai dari skrip berikut, dimana akan mendeteksi dan membatalkan perintah ketika terjadi kesalahan tertentu kemudian menampilkannya dalam pesan: 12set -euo pipefailtrap "echo 'Kesalahan: Skrip gagal: harap periksa kembali perintah yang anda masukkan'" ERR Dalam skrip Bash, bagian dalam shell (ditulis didalam tanda kurung) merupakan cara terbaik untuk menggabungkan perintah. Sebuah contoh yang sering digunakan adalah berpindah ke direktori kerja yang lain, contohnya: 123# melakukan sesuatu dalam direktori kerja saat ini(cd /direktori/kerja/lainnya &amp;&amp; suatu-perintah)# melanjutkan pekerjaan dalam direktori yang sebenarnya Dalam Bash, ada banyak jenis dari pengembangan variabel. Memeriksa ketersediaan variabel: $(nama_variabel:?pesan kesalahan). Sebagai contoh, jika skrip membutuhkan sebuah parameter, cukup menulis berkas_masukan=$(1:?penggunaan: $0 berkas_masukan). Contoh dalam aritmatika: i=$(( (i + 1) % 5 )). Urutan: {1..10}. Pemangkasan string: ${var%akhiran} dan ${var#awalan}. Sebagai contoh jika var=foo.pdf, maka echo ${var%.pdf}.txt akan menghasilkan foo.txt. Kurung kurawal {…} dapat mengurangi kesalahan dama mengetik teks yang sama dan membuat kombinasi dari banyak item secara otomatis. Ini sangat membantu misalnya dalam perintah mv foo.{txt,pdf} suatu-direktori (memindahkan kedua berkas sekaligus), cp suatuberkas{,.bak} (memiliki makna sama dengan cp suatuberkas suatuberkas.bak) atau mkdir -p test-{a,b,c}/subtest-{1,2,3} (memiliki makna membuat semua kemungkinan kombinasi untuk struktur direktori). Keluaran dari perintah dapat diperlakukan sebagai sebuah berkas dengan &lt;(suatu perintah). Misalnya, membandingkan /etc/hosts yang ada pada lokal dengan server: 1diff /etc/hosts &lt;(ssh suatuserver cat /etc/hosts) Ketika menulis skrip disarankan untuk membatasi semua kode dalam kurung kurawal. Jika penutuh kurung kurawal tidak ditemukan, skrip tidak dapat dijalankan karena terjadi kesalahan. Hal ini biasanya terjadi ketika mengunduh skrip dari web, kemungkinan beberapa bagian dari skrip yang telah diunduh sengaja ditulis untuk menghindari eksekusi: 123&#123; # Kode disini&#125; Ketahui tentang “here documents” dalam Bash dengan cat &lt;&lt;EOF.... Dalam Bash, arahkan keluaran standar dan kesalahan melalui: suatu-perintah &gt; berkaslog 2&gt;&amp;1 atau suatu-perintah &amp;&gt;berkaslog. Biasanya, untuk memastikan suatu perintah tidak meninggalkan berkas tetap terbuka setelah menerima masukan, coba pada terminal anda saat ini, merupakan hal baik untuk menambahkan &lt;/dev/null. Gunakan man ascii untuk melihan tabel ASCII, dengan nilai hex dan decimal. Untuk informasi umum mengenai unicode, man unicode, man utf-8, dan man latin1 juga sangat berguna. Gunakan screen atau tmux untuk tampilan multi layar, terutama sangat bermanfaat dalam sesi ssh, melepas dan menyambung kembali sebuah sesi. byobu Use screen or tmux to multiplex the screen, especially useful on remote ssh sessions and to detach and re-attach to a session. byobu can enhance screen or tmux providing more information and easier management. A more minimal alternative for session persistence only is dtach. Dalam ssh, mengetahui bagaimana cara menggunaakn saluran (port tunnel) dengan -L atau -D (dan terkadang -R) juga berguna. Misalnya untuk mengakses situs web dari kendali server jarak jauh. Akan sangat bermanfaat untuk melakukan optimisasi pada konfigurasi ssh; misalnya, ~/.ssh/config mengandung pengaturan untuk menghindari putusnya koneksi antar jaringan, menggunakan kompresi (bermanfaat bagi yang memiliki bandwidth rendah), dan terhubung dengan banyak saluran pada suatu server dengan kontrol lokal: 1234567TCPKeepAlive=yesServerAliveInterval=15ServerAliveCountMax=6Compression=yesControlMaster autoControlPath /tmp/%r@%h:%pControlPersist yes Beberapa opsi lain untuk SSH terkait sensitifitas keamanan dan sebaiknya diaktifkan dengan hati-hati, misalnya pada subnet atau host atau pada jaringan yang terpercaya: StrictHostKeyChecking=no, ForwardAgent=yes Pertimbangkan mosh sebagai alternatif untuk SSH yang mana menggunakan UDP, dapat menjaga terputusnya koneksi dan lebih nyaman untuk digunakan (perlu konfigurasi disisi server). Untuk mendapatkan hak akses pada sebuah berkas, yang mana berguna untuk konfigurasi sistem tapi tidak tersedia pada ls, gunakan perintah perikut 1stat -c '%A %a %n' /etc/timezone Untuk memilih nilai keluaran dari perintah lain secara interaktif, gunakan percol or fzf. For interaction with files based on the output of another command (like git), use fpp (PathPicker). For a simple web server for all files in the current directory (and subdirs), available to anyone on your network, use:python -m SimpleHTTPServer 7777 (for port 7777 and Python 2) and python -m http.server 7777 (for port 7777 and Python 3). For running a command with privileges, use sudo (for root) or sudo -u (for another user). Use su or sudo bash to actually run a shell as that user. Use su - to simulate a fresh login as root or another user. Untuk berganti ke pengguna Shell lain, gunakan su username atau su - username. Sertakan - untuk mendapatkan lingkungan jika pengguna telah login. Hindari menggunakan username menjadi root. Anda akan dimintai password untuk pengguna yang ingin diganti. Ketahui batasan 128k pada sebuah perintah. Kesalahan “Argument list too long” sering terjadi ketika karakter (wildcard) mewakili berkas yang sangat banyak. (Saat ini terjadi dapat menggunakan find dan xargs sebagai bantuan.) Untuk sebuah perhitungan dasar (secara umum akses Python), gunakan interpreter python. Contohnya, 12&gt;&gt;&gt; 2+35 Mengolah berkas dan data Untuk menemukan berkas berdasarkan nama dalam direktori saat ini, find . -iname &#39;*sesuatu*&#39; (atau yang mirip). Untuk mencari berkas dibanyak tempat berdasarkan nama, gunakan locate sesuatu (tapi ingat updatedb mungkin belum menyimpan berkas terbaru yang dibuat). Untuk pencarian umum berdasarkan isi berkas (lebih dalam dibandingkan dengan grep -r), gunakan ag. Untuk mengkonversi HTML menjadi teks: lynx -dump -stdin Untuk Markdown, HTML, dan semua jenis konversi dokumen, coba pandoc. Jika anda mengelola XML, xmlstarlet adalah pilihan yang paling tua namun terbaik. Untuk JSON, gunakan jq. Untuk YAML, gunakan shyaml. Untuk Excel atau berkas CSV, csvkit menyediakan in2csv, csvcut, csvjoin, csvgrep, dan lain sebagainya. Untuk Amazon S3, s3cmd lebih nyaman digunakan dan s4cmd lebih cepat. Amazon aws dan yang telah dikembangkan saws tetap penting untuk pekerjaan yang berhubungan dengan AWS lainnya. Ketahui tentang sort dan uniq, termasuk opsi -u dan -d – lihat Perintah satu baris dibawah. Lihat juga comm. Ketahui tentang cut, paste, dan join dalam memanipulasi teks pada berkas. Banyak orang menggunakan cut tapi melupakan tentang join. Ketahui tentang wc untuk menghitung jumlah baris (-l), karakter (-m), kata (-w) dan byte (-c). Ketahui tentang tee untuk menyalin dari stdin sebuah berkas ke stdout, seperti dalam ls -al | tee file.txt. Untuk kalkulasi yang cukup kompleks, termasuk pengelompokan, konversi nilai, dan statistik, pertimbangkan untuk menggunakan datamash. Ketahui bahwa locale cukup berdampak pada banyak perintah, termasuk pengurutan (pemeriksaan) dan dan kinerja. Kebanyakan distribusi Linux akan menggunakan LANG atau variabel locale lainnya untuk melakukan pengaturan bahasa seperti ID Indonesia. Tapi waspada karena pengurutan akan berubah jika locale juga telah dirubah. Dan ketahui aktifitas i18n dapat membuat banyak perintah seringkali menjadi lambat. Dalam kondisi tertentu (seperti beberapa perintah operasi dibawah) anda dapat menghindari i18n dan menggunakan pengurutan tradisional, gunakan export LC_ALL=C. Anda dapat menentukan perintah tertentu dengan memberikan awalan saat pemanggilan dengan variabel pengaturan, seperti TZ=Pacific/Fiji date. Ketahui mengenai dasar awk dan sed untuk manipulasi data. Sebagai contoh, menjumlahkan semua nomor yang ada pada kolom ketiga dari sebuah berkas: awk &#39;{ x += $3 } END { print x }&#39;. Ini memungkinkan komputasi 3x lebih cepat dan 3x lebih singkat dibandingkan dengan persamaan Python. Untuk mengganti semua string yang cocok, dalam satu atau lebih dari satu berkas: 1perl -pi.bak -e 's/string-lama/string-baru/g' my-files-*.txt Untuk mengganti nama banyak berkas atau mencari dan/atau mengganti dalam berkas, coba repren. (Dalam beberapa kasus perintah rename memungkinkan untuk mengganti banyak nama sekaligus, namun perlu berhati-hati karena fungsionalitas mungkin tidak akan sama pada distribusi Linux lainnya.) 123456# Mengganti nama berkas, direktori, dan isi berkas secara penuh dari foo --&gt; bar:repren --full --preserve-case --from foo --to bar .# Mengembalikan backup berkas whatever.bak -&gt; whatever:repren --renames --from '(.*)\.bak' --to '\1' *.bak# Sama seperti diatas, menggunakan rename, jika ada yang cocok:rename 's/\.bak$//' *.bak Sesuai dengan yang ada pada halaman manual, rsync adalah perintah untuk menyalin berkas yang cukup cepat dan memiliki banyak fitur. Mampu melakukan singkronisasi antar host yang mana sangat berguna untuk host lokal. Jika keamanan tidak diutamakan, gunakan rsync daripada scp untuk pemulihan tanpa harus mengulang dari awal. Perintah tersebut merupakan cara tercepat untuk menghapus banyak berkas sekaligus: 1mkdir empty &amp;&amp; rsync -r --delete empty/ some-dir &amp;&amp; rmdir some-dir Gunakan shuf untuk mengacak atau memilih baris secara acak dalam sebuah berkas. Ketahui perintah sort. Untuk angka, funakan opsi -n, atau -h untuk menampilkan angka yang mudah dibaca manusia (contoh du -h). Ketahui bagaimana cara kerja kunci (-t dan -k). Terkadang membutuhkan k1,1 untuk mengurutkan kolom pertama saja; k1 berarti mengurutkan semua barus. Pengurutan yang stabil (sort -s) juga cukup berguna. FContoh, untuk mengurutkan yang pertama berdasarkan kolom 2, yang kedua berdasarkan kolom 1, akan menjadi soft -k1,1 | sort -s -k2m2. Jika perlu untuk membuat tab pada terminal dalam Bash (misalnya argumen -t untuk mengurutkan), tekan ctrl-v [Tab] atau dengan menulis $&#39;\t&#39; (menulis langsung lebih baik dari copy/paste). Alat yang umum digunakan untuk menambal sumber kode adalah diff dan patch. Lihat juga diffstat untuk hasil berupa statistik dari diff dan sdiff. Ingat bahwa diff -r berlaku pada semua direktori. Gunakan diff -r tree1 tree2 | diffstat untuk ringkasan perubahan. Gunakan vimdiff untuk membandingkan dan memperbarui berkas. Untuk berkas binari, gunakan hd, hexdump atau xxd untuk menampilkan kode hex yang sederhana dan bvi atau blew untuk memperbarui berkas biner. Alat lainnya untuk berkas biner, strings (dikombinasikan dengan grep, dan lainnya) memungkinkan pencarian teks berdasarkan bit-bit. Untuk membandingkan berkas biner (kompresi delta), gunakan xdelta3. Untuk mengkonversi sandi penulisan teks, coba iconv. Atau uconv untuk penggunaan lebih lanjut; telah mendukung hal yang berkaitan dengan Unicode. Sebagai contoh, perintah berikut membuat tulisan kecil dan menghapus semua aksen (dengan mengembangkan atau menghapusnya). 1uconv -f utf-8 -t utf-8 -x '::Any-Lower; ::Any-NFD; [:Nonspacing Mark:] &gt;; ::Any-NFC; ' &lt; input.txt &gt; output.txt Untuk memecah berkas menjadi beberapa bagian, lihat split (memisahkan berdasarkan ukuran) dan csplit (memisahkan berdasarkan pola). Untuk memanipulasi tanggal dan waktu, gunakan dateadd, datediff, strptime etc. dari dateutils. Gunakan zless, zmore, zcat, dan zgrep untuk digunakan pada berkas yang terkompres. Atribut dari sebuah berkas dapat diset melalui chattr dan disediakan alternatif untuk level terendah pada hak akses berkas. Sebagai contoh, untuk melindungi ketidak sengajaan pada penghapusan berkas gunakan flag kebal: sudo chattr +i /direktori/berkas/penting Gunakan getfacl dan setfacl untuk menyimpan dan mengembalikan hak akses pada suatu berkas. Contohnya: 12getfacl -R /suatu/path &gt; hakakses.txtsetfacl --restore=hakakses.txt Analisa sistem Untuk analisa web, curl dan curl -I cukup berguna, atau yang sama lainnya seperti wget, atau yang lebih modern httpie. Untuk mengetahui status CPU/penyimpanan, perintah klasik top (lebih baik lagi htop), iostat, dan iotop. Gunakan iostat -mxz 15 untuk melihat detil CPU tiap bagian (partition) penyimpanan dan pengetahuan tentang kinerja. Untuk detail koneksi jaringan, gunakan netstat dan ss. Untuk melihat sekilas yang terjadi pada sistem, dstat cukup berguna. Untuk detil secara menyeluruh, gunakan glances. Untuk status memory, jalankan dan perhatikan keluaran dari free dan vmstat. Dalam kondisi tertentu, hati-hati terhadap “cached” yang dihasilkann oleh kernel Linux, jadi perhatikan sebaik mungkin keluaran dari free. Analisa sistem Java sedikit berbeda, tapi ada trik sederhana untuk JVM dari Oracle dan yang lainnya yakni dapat dijalankan perintah kill -3 &lt;pid&gt; dan penelusuran (full stack trace) dan beberapa ringkasan utama (termasuk informasi pembangkitan sampah sistem, informasi yang sangat berguna) akan dikeluarkan melalui stderr/logs. JDK seperti jps, jstat, jstack,jmap` cukup berguna. Perlengkapan SJK untuk penggunaan lebih lanjut. Gunakan mtr sebagai pilihan terbaik traceroute, untuk menelusuri masalah jaringan. Untuk mengungkapkan kenapa penyimpanan penuh, perintah ncdu lebih menghemat waktu dibangdingkan du -sh *. Untuk mencari socket atau process yang sedang menggunakan bandwidth, coba iftop atau nethogs. Perintah ab (paket dari Apache) sangat berguna untuk melihat kinerja dari server web. Untuk test lebih lanjut, gunakan siege. Untuk analisa jaringan yang lebih serius, wireshark, tshark, atau ngrep. Ketahui tentang strace dan ltrace. Perintah tersebut membantu ketika sebuah program gagal, hang, atau crash secara tiba-tiba, atau jika ingin mengetahui kinerja aplikasi secara umum. Catatan gunakan opsi profiling (-c), dan kemampuan untuk menertakan proses yang sedang berjalan (-p). Ketahui tentang ldd untuk memeriksa pustaka berbagi dan sebagainya. Ketahui bagaimana cara terhubung dengan proses yang sedang berjalan dengan gdb dan periksa alur stack-nya. Gunakan /proc untuk melakukan analisis permasalahan secara live. Contohnya: /proc/cpuinfo, /proc/meminfo, /proc/cmdline, /proc/xxx/cwd, /proc/xxx/exe, /proc/xxx/fd/, /proc/xxx/smaps (dimana xxx adalah ID proses id atau pid). Untuk mengetahui kesalahan yang terjadi pada proses analisa sebelumnya, gunakan sar. Perintah tersebut dapat menampilkan riwayat statistik pada CPU, memory, jaringan, dan lain sebagainya. Untuk analisa kinerja sistem lebih mendalam, periksa stap (SystemTap), perf), dan sysdig. Periksa Sistem Operasi yang digunakan dengan uname atau uname -a (Unix/kernel pada umumnya) atau lsb_release -a (distro linux). Gunakan dmesg ketika terjadi sesuatu yang tidak disangka (mungkin masalah perangkat kerasa atau driver). Jika anda menghapus sebuah berkas dan tidak dapat meningkatkan kapasitas media penyimpanan sebagaimana hasil pengecekan du, periksa kemungkinan berkas tersebut sedang digunakan oleh suatu proses:lsof | grep deleted | grep &quot;berkas-yang-sangat-besar&quot; Perintah satu barisBeberapa contoh untuk menggabungkan perintah sekaligus: Terkadang cukup membantu ketika ingin mencari kesamaan, kesatuan, dan perbedaan dari beberapa berkas melalui sort/uniq. Misalkan a dan b adalah berkas yang berbeda. Perintah ini cukup cepat, dan dapat bekerja pada berkas dengan ukuran sampai gigabyte. (Pengurutan tidak dibatasi oleh memory, tapi diperlukan opsi -T jika /tmp berada dalam partisi root yang kecil.) Lihat juga catatan tentang LC_ALL diatas dan opsi yang terdapat pada sort (penjelasan lebih jelas dibawah berikut). 123cat a b | sort | uniq &gt; c # c berisi kesatuan antara a dan bcat a b | sort | uniq -d &gt; c # c berisi persamaan antara a dan bcat a b b | sort | uniq -u &gt; c # c berisi perbedaan antara a dan b Gunakan grep . * untuk menguji isi dari semua berkas dalam sebuah direktori (hasil tiap berisnya berkaitan dengan nama berkas), atau head -180 * (setiap berkas memiliki informasi kepala). Hal ini sangat bermanfaat untuk direktori yang berisi berkas konfigurasi seperti /sys, /proc, /etc. Untuk menjumlahkan semua nomor pada kolom ketiga dari sebuah berkas (memungkinkan proses 3x lebih cepat dan skrip 3x lebih pendek dari Python): 1awk '&#123; x += $3 &#125; END &#123; print x &#125;' suatuberkas Untuk melihat ukuran atau tanggal berkas dalam bentuk struktur pohon, mirip dengan rekursif ls -l namun lebih mudah untuk dibaca dari ls -lR: 1find . -type f -ls Ketika terdapat sebuah berkas teks seperti log web server, dan nilai tertentu muncul pada beberapa baris, misalnya parameter acct_id yang terdapat pada URL. Jika ingin mengetahui berapa banyak akses acct_id: 1cat access.log | egrep -o 'acct_id=[0-9]+' | cut -d= -f2 | sort | uniq -c | sort -rn Untuk memantau perubahan secara terus menerus, gunakan watch, misalnya perubahan berkas pada sebuah direktori, gunakan watch -d -n 2 &#39;ls -rtlh | tail atau pada pengaturan jaringan wifi ketika melakukan perbaikan dengan watch -d -n 2 ifconfig. Jalankan fungsi berikut untuk mendapatkan sesuatu yang acak dari dokumen ini (mengolah Markdown dan mengeluarkan sebuah item): 1234567function taocl() &#123; curl -s https://raw.githubusercontent.com/jlevy/the-art-of-command-line/master/README.md | pandoc -f markdown -t html | xmlstarlet fo --html --dropdtd | xmlstarlet sel -t -v "(html/body/ul/li[count(p)&gt;0])[$RANDOM mod last()+1]" | xmlstarlet unesc | fmt -80&#125; Tidak penting tapi bermanfaat expr : melakukan perhitungan aritmatika atau mengevaluasi regular expression (regex) m4 : pemroses macro yang sederhana yes : menampilkan cukup banyak string cal : menampilkan kalender env : menjalankan sebuah perintah (berguna dalam skrip) printenv : menampilkan variabel environment (berguna dalam analisa dan skrip) look : mencari kata dalam bahasa English (atau baris dalam sebuah berkas) diawali dengan sebuah string cut, paste dan join: manipulasi data fmt: teks dengan format paragraf pr: teks dengan format halaman/kolom fold: membatasi baris dari teks column: membuat format teks jadi rata, lebar kolom tertentu atau bentuk tabel expand dan unexpand: konversi antara tab dan spasi nl: menambahkan baris baru seq: menampilkan angka bc: kalkulator factor: angka faktorial gpg: mengenkripsi dan menandatangani berkas toe: isi dari tabel terminfo nc: analisa jaringan dan aktifitas datanya socat: jalur tunda dan penerus jalur tcp (mirip dengan netcat) slurm: visualisasi aktifitas jaringan dd: memindahkan data antar berkas atau perangkat file: identifikasi jenis dari berkas tree: menampilkan struktur pohon dari direktori dan subdirektori secara bersarang; mirip ls namun dapat rekursif stat: informasi berkas time: menjadwalkan dan menjalankan sebuah perintah timeout: menjalankan sebuah perintah dalam waktu yang telah ditentukan dan melanjutkan kembali dalam waktu yang telah ditentukan pula. lockfile: membuat berkas dengan tanda hanya dapat dihapus oleh rm -f logrotate: menggulirkan, mengkompres serta mengirimkan via email berkas logs watch: menjalankan program secara berulang, menampilkan hasil dan/atau memfokuskan pada perubahan tac: menmapilkan kebalikan dari berkas shuf: memilih baris secara acak dari sebuah berkas comm: membandingkan berkas yang terurut berdasarkan baris pv: memantau perkembangan data yang melalui sebuah saluran hd, hexdump, xxd, biew dan bvi: menampilkan atau memperbaiki berkas dalam biner strings: mengeluarkan teks dari berkas biner tr: konversi atau menipulasi sebuah karakter iconv atau uconv: konversi kode teks split dan csplit: membagi berkas sponge: membaca semua masukan sebelum menuliskannya, berguna untuk membaca dan menulis pada berkas yang sama, misalnya grep -v sesuatu nama-berkas | sponge nama-berkas units: konversi dan kalkulasi unit; mengkonversi jarak mil per dua minggu (lihat juga /usr/share/units/definitions.units) apg: membangkitkan kata kunci acak xz: kompresi berkas dengan rasio yang tinggi ldd: informasi dynamic library nm: simbil dari objek berkas ab: patokan untuk web server strace: analisa sistem pemanggilan mtr: traceroute yang lebih baik untuk analisa jaringan cssh: visual shell dalam jumlah banyak secara bersamaan rsync: singkronisasi berkas dan direktori melalui SSH atau berkas sistem dalam satu mesin wireshark dan tshark: penangkap paket dan analisa jaringan ngrep: grep untuk jaringan host dan dig: pencarian DNS lsof: deskripsi berkas process dan informasi socket dstat: berguna untuk statistik sistem glances: tingkat tinggi, informasi singkat banyak subsistem iostat: statistik penggunaan penyimpanan mpstat: statistik penggunaan CPU vmstat: statistik penggunaan memory htop: versi terbaru dari top last: riwayat login w: melihat siapa yang sedang login id: informasi identitas pengguna atau grup sar: riwayat statistik sistem iftop or nethogs: penggunaan jaringan berdasarkan socket atau process ss: statistik socket dmesg: pesan ketika boot dan sistem error sysctl: melihat dan mengkonfigurasi parameter kernel Linux saat sedang berjalan hdparm: manipulasi atau melihat kinerja media SATA/ATA lsblk: daftar blok perangkat: berbentuk struktur pohon yang berisi media penyimpanan beserta partisinya lshw, lscpu, lspci, lsusb, dmidecode: informasi perangkat keras, termasuk CPU, BIOS, RAID, grafis, dan lain sebagainya. lsmod and modinfo: menampilkan daftar dan detil modul kernel fortune, ddate, dan sl: tergantung bagaimana anda menyebutnya “bermanfaat” Khusus OS XBerikut ini hanya berlaku pada OS X. Manajemen paket menggunakan brew (homebrew) dan/atau port (MacPorts). Dapat digunakan untuk memasang banyak aplikasi OS X untuk menggunakan perintah-perintah diatas. Salin keluaran dari perintah ke aplikasi desktop menggunakan pbcopy dan tempel menggunakan pbpaste. Untuk mengaktifkan tombol Option pada aplikasi Terminal OS X sebagai tombol alt (seperti menggunakan perintah diatas alt-b, alt-f, dan lain sebagainya), buka Preferences -&gt; Profiles -&gt; Keyboard dan pilih “Use Option as Meta key”. Untuk membuka berkas pada aplikasi desktop, gunakan open atau open -a /Applications/namaaplikasi.app. Spotlight: Mencari berkas dengan mdfind dan menampilkan metadata (seperti info EXIF foto) dengan mdls. Berhati-hati karena OS X berbasis pada BSD Unix, dan banyak perintah (seperti ps, ls, tail, awk, sed) beberapa memiliki varian yang berbeda dengan Linux, yang mana akan berdampak besar pada System V-style Unix dan peralatan GNU lainnya. Perbedaannya dapat diketahui dengan mencari pada halaman manual “BSD General Command Manual”. Pada beberapa kasus versi GNU dapat dipasang juga (seperti gawk dan gsed untuk GNU awk dan sed). Ketika menulis skrip Bash lintas platform, hundari beberapa perintah (seperti mempertimbangkan Python atau perl) atau coba kembali dengan hati-hati. Untuk mendapatkan informasi rilis OS X, gunakan sw_vers. Hanya WindowsBerikut ini hanya berlaku pada Windows. Pada Windows 10, anda dapat menggunakan Bash di Ubuntu pada Windows, dimana menyediakan lingkungan Bash yang mirip dengan perintah baris pada lingkungan Unix. Sebagai tambahan, memungkinkan program Linux untuk berjalan pada Windows. Namun disisi lain tidak memungkinkan untuk menjalankan aplikasi windows melalui jendela Bash. Akses fasilitas dari Shell Unix pada Microsoft Windows dengan memasang Cygwin. Banyak hal telah dijelaskan pada dokumen ini akan bekerja secara normal. Pasang program Unix tambahan dengan paket manajer Cygwin. Gunakan mintty sebagai aplikasi perintah baris. Akses clipboard pada Windows pada /dev/clipboard. Gunakan cygstart untuk membuka berkas melalui aplikasi yang telah terdaftar. Akses registry pada Windows dengan regtool. Ingat bahwa C:\ Windows akan menjadi /cygdrive/c pada Cygwin, dan / pada Cygwin akan berada di C:\cygwin pada Windows. Konversi antara Cygwin dan gaya Windows file path dengan cygpath. Hal ini berguna dalam skrip yang menjalankan program Windows. Anda dapat menjalankan skrip sistem administrasi pada Windows dari perintah baris dengan mempelajari dan menggunakan wmic. Pilihan lainnya untuk membuat mendapatkan Unix pada Windows adalah Cash. Sebagai catatan bahwa hanya tersedia beberapa fasilitas perintah baris Unix yang tersedia dalam lingkungan ini. Sebagai pilihan alternatif untuk mendapatkan alat pengembangan dalam GNU (seperti GCC) pada Windows adalah MinGW dan paketnya MSYS, dimana menyediakan beberapa fasilitas seperti bash, gawk, make dan grep. MSYS tidak sepenuhnya memiliki semua fasilitas jika dibandingkan dengan Cygwin. Cygwin biasanya berguna untuk membuat port Windows dari Unix. Bacaan lebih lanjut awesome-shell: Daftar alat dan sumber Shell lainnya. awesome-osx-command-line: Penjelasan lebih dalam perintah baris pada OS X. Strict mode untuk menulis skrip Shell yang lebih baik. shellcheck: Analisis Shell skrip. Pada dasarnya, lint untuk bash/sh/zsh. Filenames and Pathnames in Shell: Cara menangani nama berkas yang baik dan benar pada skrip Shell. Data Science at the Command Line: Perintah dan alat yang berguna untuk mengolah data sains, dari buku dengan nama yang sama. PenyangkalanDengan pengecualian dari tugas yang sangat kecil, kode ditulis sehingga orang lain dapat membacanya. Dengan kekuatan datang tanggung jawab. Bahkan Anda dapat melakukan sesuatu di Bash tidak berarti Anda harus! ;)Dengan beberapa pengecualian, sebuah kode ditulis sehingga orang lain dapat membacanya. Dengan adanya kekuatan datang pula tanggung jawab. Faktanya anda dapat melakukan hal yang tidak seharusnya dalam Bash! ;) Lisensi Hasil kerja ini memiliki lisensi dibatah Creative Commons Attribution-ShareAlike 4.0 International License.]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%9A%84%E8%89%BA%E6%9C%AF%2FREADME-fr%2F</url>
    <content type="text"><![CDATA[🌍Čeština ∙ Deutsch ∙ Ελληνικά ∙ English ∙ Español ∙ Français ∙ Indonesia ∙ Italiano ∙ 日本語 ∙ 한국어 ∙ Português ∙ Română ∙ Русский ∙ Slovenščina ∙ Українська ∙ 简体中文 ∙ 繁體中文 L’art de la ligne de commande Méta Notions de base Utilisation quotidienne Traitement des fichiers et des données Débogage du système Unilignes Obscures mais utiles Uniquement macOS Uniquement Windows Autres ressources Avertissement La maîtrise de la ligne de commande est une compétence souvent négligée ou considérée ésotérique, pourtant elle améliore de façon évidente et subtile votre habilité et votre productivité en tant qu’ingénieur.Ceci est une sélection de notes et d’astuces sur l’utilisation de la ligne de commande que nous avons trouvées utiles en travaillant avec Linux.Certaines sont élémentaires, d’autres sont assez spécifiques, complexes ou obscures.Cette page n’est pas bien longue, mais si vous pouvez retenir et vous servir de tout ce qui s’y trouve, alors vous saurez beaucoup de choses. Ce document est le fruit du travail de nombreux auteurs et traducteurs.Une partie de celui-ci a été initialement publiée sur Quora, mais il se trouve maintenant sur GitHub, où des personnes plus compétentes que l’auteur originel ont apporté de nombreuses améliorations.N’hésitez pas à poser des questions sur la ligne de commande.Merci de contribuer si vous voyez une erreur ou quelque chose qui pourrait être amélioré ! MétaContexte : Ce guide est destiné aux débutants et aux utilisateurs chevronnés.Les objectifs sont l’envergure (tout est important), la spécificité (donner des exemples concrets des cas les plus courants) et la concision (éviter tout ce qui n’est pas essentiel et les digressions disponibles facilement ailleurs).Chaque astuce est indispensable dans certaines situations ou fait gagner beaucoup de temps par rapport aux solutions alternatives. Il est écrit pour Linux, à l’exception des sections « Uniquement macOS » et « Uniquement Windows ».Beaucoup d’items s’appliquent ou peuvent être installés sur d’autres Unices ou macOS (ou même Cygwin). L’accent est mis sur l’utilisation intéractive de Bash, bien que de nombreuses astuces s’appliquent aux autres shells et à l’écriture de scripts en Bash. Il inclut les commandes « standard » d’Unix aussi bien que celles qui nécessitent l’installation de paquets spéciaux &mdash; tant qu’ils sont suffisamment importants pour mériter d’être mentionnés. Remarques : Afin que le guide tienne sur une seule page, du contenu est implicitement inclus par référence.Vous êtes suffisamment intelligents pour rechercher des renseignements ailleurs une fois que vous avez l’idée ou la commande à googler.Utilisez apt, yum, dnf, pacman, pip ou brew (selon votre distribution ou OS) pour installer de nouveaux programmes. Allez sur Explainshell pour obtenir de l’aide à propos des commandes, options, tubes, etc. Notions de base Apprenez les bases de Bash.En fait, tapez man bash et parcourez toute la page&#8239;; elle est relativement facile à suivre et pas si longue.Les shells alternatifs peuvent être intéressants, mais Bash est puissant et disponible partout (apprendre seulement zsh, fish, etc., bien que cela soit tentant sur votre ordinateur portable, vous limite dans bien des situations, comme par exemple lors de l’utilisation de vrais serveurs). Apprenez à bien utiliser au moins un éditeur en mode texte.L’éditeur nano est l’un des plus simples pour de l’édition simple (ouvrir, modifier, sauvegarder, rechercher).Cependant pour un usage avancé dans un terminal, rien ne remplace le vénérable Vim (vi), éditeur difficile à prendre en main, mais rapide et très complet.De nombreuses personnes utilisent également le classique Emacs, surtout pour d’importantes tâches d’édition (bien sûr, tout développeur moderne de logiciels travaillant sur un vaste projet n’utilise probablement pas un simple éditeur en mode texte et devrait donc aussi se familiariser avec des outils et des EDI graphiques modernes). Sachez comment lire une documentation avec man (pour les curieux, man man liste les sections avec leur numéro, par exemple 1 pour les commandes «&nbsp;normales&nbsp;» , 5 pour les formats des fichiers et les conventions, et 8 pour tout ce qui concerne l’administration système).Trouvez les pages de manuel avec apropos.Sachez que certaines commandes ne sont pas des exécutables, mais des commandes internes de Bash et que vous pouvez obtenir de l’aide à leur sujet avec help et help -d.Utilisez type command pour déterminer si une commande est un exécutable, une commande interne du shell ou un alias. Apprenez à rediriger les entrées et sorties au moyen de &gt; et &lt;, et à créer des tubes avec |.Sachez que &gt; écrase le fichier de sortie et &gt;&gt; sert à ajouter.Renseignez-vous sur stdout et stderr. Apprenez au sujet de l’expansion des noms de fichiers avec * (et peut-être ? et […]), des mécanismes de citation, et de la différence entre les guillemets &quot; et les apostrophes &#39; (voir ci-dessous). Familiarisez-vous avec la gestion des processus avec Bash&nbsp;: &amp;, ctrl-z, ctrl-c, jobs, fg, bg, kill, etc. Apprenez ssh et les principes de l’authentification sans mot de passe à l’aide de ssh-agent, ssh-add, etc. Les bases de la gestion des fichiers&nbsp;: ls et ls -l (en particulier, apprenez la signification de chacune des colonnes de ls -l), less, head, tail et tail -f (ou mieux, less +F), ln et ln -s (apprenez les différences et les avantages des liens durs par rapport aux liens symboliques), chown, chmod, du (pour un rapide résumé de l’espace disque occupé&nbsp;: du -hs *).Pour la gestion du système de fichiers&nbsp;: df, mount, fdisk, mkfs, lsblk.Apprenez ce qu’est un inode (ls -i ou df -i). Les bases de l’administration réseau&nbsp;: ip, ifconfig, dig, traceroute et route. Apprenez à vous servir d’un logiciel de gestion de versions tel que git, et utilisez-le. Apprenez les expressions régulières et les différents drapeaux de grep et egrep.Les options -i, -o, -v, -A, -B et -C sont bonnes à connaître. Apprenez à utiliser apt-get, yum, dnf ou pacman (selon la distribution) pour trouver et installer des paquets.Assurez-vous d’avoir pip pour installer des outils en ligne de commande écrits en Python (quelques-uns ci-dessous sont plus faciles à installer avec pip). Utilisation quotidienne En Bash, utilisez Tab pour compléter les arguments ou lister toutes les commandes disponibles, et ctrl-r pour rechercher dans l’historique des commandes (tapez pour rechercher, appuyez sur ctrl-r plusieurs fois pour parcourir les différentes correspondances, appuyez sur Enter pour exécuter la commande trouvée ou sur la flèche droite pour l’éditer). En Bash, utilisez ctrl-w pour effacer le mot précédent et ctrl-u pour effacer tout ce qui précède le curseur.Utilisez alt-b et alt-f pour se déplacer mot par mot, ctrl-a pour déplacer le curseur au début de la ligne, ctrl-e pour déplacer le curseur à la fin de la ligne, ctrl-k pour effacer depuis le curseur jusqu’à la fin de la ligne, ctrl-l pour effacer l’écran.Voir man readline pour la liste des raccourcis clavier par défault de Bash.Il y en a beaucoup.Par exemple alt-. fait défiler les arguments précédents et alt-* développe un glob. Sinon, si vous adorez les combinaisons de touches dans le style vi, utilisez set -o vi (set -o emacs pour revenir en arrière). Pour éditer de longues commandes, après avoir configuré votre éditeur (par exemple export EDITOR=vim), ctrl-x ctrl-e (escape-v dans le style vi) ouvre l’éditeur pour éditer la commande courante. Consultez les commandes récentes avec history.Faites !n pour rappeler la commande numéro n.Il y a aussi beaucoup d’autres abréviations, les plus utiles étant probalement !$ pour le dernier argument et !! pour la dernière commande (voir la section « HISTORY EXPANSION » de la page de manuel).Cependant, celles-ci peuvent être aisément remplacées par ctrl-r et alt-.. Placez-vous dans votre répertoire personnel avec cd.Accédez aux fichiers à partir de leurs chemins relatifs par rapport à votre répertoire personnel en préfixant ceux-ci avec ~ (p.&nbsp;ex. ~/.bashrc).Dans les scripts shell, désignez le répertoire personnel par $HOME. Pour revenir au répertoire de travail précédent&nbsp;: cd -. Si vous êtes au milieu de la saisie d’une commande mais que vous changez d’avis, tapez alt-# pour ajouter # au début de la ligne et l’entrer comme un commentaire (ou utilisez ctrl-a, #, enter).Vous pouvez alors y revenir plus tard à l’aide de la commande history. Utilisez xargs (ou parallel).C’est très puissant.Remarquez que vous pouvez contrôler le nombre d’items à exécuter par ligne (-L) ainsi que la parallélisation (-P).Si vous n’êtes pas sûr d’avoir fait ce qu’il faut, utilisez d’abord xargs echo.L’option -I{} est également pratique.Exemples&nbsp;: 12find . -name '*.py' | xargs grep some_functioncat hosts | xargs -I&#123;&#125; ssh root@&#123;&#125; hostname pstree -p fournit un affichage utile des processus sous la forme d’un arbre. pgrep et pkill pour rechercher ou envoyer un signal à des processus en fonction de leur nom (-f est utile). Connaissez les différents signaux que vous pouvez envoyer aux processus.Par exemple, pour suspendre l’exécution d’un processus, utilisez kill -STOP [pid].Pour la liste complète, consultez man 7 signal. Utilisez nohup ou disown pour qu’un processus en arrière-plan reste actif indéfiniment. Vérifiez quels sont les processus qui écoutent à l’aide de netstat -lntp, ss -plat (pour TCP; ajoutez -u pour UDP) ou lsof -iTCP -sTCP:LISTEN -P -n (qui fonctionne aussi sur macOS). Voyez également lsof et fuser pour la liste des sockets et fichiers ouverts. Voyez uptime ou w pour savoir depuis combien de temps le système fonctionne. Utilisez alias pour créer des raccourcis vers les commandes fréquemment utilisées.Par exemple, alias ll=&#39;ls -latr&#39; crée un nouvel alias ll. Conservez les aliases, les paramètres du shell et les fonctions fréquemment utilisées dans le fichier ~/.bashrc, et arrangez-vous pour qu’il soit chargé par le shell de connexion.Ainsi, votre configuration s’appliquera à toutes vos sessions shell. Placez dans ~/.bash_profile la configuration de vos variables d’environnement ainsi que les commandes à exécuter lorsque vous vous connectez.Une configuration séparée est nécessaire lorsque vous vous connectez depuis un gestionnaire de connexion graphique et pour les tâches planifiées par cron. Synchronisez vos fichiers de configuration (p.&nbsp;ex. .bashrc et .bash_profile) entre plusieurs ordinateurs avec Git. Comprennez qu’il convient d’être prudent lorsque des variables et des noms de fichiers contiennent des espaces.Mettez vos variables entre guillemets, par exemple &quot;$FOO&quot;.Préférez les options -0 ou -print0 qui permettent de délimiter les noms des fichiers avec le caractère nul, par exemple locate -0 pattern | xargs -0 ls -al ou find / -print0 -type d | xargs -0 ls -al.Pour itérer sur des noms de fichiers contenant des espaces dans une boucle for, positionnez la variable IFS avec le caractère de retour à la ligne à l’aide de IFS=$&#39;\n&#39;. Dans les scripts Bash, utilisez set -x (ou la variante set -v qui enregistre les entrées brutes, y compris les variables non référencées et les commentaires) pour l’affichage d’informations de débogage.Utilisez les modes stricts à moins que vous ayez une bonne raison de ne pas le faire&nbsp;: utilisez set -e pour interrompre le script en cas d’erreur (code de sortie non nul).Utilisez set -u pour détecter l’utilisation d’une variable non initialisée.Envisagez aussi set -o pipefail pour détecter les erreurs dans les tubes (cependant lisez-en plus si vous l’utilisez car ce sujet est un peu délicat).Pour des scripts plus compliqués, servez-vous également de trap pour intercepter EXIT ou ERR.Une bonne habitude est de commencer un script comme cela, ce qui lui permettra de détecter les erreurs courantes, de s’interrompre et d’afficher un message&nbsp;: 12set -euo pipefailtrap "echo 'error: Script failed: see failed command above'" ERR Dans les scripts en Bash, les sous-shells (placés entre parenthèses) sont commodes pour grouper des commandes.Un exemple classique consiste à se déplacer temporairement dans un autre répertoire de travail&nbsp;: 123# faire quelque chose dans le répertoire courant(cd /some/other/dir &amp;&amp; other-command)# continue dans le répertoire original Notez qu’en Bash, il existe de nombreux types d’expansions de variables. Pour vérifier l’existence d’une variable&nbsp;: ${name:?error message}.Par exemple, si un script en Bash exige un unique argument, il suffit d’écrire input_file=${1:?usage: $0 input_file}.Pour utiliser une valeur par défaut si une variable est vide&nbsp;: ${name:-default}.Si vous souhaitez ajouter un paramètre supplémentaire facultatif dans l’exemple précédent, vous pouvez écrire quelque chose comme output_file=${2:-logfile}.Si $2 est omis et donc vide, output_file prendra la valeur logfile.L’évaluation arithmétique&nbsp;: i=$(( (i+1) % 5).Les listes d’entiers&nbsp;: {1..10}Suppression de préfixes et de suffixes&nbsp;: ${var%suffix} et ${var#prefix}.Par exemple, si var=foo.pdf, alors echo ${var%.pdf}.txt affiche foo.txt. L’expansion des accolades avec {…} évite de retaper des textes similaires et automatise les combinaisons d’éléments de listes.C’est utile dans des exemples comme mv foo.{txt,pdf} some-dir (qui déplace les deux fichiers), cp somefile{,.bak} (équivalent à cp somefile somefile.bak) ou mkdir -p test-{a,b,c}/subtest-{1,2,3} (qui engendre toutes les combinaisons possibles et crée une arborescence de répertoires).L’expansion des accolades est effectuée avant toutes les autres expansions. Les expansions sont exécutées dans l’ordre suivant&nbsp;: expansion des accolades, développement du tilde, remplacement des paramètres et des variables, évaluation arithmétique, substitution de commande (de la gauche vers la droite), découpage en mots, puis développement des chemins.Par exemple, une liste telle que {1..20} ne peut s’exprimer avec des variables en utilisant {$a..$b}.À la place, utilisez seq ou une boucle for&nbsp;; par exemple, seq $a $b ou for((i=a; i&lt;=b; i++)); do ...; done. La sortie d’une commande peut être traitée comme un fichier à l’aide de &lt;(some command) (substitution de processus).Par exemple, pour comparer le fichier local /etc/hosts avec un fichier distant&nbsp;: 1diff /etc/hosts/ &lt;(ssh somehost cat /etc/hosts) Lorsque vous écrivez des scripts, vous pourriez avoir envie de placer votre code entre accolades.S’il manque l’accolade fermante, les scripts ne pourront s’exécuter à cause d’une erreur de syntaxe.C’est particulièrement utile pour des scripts mis à disposition sur le web, afin de prévenir leur exécution lorsqu’ils sont partiellement téléchargés. 123&#123; # Votre code ici&#125; Un «&nbsp;document intégré&nbsp;» permet de rediriger plusieurs lignes en entrée comme si elles provenaient d’un fichier&nbsp;: 1234cat &lt;&lt;EOFentrée surplusieurs lignesEOF En Bash, redirigez à la fois la sortie standard et la sortie des erreurs à l’aide de some-command &gt; logfile 2&gt;&amp;1 ou some-command &amp;&gt;logfile.Souvent, pour s’assurer qu’une commande ne laisse pas un descripteur de fichier ouvert sur l’entrée standard, l’attachant au terminal dans lequel vous vous trouvez, une bonne pratique consiste à ajouter &lt;/dev/null. Utilisez man ascii pour une bonne table ASCII avec les valeurs décimales et hexadécimales.Pour des informations générales sur l’encodage, man unicode, man utf-8 et man latin1 sont utiles. Utilisez screen ou tmux pour multiplexer une fenêtre de terminal, particulièrement utile pour des sessions SSH distantes, et pour détacher et rattacher une session.byobu peut améliorer screen ou tmux en fournissant plus d’informations et une gestion plus facile.Une alternative plus légère pour la persistance des sessions seulement est dtach. Il est utile de savoir comment créer un tunnel SSH avec -L ou -D (et occasionnellement -R), par exemple pour accéder à des sites web à partir d’un serveur distant. Il peut être intéressant d’effectuer quelques optimisations à votre configuration de ssh&#8239;; par exemple, le fichier ~/.ssh/config contient des paramètres pour éviter les pertes de connexion dans certains environnements réseaux, pour utiliser la compression (ce qui est utile avec scp sur des connexions à faible bande passante), et pour le multiplexage de canaux vers le même serveur avec un fichier de contrôle local&nbsp;: 1234567TCPKeepAlive=yesServerAliveInterval=15ServerAliveCountMax=6Compression=yesControlMaster autoControlPath /tmp/%r@%h:%pControlPersist yes Quelques autres options relatives à ssh sont sensibles pour la sécurité et ne devraient être activées qu’avec la plus grande prudence. Par exemple, sur des sous-réseaux, des hôtes ou des réseaux sûrs&nbsp;: StrictHostKeyChecking=no, ForwardAgent=yes. Envisagez mosh comme une alternative à ssh qui utilise UDP, évitant ainsi les pertes de connexion et ajoutant du confort en situation de mobilité (exige une installation côté serveur). Pour obtenir les permissions d’un fichier en octal, utile pour configurer le système mais non fournit par ls, utilisez quelque chose comme 1stat -c '%A %a %n' /etc/timezone Pour une sélection intéractive de valeurs issues de la sortie d’une commande, utilisez percol ou fzf. Pour intéragir avec les fichiers provenant de la sortie d’une commande (p.&nbsp;ex. git), utilisez fpp (PathPicker). Créez un simple serveur web pour partager les fichiers du répertoire courant (et ses sous-répertoires) avec python -m SimpleHTTPServer 7777 (port 7777 et Python 2) et python -m http.server 7777 (port 7777 et Python 3). Pour exécuter une commande avec les privilèges d’un autre utilisateur, utilisez sudo.Par défaut, cet autre utilisateur est root&#8239;; utilisez -u pour spécifier un autre utilisateur.Utilisez -i pour ouvrir une session en tant que cet autre utilisateur (on vous demandera votre mot de passe). Pour basculer le shell sous un autre utilisateur, utilisez su username ou su - username.Incluez - pour obtenir le même environnement que lorsque cet utilisateur se connecte.Le nom d’utilisateur par défaut est root.Le système vous demandera le mot de passe de l’utilisateur cible. Sachez que l’argument de la ligne de commande a une taille limite de 128 Kio. L’erreur « Argument list too long » est fréquente avec les jokers qui reconnaissent un grand nombre de fichiers (quand cela se produit des alternatives comme find et xargs peuvent aider). Pour une calculatrice basique (et bien sûr accéder à Python en général), utilisez l’interpréteur python.Par exemple, 12&gt;&gt;&gt; 2+35 Traitement des fichiers et des données Pour localiser un fichier par son nom dans le répertoire courant, find . -iname &#39;*something*&#39; (ou autres).Pour trouver un fichier n’importe où par son nom, utilisez locate something (mais n’oubliez pas que updatedb peut ne pas avoir indexé les fichiers récemment créés). Pour effectuer une recherche parmi des fichiers sources ou des fichiers de données, il existe des alternatives plus avancées ou plus rapides que grep -r, parmi lesquels (en gros du plus ancien au plus récent) ack, ag (« the silver searcher ») et rg (ripgrep). Pour convertir du HTML en texte brut : lynx -dump -stdin. Pour convertir du Markdown, du HTML et toutes sortes de formats texte, essayez pandoc.Par exemple, pour convertir un document Markdown au format Word : pandoc README.md --from markdown --to docx -o temp.docx Si vous devez manipuler du XML, l’ancien xmlstarlet marche bien. Pour le JSON, utilisez jq.Voir également jid and jiq pour une utilisation intéractive. Pour le YAML, utilisez shyaml. Pour les fichiers Excel ou CSV, csvkit fournit in2csv, csvcut, csvjoin, csvgrep, etc. Pour Amazon S3, s3cmd est pratique et s4cmd est plus rapide.L’outil d’Amazon aws et la version améliorée saws sont indispensables pour les autres tâches liées à AWS. Connaissez sort et uniq, y compris les options -u et -d de uniq (voir les unilignes plus bas). Voir aussi comm. Sachez utiliser cut, paste et join pour manipuler les fichiers texte.Beaucoup de personnes utilisent cut mais oublient join. Connaissez wc pour compter les lignes (-l), les caractères (-m), les mots (-w) et les octets (-c). Connaissez tee pour copier depuis stdin vers un fichier ou vers stdout, comme dans ls -al | tee file.txt. Pour des calculs plus complexes, incluant les regroupements, les inversions de champs et des calculs statistiques, considérez datamash. Sachez que la locale affecte de nombreux outils en ligne de commande de manière subtile, comme l’ordre pour les tris (collation) et les performances.La plupart des installateurs Linux définissent la variable LANG ou d’autres variables locales d’environnement pour configurer une locale telle que US English.Mais ayez à l’esprit que le tri sera modifié si vous changez la locale.Et sachez que les routines i18n peuvent rendre les opérations de tri et d’autres commandes beaucoup plus lentes.Dans certains cas (tels que les opérations concernant les ensembles et l’unicité abordées ci-dessous) vous pouvez, sans risque, ignorer complètement les lentes routines i18n et utiliser l’ordre de tri classique fondé sur les valeurs des octets à l’aide de export LC_ALL=C. Vous pouvez modifier l’environnement d’une commande particulière en préfixant son invocation par l’affectation de variables, comme dans TZ=Pacific/Fiji date. Apprenez awk et sed pour de l’analyse de données élémentaire.Voir la section Unilignes pour des exemples. Par exemple, pour effectuer la somme de tous les nombres de la troisième colonne d’un fichier texte&nbsp;: awk &#39;{ x += $3 } END { print x}&#39;.C’est probablement trois fois plus rapide et trois fois plus petit que son équivalent en Python. Pour remplacer toutes les occurences d’une chaîne de caractères dans un ou plusieurs fichiers&nbsp;: 1perl -pi.bak -e 's/old-string/new-string/g' my-files-*.txt Pour renommer de multiple fichiers ou effectuer des recherches et des remplacements dans des fichiers, essayez repren (dans certains cas la commande rename permet aussi de renommer de multiples fichiers, mais soyez prudent car ses fonctionnalités ne sont pas les mêmes sur toutes les distributions Linux). 1234567# Renomme les répertoires, les fichiers et leurs contenus à l'aide# de la substitution foo -&gt; bar :repren --full --preserve-case --from foo --to bar .# Restaure des fichiers de sauvegarde à l'aide de la# substitution whatever.bak -&gt; whatever :# Même chose que ci-dessus avec rename s'il est disponible :rename 's/\.bak$//' *.bak Selon sa page de manuel, rsync est un outil de duplication de fichiers vraiment rapide et incroyablement polyvalent.Il est connu pour faire de la synchronisation entre machines, mais est également utile pour un usage local.Lorsque les mesures de sécurité l’autorisent, utiliser rsync au lieu de scp permet de reprendre un transfert interrompu sans devoir le recommencer zéro.Il est aussi l’un des outils les plus rapides pour effacer un grand nombre de fichiers&nbsp;: 1mkdir empty &amp;&amp; rsync -r --delete empty/ some-dir &amp;&amp; rmdir some-dir Pour surveiller l’état d’avancement d’une copie de fichiers, utilisez pv, pycp, pmonitor, progress, rsync --progress, ou dd status=progress dans le cas d’une copie par blocs. Utilisez shuf pour mélanger ou sélectionner aléatoirement des lignes d’un fichier. Sachez les options de sort.Pour les nombres, utilisez -n, ou -h s’ils sont dans un format lisible par un humain (p.&nbsp;ex. issus de du -h).Comprenez le fonctionnement des clés (-t et -k).En particulier, faites attention à bien écrire -k1,1 pour trier seulement selon le premier champ&nbsp;: -k1 signifie que l’on trie selon la ligne entière.Le tri stable (sort -s) peut s’avérer utile.Par exemple, pour trier d’abord selon le champ 2, puis selon le champ 1, vous pouvez utiliser sort -k1,1 | sort -s -k2,2. Si jamais vous avez besoin d’écrire un caractère de tabulation dans une ligne de commande en Bash (p.&nbsp;ex pour le paramètre de l’option de tri -t), entrez ctrl-v [Tab] ou écrivez $&#39;\t&#39; (préférable car vous pouvez le copier-coller). Les outils habituels pour patcher un code source sont diff et patch.Voir aussi diffstat pour un relevé statistique d’un diff et sdiff pour un affichage côte à côte d’un diff.Remarquez que diff -r marche avec des répertoires entiers.Utilisez diff -r tree1 tree2 | diffstat pour obtenir un résumé des changements.Utilisez vimdiff pour comparer et éditer des fichiers. Pour les fichiers binaires, utilisez hd, hexdump ou xxd pour un affichage simple en hexadécimal et bvi, biew pour éditer des fichiers binaires. Également pour les fichiers binaires, strings (ainsi que grep, etc) vous permet d’y trouver des bouts de texte. Pour effectuer des différences entre des fichiers binaires (compression différentielle), utilisez xdelta3. Pour changer l’encodage d’un texte, essayer iconv, ou uconv pour un usage plus avancée&nbsp;: il permet quelques trucs avancés avec l’Unicode.Par exemple&nbsp;: 123456# Affiche les codes hexadécimaux et les noms des caractères (utile pour déboguer) : uconv -f utf-8 -t utf-8 -x '::Any-Hex;' &lt; input.txtuconv -f utf-8 -t utf-8 -x '::Any-Name;' &lt; input.txt# Convertit en minuscule et supprime les accents :uconv -f utf-8 -t utf-8 -x '::Any-Lower; ::Any-NFD; [:Nonspacing Mark:] &gt;; ::Any-NFC;' &lt; input.txt &gt; output.txt Pour découper des fichiers en morceaux, regardez split pour un découpage en morceaux de taille donnée et csplit pour un découpage en morceaux délimités par un motif. Date et heure&nbsp;: pour obtenir la date et l’heure courantes au format ISO 8601, utilisez date -u +&quot;%Y-%m-%dT%H:%M:%SZ&quot; (d’autres options sont problématiques).Pour manipuler des dates et des heures, utilisez dateadd, datediff, strptime, etc. fournis par dateutils. Utilisez zless, zmore, zcat et zgrep pour travailler sur des fichiers compressés. Les attributs d’un fichier peuvent être modifiés avec chattr et proposent une alternative de plus bas niveau aux permissions d’accès aux fichiers.Par exemple, l’attribut immutable protège un fichier contre toute suppression accidentelle: sudo chattr +i /critical/directory/or/file. Utilisez getfacl et setfacl pour sauvegarder et restorer les permissions. Par exemple: 12getfacl -R /some/path &gt; permissions.txtsetfacl --restore=permissions.txt Pour créer rapidement un fichier vide, utilisez truncate (crée un fichier creux), fallocate (systèmes de fichiers ext4, XFS, Btrfs et OCFS2), xfs_mkfile (pour presque tous les systèmes de fichiers, disponible dans le paquet xfsprogs) ou mkfile (pour les systèmes de type Unix comme Solaris ou Mac OS X). Débogage du système Pour du débogage web, curl et curl -I sont pratiques, de même que leurséquivalents avec wget ou le plus moderne httpie. Pour connaître l’état courant du CPU ou du disque, les outils conventionnels sont top (ou htop meilleur), iostat et iotop.Utilisez iostat -mxz 15 pour des statistiques de base concernant le CPU, des statistiques détaillées pour les disques et un aperçu des performances. Pour des informations sur les connexions réseaux, utilisez netstat et ss. Pour un rapide aperçu de ce qui se passe dans le système, dstat est particulièrement utile.Pour un aperçu plus étendu et détaillé, utilisez glances. Pour connaître l’état de la mémoire, exécutez free et vmstat et comprenez leurs sorties.En particulier, ayez à l’esprit que la valeur du « cache » est la mémoire utilisée par le noyau Linux comme cache de fichiers, donc compte comme de la mémoire « libre ». Le système de debogage de Java est une autre paire de manche, cependant un truc simple sur la JVM d’Oracle et quelques autres JVMs consiste à exécuter kill -3 &lt;pid&gt; pour obtenir une trace complète des appels et une empreinte de la mémoire (y compris des détails sur le ramasse-miettes qui peuvent être hautement instructifs) dans stderr ou des fichiers journaux.Les commandes jps, jstat, jstack et jmap de la JDK sont utiles. L’outil SJK est plus avancé. Utilisez mtr comme un traceroute amélioré pour identifier les problèmes de réseau. Pour déterminer les raisons pour lesquelles un disque est plein, ncdu permet de gagner du temps par rapport aux commandes habituelles telles que du -sh *. Pour trouver quel socket ou processus utilise la bande passante, essayez iftop ou nethogs. L’outil ab (fourni avec Apache) est utile pour une vérification rapide et grossière des performances d’un serveur web.Pour des tests de charge plus complexes, essayez siege. Pour du debogage réseau plus sérieux : wireshark, tshark ou ngrep. Sachez utiliser strace et ltrace.Ces commandes peuvent être utiles si un programme fonctionne mal ou plante et que vous n’en connaissez pas la raison, ou si vous voulez vous faire une idée de ses performances.Remarquez l’option de profilage (-c) et la possibilité de s’attacher à un processus en cours d’exécution (-p).Utilisez l’option -f pour ne pas manquer les appels des processus enfants. Connaissez ldd pour afficher les bibliothèques partagées, mais ne l’utilisez jamais sur des fichiers qui ne sont pas dignes de confiance. Sachez comment vous connecter à un processus en cours d’exécution avec gdb et récupérer la trace des appels. Utilisez /proc. C’est parfois incroyablement utile pour résoudre des problèmes en live.Exemples&nbsp;: /proc/cpuinfo, /proc/meminfo, /proc/cmdline, /proc/xxx/cwd, /proc/xxx/exe, /proc/xxx/fd, /proc/xxx/smaps (où xxx est l’identifiant du processus ou pid). Pour comprendre pourquoi quelque chose a mal tourné antérieurement, sar peut-être très utile.Il fournit un historique concernant l’usage du CPU, de la mémoire, du réseau, etc. Pour une analyse plus approfondie du système et de ses performances, regardez stap (SystemTap), perf et sysdig. Vérifiez quel OS vous utilisez avec uname ou uname -a (information général sur la version d’Unix et du noyau) ou lsb_release -a (informations sur la distribution Linux). Utilisez dmesg à chaque fois que quelque chose de bizarre se produit (pour des problèmes liés au matériel ou aux drivers). Si vous effacez un fichier et que du indique que l’espace occupé n’a pas été libéré, alors vérifiez si le fichier n’est pas utilisé par un processus:lsof | grep deleted | grep &quot;filename-of-my-big-file&quot; UnilignesQuelques exemples d’assemblages de commandes&nbsp;: Il est quelques fois extrèmement utile de pouvoir faire une intersection, union ou différence ensemblistes de fichiers texte à l’aide de sort et uniq.Supposez que a et b soient des fichiers texte ne contenant pas de lignes répétées.C’est rapide et fonctionne sur des fichiers de taille quelconque jusqu’à plusieurs gigaoctets (le tri n’est pas limité par la capacité mémoire bien que vous puissiez avoir besoin d’utiliser l’option -T si /tmp est sur une petite partition racine).Voyez aussi la remarque à propos de LC_ALL ci-dessus et l’option -u de sort (omise ci-dessous pour plus de clarté). 123sort a b | uniq &gt; c # c is a union bsort a b | uniq -d &gt; c # c is a intersect bsort a b b | uniq -u &gt; c # c is set difference a - b Utilisez grep . * pour inspecter rapidement les contenus des fichiers d’un repértoire (chaque ligne est précédé du nom du fichier) ou head -100 * (chaque fichier a un titre).Cela peut être utile pour des répertoires remplis de fichiers de configuration comme ceux de /sys, /proc, /etc. Pour ajouter les nombres de la troisième colonne d’un fichier texte (c’est probablement trois fois plus rapide et trois fois plus petit que son équivalent en Python)&nbsp;: 1awk '&#123; x += $3 &#125; END &#123; print x &#125;' myfile Pour visualiser les tailles et les dates des fichiers d’une arborescence, une sorte de ls -l récursive, mais plus facile à lire que ls -lR&nbsp;: 1find . -type f -ls Supposons que vous ayez un fichier texte comme un fichier journal de serveur web et q’une certaine valeur, comme un paramètre acct_id présent dans l’URL, figure à certaines lignes.Si vous voulez un décompte du nombre de requêtes pour chaque valeur de acct_id&nbsp;: 1egrep -o 'acct_id=[0-9]+' access.log | cut -d= -f2 | sort | uniq -c | sort -rn Pour surveiller en permanence tout changement, utilisez watch, par exemple vérifiez les modifications dans les fichiers d’un répertoire avec watch -d -n 2 &#39;ls -rtlh | tail&#39; ou surveillez les paramètres de votre réseau tout en dépannant la configuration de votre wifi avec watch -d -n 2 ifconfig. Exécutez cette fonction pour afficher aléatoirement une astuce de ce guide (analyse le code en Markdown et en extrait un élément d’une des listes)&nbsp;: 12345678function taocl() &#123; curl -s https://raw.githubusercontent.com/jlevy/the-art-of-command-line/master/README.md | sed '/cowsay[.]png/d' | pandoc -f markdown -t html | xmlstarlet fo --html --dropdtd | xmlstarlet sel -t -v "(html/body/ul/li[count(p)&gt;0])[$RANDOM mod last()+1]" | xmlstarlet unesc | fmt -80 | iconv -t US &#125; Obscures mais utiles expr : effectue des operations arithmétiques et booléenne, et évalue des expressions régulières. m4 : simple macro processeur. yes : affiche une chaîne de caractères indéfiniment. cal : un calendrier sympathique. env : exécute une commande (utile dans les scripts). printenv : imprime les variables d’environnement (utile pour le débogage et dans les scripts). look : trouve les mots anglais (ou les lignes d’un fichier) commençant par une chaîne donnée. cut, paste and join : manipulation des données. fmt : formate du texte. pr : formate un texte en pages ou en colonnes. fold : coupe des lignes de texte. column : formate un texte en colonnes alignées, de largeurs fixes ou en tables. expand et unexpand : convertit les tabulations en espaces et vice-versa. nl : numérote les lignes d’un fichier. seq : affiche une suite de nombres. bc : une calculatrice. factor : factorise des nombres entiers. gpg : chiffre et signe les fichiers. toe : table des entrées terminfo. nc : debogage réseau et transfert de données. socat : relai et réacheminement de port TCP (semblable à netcat). slurm : visualisation du trafic réseau. dd : déplacer les données entre les fichiers ou les périphériques. file : détermine le type d’un fichier tree : affiche les répertoires et sous-répertoires sous la forme d’un arbre (comme ls mais récursivement). stat : affiche des informations sur un fichier. time: exécute et chronomètre une commande. timeout: exécute une commande avec une limite de temps et stoppe le processus après la durée indiquée. lockfile : crée un fichier sémaphore qui ne peut être supprimé que par rm -f logrotate : permet la rotation, la compression et l’envoi des fichiers journaux par courrier électronique. watch : exécute une commande périodiquement, affiche le résultat et surligne les différences entre les résultats. when-changed : exécute n’importe quelle commande donnée à chaque fois qu’un fichier est modifié. Voir également inotifywait et entr. tac : affiche des fichiers à l’envers. comm : compare ligne à ligne deux fichiers triés. strings : extrait du texte de fichiers binaires. tr : conversion et manipulation de caractères. iconv ou uconv : conversion entre différents encodages de caractères. split et csplit : découpage de fichiers. sponge : lit entièrement un flux d’entrée avant de l’écrire. Utile pour lire depuis un fichier puis écrire dans le même fichier, par exemple&nbsp;: grep -v something some-file | sponge some-file units : conversions d’unités et calculs. Convertit des furlongs par fortnight en twips par blink (voir aussi /usr/share/units/deifinitions.units). apg : génère des mots de passe aléatoires. xz : compresse des fichiers avec taux de compression élevé. ldd : affiche des informations sur les bibliothèques partagées. nm : affiche les symboles des fichiers objets. ab ou wrk : mesure les performances de serveurs web. strace: trace les appels système. mtr: un traceroute amélioré pour débugguer un réseau. cssh : visual concurrent shell rsync : synchronise des fichiers et des dossiers via SSH ou localement. wireshark et tshark: capture de paquets et dépannage réseau. ngrep : grep pour les couches réseaux. host et dig: interroge les serveurs DNS. lsof : process file descriptor and socket info. dstat : statistiques sur les ressources système. glances: aperçu de haut niveau et multi-systèmes. iostat : statistiques sur l’usage du disque. mpstat : statistiques sur l’usage du CPU. vmstat : statistiques sur l’usage de la mémoire. htop : version améliorée de top. last : historique des connexions. w : montre qui est connecté. id : affiche les informations sur un utilisateur et ses groupes. sar : statistiques sur l’activité du système iftop ou nethogs : utilisation du réseau par un socket ou un processus. ss : statistiques relatives aux sockets. dmesg : messages lors du démarrage et erreurs système. sysctl : visualise et configure les paramètres du noyau Linux à chaud. hdparm : manipulation et performances d’un disque SATA ou ATA. lsblk : affiche les périphériques blocs (une arborescence de vos disques et de leurs partitions). lshw, lscpu, lspci, lsusb, dmidecode : informations sur le matériel, comprenant le CPU, le BIOS, le RAID, la carte graphique, les périphériques, etc. lsmod et modinfo : liste les modules du noyau et donne des informations sur un module. fortune, ddate et sl : euh, bon, seulement si vous estimez que les locomotives à vapeur et les citations de Jean-Claude Van Damme sont « utiles ». Uniquement macOSCe qui suit ne s’applique qu’à macOS. Gestion des paquets avec brew (Homebrew) ou port (MacPorts).Ceux-ci peuvent être utilisés pour installer sur macOS la plupart des commandes mentionnées ci-dessus. Copier la sortie de n’importe quelle commande dans une application de bureau avec pbcopy et coller l’entrée d’une commande avec pbpaste. Pour permettre à la touche Option de fonctionner comme la touche Alt dans le terminal de macOS (comme dans les commandes alt-b, alt-f, etc), allez dans Préférences -&gt; Profils -&gt; Clavier et sélectionner « Choisir la touche Option comme touche virtuelle ». Pour ouvrir un fichier avec une application de bureau, utilisez open ou open -a /Applications/Whatever.app. Spotlight&nbsp;: recherche de fichiers avec mdfind et affichage des métadonnées (telles que les informations EXIF d’une photo) avec mdls. Ayez à l’esprit que macOS dérive du système Unix BSD et que beaucoup de commandes (par exemple ps, ls, tail, awk, sed) présentent de légères différences avec leurs versions pour Linux, qui lui est largement influencé par System V et les outils GNU.Vous pouvez souvent faire la distinction grâce à l’en-tête « BSD General Commands Manual » dans les pages de manuel.Dans certains cas, les versions GNU peuvent également être installées (telles que gawk et gsed pour GNU awk et GNU sed).Pour écrire des scripts Bash multi-plateformes évitez d’utiliser de telles commandes (par exemple, envisagez d’utiliser Python ou Perl) ou alors testez-les soigneusement. Pour obtenir des informations sur la version de macOS, utilisez sw_vers. Uniquement WindowsCe qui suit ne concerne que Windows. Différentes manières d’obtenir les outils Unix sous Windows Installez Cygwin pour bénéficier de la puissance du shell Unix sous Microsoft Windows.La majorité de ce qui est décrit dans ce document fonctionnera out of the box. Sous Windows 10, Windows Subsystem for Linux (WSL) fournit un environnement Bash avec les utilitaires en ligne de commandes d’Unix. Si vous êtes surtout intéressés par les outils de developpement GNU (comme GCC) sur Windows, jetez un œil à MinGW et à son package MSYS qui fournit des utilitaires tels que bash, gawk, make et grep.MSYS ne dispose pas de toutes les fonctionnalités de Cygwin.MinGW est particulièrement utile pour porter sous Windows des outils Unix. Une autre manière d’obtenir le look and feel d’Unix sous Windows est d’utiliser Cash.Notez que très peu de commandes Unix et d’options de ligne de commande sont disponibles dans cet environnement. Outils en ligne de commande utiles pour Windows Vous pouvez accomplir et scripter la plupart des tâches d’administration système de Windows depuis la ligne de commande à l’aide de wmic. Parmi les outils réseaux en ligne de commande nativement disponibles sous windows que vous devriez trouver utiles, on trouve ping, ipconfig, tracert et netstat. Vous pouvez effectuer de nombreuses tâches sous Windows en invoquant la commande Rundll32. Trucs et astuces à propos de Cygwin Installez des programmes Unix supplémentaires à l’aide du gestionnaire de paquets de Cygwin. Utilisez mintty comme fenêtre de ligne de commande. Accédez au presse-papier de Windows par /dev/clipboard. Exécutez cygstart pour ouvrir un fichier quelconque avec l’application associée. Accédez à la base de registres de Windows avec regtool. Sachez qu’on accède au lecteur C:\ depuis Cygwin via /cygdrive/c et que le chemin Cygwin \ devient C:\cygwin sous Windows.Effectuez des conversions entre les deux types de chemin avec l’utilitaire cygpath.C’est particulièrement utile pour invoquer des programmes Windows dans les scripts. Autres ressources awesome-shell&nbsp;: une liste organisée d’outils et de ressources pour le shell. awesome-osx-command-line&nbsp;: un guide plus approfondi sur la ligne de commande pour macOS. Strict mode&nbsp;: pour écrire de meilleurs scripts shell. shellcheck&nbsp;: un outil d’analyse statique des scripts shell. L’équivalent de lint pour bash, sh et zsh. Filenames and Pathnames in Shell&nbsp;: les points de détail, malheureusement compliqués, sur la manière de manipuler correctement les noms de fichiers dans les scripts shell. Data Science at the Command Line&nbsp;: d’autres outils en ligne de commande, utiles en science des données et discutés dans le livre du même nom. AvertissementÀ l’exception des très petites tâches, le code est écrit de sorte que d’autres personnes puissent le lire.Il n’y a pas de pouvoir sans responsabilité : le fait que vous puissiez faire quelque chose en Bash ne signifie pas nécessairement que vous devriez le faire ! ;) Licence Ce document est mis à disposition selon les termes de la Licence Creative Commons Attribution - Partage dans les mêmes conditions 4.0 International.]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%9A%84%E8%89%BA%E6%9C%AF%2FREADME-es%2F</url>
    <content type="text"><![CDATA[🌍Čeština ∙ Deutsch ∙ Ελληνικά ∙ English ∙ Español ∙ Français ∙ Indonesia ∙ Italiano ∙ 日本語 ∙ 한국어 ∙ Português ∙ Română ∙ Русский ∙ Slovenščina ∙ Українська ∙ 简体中文 ∙ 繁體中文 El Arte del Terminal Meta Fundamentos Uso diario Procesamiento archivos y datos Depuración del sistema One-liners Obscuro pero útil Solo para OS X Solo para Windows Más recursos Advertencia La fluidez en el terminal es una destreza a menudo abandonada y considerada arcaica, pero ésta mejora tu flexibilidad y productividad como ingeniero de formas obvias y sutiles. Esta es una selección de notas y consejos para usar el terminal que encontramos útiles al trabajar en Linux. Algunos consejos son elementales y algunos bastante específicos, sofisticados u oscuros. Esta página no es larga, pero si puedes usar y recordar todos los puntos aquí mostrados, sabrás un montón. Este trabajo es el resultado de muchos autores y traductores.Parte de esta:originalmenteaparecióen Quora,pero se ha movido desde entonces a Github, donde personas más talentosas que el autor han hecho numerosas mejoras.Por favor contribuye Si ves un error o algo que podría ser mejor! MetaAlcance: Esta guía es tanto para principiantes como para experimentados. Los objetivos son diversidad (todo importa), especificidad (dar ejemplos concretos del caso más común), y concisión (evitar cosas que no son esenciales o insignificantes que puedas buscar fácilmente en otro lugar). Cada consejo es esencial en alguna situación o significativamente puede ahorrar tiempo comparado con otras alternativas. Está escrita para Linux, con excepción de la secciones “Solo para OS X“ y “Solo para Windows“. Muchos de los otros puntos aplican o pueden ser instalados en otros Unices o OS X (o incluso Cygwin). Se centra en Bash interactivo, aunque muchos de los consejos aplican para otros shells y al Bash scripting por lo general. Incluye tanto comandos “estándar” Unix así como los que requieren instalaciones de paquetes especiales – siempre que sean lo suficientemente importantes para merecer su inclusión. Notas: Para mantener esto en una página, el contenido está incluido implícitamente por referencia. Eres lo suficientemente inteligente para consultar más detalles en otros lugares buscando en Google una vez conoces la idea o el comando. Usa apt-get, yum, dnf, pacman, pip o brew (según proceda) para instalar los nuevos programas. Usa Explainshell para obtener detalles de ayuda sobre que hacen los comandos, las opciones, las pipes, etc. Fundamentos Aprende conocimientos básicos de Bash, de hecho, escribe man bash y al menos échale un vistazo a todo el asunto. Es bastante fácil de seguir y no es tan largo. Alternar entre shells puede ser agradable, pero Bash es poderoso y siempre está disponible (conocer solo zsh, fish, etc., aunque resulte tentador en tu propia laptop, Te restringe en muchas situaciones, tales como el uso de servidores existentes). Aprende bien al menos un editor de texto, idealmente Vim (vi), como no hay realmente una competencia para la edición aleatoria en un terminal (incluso si usa Emacs, un gran IDE, o un editor alternativo (hipster) moderno la mayor parte del tiempo). Conoce como leer la documentación con man (Para curiosos, man man lista las secciones enumeradas, ej. 1 es comandos “regulares”, 5 son archivos/convenciones, y 8 para administración). Encuentra las páginas de man apropos. Sepa que alguno de los comandos no son ejecutables, pero son Bash builtins, y que puedes obtener ayuda sobre ellos con help y help -d. Aprende sobre redirección de salida &gt;, entrada &lt; y pipes utilizando |. Conozca que &gt; sobrescribe el archivo de salida y &gt;&gt; añade. Aprende sobre stdout y stderr. Aprende sobre expansión de archivos glob con * (y tal vez ? y […]) y quoting y la diferencia entre comillas dobles &quot; y simples &#39;. (Ver más en expansión de variables más abajo.) Familiarízate con la administración de trabajo en Bash: &amp;, ctrl-z, ctrl-c, jobs, fg, bg, kill, etc. Conoce ssh y lo básico de autenticación sin contraseña, vía ssh-agent, ssh-add, etc. Administración de archivos básica: ls y ls -l (en particular, aprende el significado de cada columna en ls -l), less, head, tail y tail -f (o incluso mejor, less +F), ln y ln -s (aprende las diferencias y ventajas entre enlaces hard y soft), chown, chmod, du (para un resumen rápido del uso del disco: du -hs *). Para administración de archivos de sistema, df, mount, fdisk, mkfs, lsblk. Aprenda que un inode es ls -i or df -i). Administración básica de redes: ip o ifconfig, dig. Aprende y usa un sistema de control de versiones, por ejemplo git. Conoce bien las expresiones regulares y varias opciones (flags) para grep/egrep. Las opciones -i, -o, -v, -A, -B y -C son dignas de ser recordadas. Aprende el uso de apt-get, yum, dnf o pacman (dependiendo de la distribución “distro”) para buscar e instalar paquetes. Y asegúrate que tienes pip para instalar la herramienta de línea de comando basada en Python (un poco más abajo esta explicado como instalar vía pip). De uso diario En Bash, se usa Tab para completar los argumentos o lista todos los comandos disponibles y ctrl-r para buscar a través del historial de comandos (despues de presionar, escribe la búsqueda, presiona ctrl-r repetidamente para hacer un ciclo a través de más coincidencias, presiona Enter para ejecurar el comando encontrado, o presiona la flecha derecha para poner el resultado en la línea actual y editar). En Bash, se usa ctrl-w para borrar la última palabra, y ctrl-u para borrar todo hacia atrás hasta el inicio de la línea. Se usa alt-b y alt-f para moverse entre palabras, ctrl-a para mover el cursor al principio de la línea, ctrl-e para mover el cursor al final de la línea, ctrl-k para eliminar hasta el final de la línea, ctrl-l para limpiar la pantalla. Ver man readline para todos los atajos de teclado por defecto en Bash. Son una gran cantidad. Por ejemplo alt-. realiza un ciclo a través de los comandos previos, y alt-* expande un glob. Alternativamente, si amas los atajos de teclado vi-style, usa set -o vi. (y set -o emacs para regresar a la anterior). Para editar largos comandos, después de configurar to editor (por ejemplo export EDITOR=vim), ctrl-x ctrl-e se abrirá el comando actual en un editor para editar multiples líneas. O en estilo vi, escape-v. Para ver los últimos comandos, history. También existen abreviaciones, tales como, !$ (último argumento) y !! último comando, aunque son fácilmente remplazados con ctrl-r y alt-.. Para volver al directorio principal con cd. Accede a los archivos relativos a tu directorio principal con el prefijo ~ (ej. ~/.bashrc). En scripts hrefierete al directorio principal con $HOME. Para volver al directorio de trabajo previo: cd -. Si estás a medio camino al escribir un comando pero cambias de opinión, presiona alt-# para agregar un # al principio y lo agrega como comentario (o usa ctrl-a, #, enter). Luego puedes regresar a este vía comando history. Usa xargs (o parallel). Es muy poderoso. Ten en cuenta que puedes controlar cuántos elementos son ejecutados por línea (-L), así como el paralelismo (-P). Si no estas seguro de que este haga la cosa correcta, usa xargs echo primero. También, -I{} es útil. Ejemplos: 12find . -name '*.py' | xargs grep some_functioncat hosts | xargs -I&#123;&#125; ssh root@&#123;&#125; hostname pstree -p es útil para mostrar el árbol de procesos. Usa pgrep y pkill para encontrar o señalar procesos por su nombre (-f es de mucha ayuda). Conoce las señales que puedes enviar a los procesos. Por ejemplo, para suspender un proceso usa kill -STOP [pid]. Con man 7 signal puedes ver la lista completa Usa nohup o disown si quieres que un proceso de fondo se mantenga corriendo para siempre. Verifica que procesos están escuchando vía netstat -lntp o ss -plat (para TCP; agrega -u para UDP). Consulta también lsof para abrir sockets y archivos. Consulta uptime o w para conocer cuánto tiempo el sistema ha estado corriendo. Usa alias para crear atajos para comandos comúnmente usados. Por ejemplo, alias ll=&quot;las -latr&quot; crea el alias ll En Bash scripts, usa set -x (o su variantes set -v, que registra las entradas sin procesar, incluyendo variables sin expander y comantarios) para depurar la salida. Usa el modo estricto al menos que tengas una buena razón para no hacerlo: Usa set -e para abortar en caso de errores (códigos de salida distintos a cero). Usa set -u para detectar uso de variables no definidas. Considera set -o pipefail también, para los errores con pipes, también (estudiar mas sobre este como un tema delicado). Para scripts más complejos, usa también trap. en EXIT o ERR. Un hábito útil es para comenzar un script como este, el cual detectará y abortará con errores comunes e imprimirá un mensaje: 12set -euo pipefailtrap "echo 'error: Falló del Script: ver arriba comando que falló'" ERR En Bash scripts, subshells (escritos con paréntesis) son maneras convenientes para agrupar los comandos. Un ejemplo común es temporalmente moverse hacia un directorio de trabajo diferente, Ej. 123# do something in current dir(cd /some/other/dir &amp;&amp; other-command)# continue in original dir En Bash, considera que hay muchas formas de expansión de variables. Verificar la existencia de una variable: ${name:?error message}. Por ejemplo, si un script Bash requiere un único argumento, solo escribe input_file=${1:?usage: $0 input_file}. Expansión aritmética: i=$(( (i + 1) % 5 )). Secuencias: {1..10}. Reducción de cadenas de texto: ${var%suffix} y ${var#prefix}. Por ejemplo si var=foo.pdf, entonces echo ${var%.pdf}.txt imprime foo.txt. Utilizando la expansión de corchetes {…} puede reducir el tener que retipear un texto similar y automatizar conbinaciones de elementos. Esto es útil en ejemplos como mv foo.{txt,pdf} some-dir (el cual mueve ambos archivos), cp somefile{,.bak} (el cual se expandirá a cp somefile somefile.bak) o mkdir -p test-{a,b,c}/subtest-{1,2,3} (el cual se expandirá en todas las posibles conbinaciones y creará un árbol de directorios). La salida de un comando puede ser tratado como un archivo por medio de &lt;(some command). Por ejemplo, comparar el /etc/hosts local con uno remoto: 1diff /etc/hosts &lt;(ssh somehost cat /etc/hosts) Conocer acerca de “here documents” en Bash, como también de cat &lt;&lt;EOF .... En Bash, redirecciona ambas la salida estándar y el error estándar, mediante: some-command &gt;logfile 2&gt;&amp;1 o some-command &amp;&gt;logfile. Frecuentemente, para garantizar que un comando no haya dejado abierto un archivo para controlar la entrada estándar vinculada al terminal en el que te encuentras y también como buena práctica puedes agregar &lt;/dev/null. Usa man ascii para una buena tabla ASCII con valores hexadecimal y decimales. Para información de codificación general, man unicode, man utf-8, y man latin1 son de utilidad. Usa screen o tmux para multiplexar la pantalla, especialmente útil en sesiones ssh remotas y para desconectar y reconectar a una sesión. byobu puede mejorar la pantalla o tmux proporcionando mayor información y gestión ás sencilla. Una alternativa más minimalista para persistencia de la sesión solo sería dtach. En ssh, saber cómo hacer un port tunnel con -L o -D (y de vez en cuando -R) es útil, Ej. para acceder a sitios web desde un servidor remoto. Puede ser útil hacer algunas optimizaciones a su configuración ssh; por ejemplo, ~/.ssh/config, contiene la configuración para evitar desconexiones en ciertos entornos de red, utiliza compresión (cual es útil con scp sobre conexiones con un bajo ancho de banda), y la multiplexión de canales para el mismo servidor con un archivo de control local: 1234567TCPKeepAlive=yesServerAliveInterval=15ServerAliveCountMax=6Compression=yesControlMaster autoControlPath /tmp/%r@%h:%pControlPersist yes Algunas otras opciones relevantes a ssh son sensibles en cuanto a seguridad y deben ser usadas con cuidado, Ej. por subnet, host o en redes confiables: StrictHostKeyChecking=no, ForwardAgent=yes. Considera mosh una alternativa para ssh que utiliza UDP, evitando conexiones caidas y agregando conveniencia en el camino. (require configuración del lado del servidor). Para obtener permiso sobre un archivo en forma octal, el cual es útil para la configuración del sistema pero no está disponible con ls y fácil de estropear, usa algo como 1stat -c '%A %a %n' /etc/timezone Para selección interactiva de valores desde la salida de otro comando, use percol o fzf. Para la interacción con archivos basados en la salida de otro comando (como git), use fpp (PathPicker). Para un servidor web sencillo para todos los archivos en el directorio actual (y subdirectorios), disponible para cualquiera en tu red, usa:python -m SimpleHTTPServer 7777 (para el puerto 7777 y Python 2) y python -m http.server 7777 (para 7777 y Python 3). Para ejecutar un comando con privilegios, usando sudo (para root) o sudo -u (para otro usuario). Usa su o sudo bash para realmente ejecutar un shell como este usuario. Usa su - para simular un login fresco como root u otro usuario. Procesamiento de archivos y datos Para localizar un archivo por nombre en el directorio actual, find . -iname &#39;*algo*&#39; (o similar). Para encontrar un archivo en cualquier lado por nombre, usa locate something (pero tenga en mente que updatedb quizás no haya indexado recientemente los archivos creados). Para búsqueda general a través de archivos fuente o de datos (más avanzado que grep -r), usa ag. Para convertir HTML a texto: lynx -dump -stdin Para Markdown, HTML, y todos los tipos de conversión de documentos, prueba pandoc. Si debe manipular XML, xmlstarlet es viejo pero bueno. Para JSON usa jq. Para YAML, usa shyaml. Para archivos Excel o CSV, csvkit proporciona in2csv, csvcut, csvjoin, csvgrep, etc. Para Amazon S3, s3cmd es conveniente y s4cmd es el mas rápido. aws de Amazon y el mejorado saws son esenciales para otras tareas relacionadas al AWS. Conoce acerca de sort y uniq, incluyendo las opciones de uniq -u y -d – ver one-liners más abajo. Ver también comm Conoce acerca de cut, paste y join para manipular archivos de texto. Muchas personas usan cut pero se olvidan acerca de join. Conoce acerca de wc para contar saltos de línea (-l), caracteres (-m), palabras (-w) y bytes (-c). Conoce acerca de tee para copiar desde el stdin hacia un archivo y también hacia el stdout, al igual que en ls -al | tee file.txt. Conoce que la localización afecta muchas herramientas de línea de comando en forma delicada, incluyendo el ordenamiento (compaginación) y rendimiento. La mayoría de las instalaciones de Linux configuran LANG u otras variables de localización para la configuración local como US English. Pero ten en mente que el ordenamiento puede cambiar si cambia la localización. Y también las rutinas i18n pueden hacer que sort u otros comandos se ejecuten más lentamente. En algunas situaciones (tales como la realización de operaciones u operaciones singulares descritas más abajo) puedes ignorar las rutinas i18n por completo y utilizar el sort tradicional basado en bytes, usando export LC_ALL=C. Conoce los aspectos básicos de awk y sed para manejo de datos. Por ejemplo, sumar todos lo números en la tercera columna de un archivo de texto: awk &#39;{ x += $3 } END { print x }&#39;. Esto es probablemente 3 veces más rápido y 3 veces más corto que su equivalente en Python. Para reemplazar todas las ocurrencias de un string en su lugar, en uno o más archivos: 1perl -pi.bak -e 's/old-string/new-string/g' my-files-*.txt Para renombrar multiples y/o buscar y remplazar dentro de archivos, intenta repren. (En algunos casos el comando rename también permite multiples renombramientos, pero sea cuidadoso ya que esta funcionalidad no es igual en todas las distribuciones de Linux.) 123456# Renombramiento completo de archivos, carpetas y contenidos foo -&gt; bar:repren --full --preserve-case --from foo --to bar .# Recuperar archivos de respaldo cualquier.bak -&gt; cualquier:repren --renames --from '.*)\.bak' --to '\1' *.bak# Igual que arriba, utilizando rename, si esta disponible:rename 's/\.bak$//' *.bak Como dice la página de man, rsync es una muy rápida y extraordinariamente versatil herramienta de copiado. Esta se conoce por la sincronización entre máquinas pero es igualmente útil localmente. Esta también se encuentra entre las formas más rápidas para borrar un gran número de archivos: 1mkdir empty &amp;&amp; rsync -r --delete empty/ some-dir &amp;&amp; rmdir some-dir Usa shuf para mezclar o seleccionar líneas aleatorias de un archivo. Conoce las opciones de sort. Para números, usa -n, o -h para manipulación de números humanamente leíbles (Ej. desde du -h). Conoce el trabajo principal de (-t y -k). En particular, esta atento que lo necesitas escribir-k1,1 para ordenar por solo el primer campo; -k1 significa ordenar de acuerdo a toda la línea. Orden estable (sort -s) puede ser útil. Por ejemplo, para organizar el primer por el campo 2, entonces secundariamente hacerlo por el campo 1, Puedes usar sort -k1,1 | sort -s -k2,2. Si alguna vez necesitas escribir un tab literal en una línea de comandos en Bash (Ej. para el argumento -t de ordenar), presiona ctrl-v [Tab] o escribe $&#39;\t&#39; (El último es mejor porque puedes copiarlo/pegarlo). Las herramientas estándar para reparar el código fuente son diff y patch. Consulta también diffstat para resumen estadístico de una diff y sdiff para un diff puesto lado a lado. Considera diff -r trabaja con directorios por completo. Usa diff -r tree1 tree2 | diffstat para el resumen de cambios. Urilizá vimdiff para comparar y editar archivos. Para archivos binarios, usa hd, hexdeump or xxd para volcados hexdecimales simples y bvi o biew para edición de binario. También para archivos binarios, strings (además de grep, etc.) permite encontrar fragmentos de texto. Para diffs binaria (compresión delta), usa xdelta3. Para convertir la codificación del texto, probar iconv. O uconv para uso más avanzado; este soporta algunos elementos Unicode avanzados. Por ejemplo, este comando coloca en minúsculas y remueve todas los acentos (por su expansión y colocándolos): 1uconv -f utf-8 -t utf-8 -x '::Any-Lower; ::Any-NFD; [:Nonspacing Mark:] &gt;; ::Any-NFC; ' &lt; input.txt &gt; output.txt Para dividir archivos en múltiples partes, consulta split (para dividir por tamaño) y csplit (para dividir por un patrón). Para manipular expresiones de fecha y tiempo, usa dateadd, datediff, strptime etc. de dateutils. Usa zless, zmore, zcat, y zgrep para operar sobre archivos comprimidos. Depuración del sistema Para depuración web, curl y curl -I son prácticos, o como sus equivalentes wget, o el más moderno httpie. Para conocer el estado del cpu/disco, las clásicas herramientas son top (o mejor htop), iostat, y iotop. Usa iostat -mxz 15 para CPU básicas y estadísticas detalladas y visión de rendimiento por partición del disco. Para detalles de la conexión de red, usa netstat y ss. Para una rápida visión general de que esta pasando en un sistema, dstat es especialmente útil. Para una visión general más amplia con detalles usa glances. Para conocer el estado de la memoria, ejecuta y entiende la salida de free y vmstat. En particular, ten en cuenta que el valor “cached” es mantenido en memoria por el kernel de Linux como un archivo de cache, por lo que efectivamente cuenta como valor para “free”. El sistema de depuración de Java es harina de otro costal, pero un truco simple en las JSM de Oracle y otros consta en que puedes ejecutar kill -3 &lt;pid&gt; y una traza completa y un resumen del montículo “heap summary” (incluyendo del detalle de la colección de basura generacional, la cual puede ser altamente informativa) serán descargados al stderr/logs. Las herramientas jps, jstat, jstack, jmap del JDK son útiles. SJK tools son más avanzadas. Usa mtr como un mejor traceroute para identificar los problemas en la red. Para examinar por qué el disco está lleno, ncdu ahorra tiempo en comparación con los comandos usuales como du -sh *. Para encontrar cual socket o proceso está utilizando el ancho de banda, prueba iftop o nethogs. La herramienta ab (viene con Apache) es útil para una verificación rápida del rendimiento de un servidor web. Para pruebas de carga más complejas prueba siege. Para una depuración mas seria de redes, wireshark, tshark, o ngrep. Conoce acerca de strace y ltrace. Estas puede ser de utilidad si un programa está fallando, suspendido, o colgado, y no sabe por qué, o si quieres tener una idea general del rendimiento. Considera la opción de elaboración de perfiles (-c), y la habilidad de adjuntar a un proceso en ejecución (-p). Conoce acerca ldd para verificar librerías compartidas etc. Conoce como conectarse a un proceso en ejecución con gdb y obtener su traza de pilas. Usa /proc. Es extraordinariamente útil algunas veces cuando se depuran problemas en vivo. Ejemplos: /proc/cpuinfo, /proc/xxx/cwd, /proc/meminfo, /proc/cmdline, /proc/xxx/exe, /proc/xxx/fd/, /proc/xxx/smaps (donde xxx es el id o pid del proceso). Cuando se depura porque algo salió mal en el pasado, sar puede ser muy útil. Este muestra la estadística histórica en CPU, memoria, red, etc. Para sistemas y análisis de rendimiento de mayor profundidad, examina stap (SystemTap), perf), y sysdig. Comprueba en que OS se encuentra con uname o uname -a (información general en Unix/kernel) o lsb_release -a (información en Linux distro). Usa dmesg siempre que algo actúe raro (esto podría ser problemas con el hardware o driver). One-linersAlgunos ejemplos de comandos reunidos: Es notablemente útil en ocasiones que pueda realizar intersección, unión, y diferencia de conjuntos de archivos de texto vía sort/uniq. Suponga que a y b como archivos de texto que son únicos. Esto es rápido, y trabaja con archivos de tamaño arbitrario, hasta varios gigabytes. (Sort no está limitado por la memoria, aunque quizás necesite utilizar la opción -T si /tmp está en una pequeña partición de raíz.) Consulta también la nota acerca de LC_ALL y las opciones de sort, -u (dejado de lado para clarificar más abajo). 123cat a b | sort | uniq &gt; c # c es a unido con bcat a b | sort | uniq -d &gt; c # c es a intersectado con bcat a b b | sort | uniq -u &gt; c # c es el conjunto diferencia a - b Usa grep . * para rápidamente examinar el contenido de todos los archivos de un directorio (para que cada línea este emparejada con con el nombre de archivo), o head -100 * (para que cada archivo tenga un encabezado). Esto puede se útil para directorios llenos con ajustes de configuración como aquellos en /sys, /proc, /etc. Sumar todos los números en la tercera columna de un archivo de texto (esto es probablemente 3 veces más rápido y 3 veces menos código que el equivalente en Python): 1awk '&#123; x += $3 &#125; END &#123; print x &#125;' miarchivo Consultar tamaños/fechas en un árbol de archivos, esto es como un ls -l recursivo pero es más fácil de leer que ls -lR: 1find . -type f -ls Digamos que tiene un archivo de texto, como un log de un servidor web, y un cierto valor comienza a aparecer en algunas líneas, tales como un parámetro acct_id que está presente en la URL. Si quieres un recuento de cuantas peticiones por cada acct_id: 1cat access.log | egrep -o 'acct_id=[0-9]+' | cut -d= -f2 | sort | uniq -c | sort -rn Para monitorear continuamente los cambios, usa watch, Ej. verificar los cambios de archivos en un directorio con watch -d -n 2 &#39;ls -rt1h | tail&#39; o para configuraciones de red mientras solucionas problemas con la configuración wifi watch -d -n 2 ifconfig. Ejecuta esta función para obtener un consejo aleatorio desde este documento (analiza el Markdown y extrae un elemento): 1234567function taocl() &#123; curl -s https://raw.githubusercontent.com/jlevy/the-art-of-command-line/master/README.md | pandoc -f markdown -t html | xmlstarlet fo --html --dropdtd | xmlstarlet sel -t -v "(html/body/ul/li[count(p)&gt;0])[$RANDOM mod last()+1]" | xmlstarlet unesc | fmt -80&#125; Obscuro, pero útil expr: ejecuta operaciones aritméticas o booleanas o evalúa expresiones regulares m4: procesador de macro sencillo yes: imprime un string sin fin cal: lindo calendario env: ejecuta un comando (útil en scripts) printenv: imprime las variables del entorno (útil en depuración y scripts) look: buscar palabras en inglés (o líneas en un archivo) comenzando con un string cut, paste y join: manipulación de datos fmt: formatea los párrafos de texto pr: formatea el texto en páginas/columnas fold: ajusta de líneas de texto column: formatea campos de texto alineados, en columnas de ancho fijo o tablas expand y unexpand: conversión entre tabuladores y espacios nl: agrega números de línea seq: imprime números bc: calculadora factor: factorización de enteros gpg: encripta y firma archivos toe: tabla de información de términos nc: depuración de la red y transferencia de datos socat: socket relay y redireccionador de puerto tcp (similar a netcat) slurm: visualización del tráfico de red dd: moviliza datos entre archivos o dispositivos file: identifica el tipo de archivo tree: muestra directorios y subdirectorios como un árbol anidado; parecido a ls pero recursivo stat: información del archivo time: ejecuta y calcula el tiempo de ejecución de un comando timeout: ejecuta un comando especificando una cantidad de tiempo y deteniendo el proceso cuando la cantidad de tiempo especificado se completa. lockfile: crea un archivo semáforo que puedes solo ser removido con rm -f logrotate: rota, comprime y registra correos electrónicos. watch: ejecuta un comando repetidamente, mostrando resultados y/o resaltando cambios tac: imprime archivos en forma inversa shuf: selección aleatoria de líneas de un archivo comm: compara archivos ordenados línea por línea pv: monitorea el progreso de datos a través de un tubo hd, hexdump, xxd, bview y bvi: descarga o edita archivos binarios strings: extrae texto desde archivos binarios tr: traducción o manipulación de caracteres iconv o uconv: conversión de codificaciones de texto split y csplit: división de archivos sponge: lee todas las entradas antes de escribirlo, útil para vista previa y posterior escritura sobre el mismo archivo, Ej., grep -v something some-file | sponge some-file units: unidades de conversión y cálculos; convierte furlongs por fortnight a twips por blink (ver también /usr/share/units/definitions.units) apg: genera contraseñas aleatorias. 7z: compresión de archivos de alto nivel ldd: información de librería dinámica nm: símbolos de archvios objeto ab: benchmarking de servidores web strace: depuración de llamadas del sistema mtr: mejor traceroute para la depuración de la red cssh: shell concurrente visual rsync: sincronización de archivos y carpetas sobre SSH o en sistema de archivos locales wireshark y tshark: captura de paquetes y depuración de la red ngrep: grep para la capa de la red host y dig: consultas DNS lsof: descriptor de archivo de procesos e información de socket dstat: sistema de estadísticas útil glances: visión general de multi-subsistemas, de alto nivel iostat: estadísticas del uso del disco duro mpstat: estadísticas del uso del CPU vmstat: estadísticas del uso de la memoria htop: versión mejorada de top last: historial de login w: quién está autenticado id: información de identidad de usuario/grupo sar: estadísticas históricas del sistema iftop o nethogs: utilización de la red por un socket o proceso ss: estadísticas de socket dmesg: mensajes de error del arranque y del sistema sysctl: examina y configura los parámetros de kernel de Linux en tiempo de ejecución hdparm: manipulación/rendimiento de discos SATA/ATA lsblk: lista de dispositivos de bloque: una vista tipo arbol de sus discos y particiones de disco lshw, lscpu, lspci, lsusb, dmidecode: información de hardware, incluyendo CPU, BIOS, RAID, gráficos, dispositivos, etc lsmod y modinfo: lista y muestra detalles de los módulos del kernel fortune, ddate, y sl: um, bien, depende de si considera las locomotoras de vapor y citas Zippy “útiles” Solo para OS XEstos son puntos relevantes únicamente para OS X. Administración de paquetes con brew (Homebrew) y/o port (MacPorts). Estos pueden ser utilizados para instalar en OS X muchos de los comandos de arriba. Copie la salida de cualquier comando en una aplicación de escritorio con pbcopy y pegue una entrada con pbpaste. Para activar la tecla Option en un OS X Terminal como una tecla alt (tal como se usan en los comandos más arriba como alt-b, alt-f, etc.), abre Preferencias -&gt; Perfiles -&gt; Teclado y selecciona “Usa Option como tecla Meta”. Para abrir un archivo con una aplicación de escritorio, use open o open -a /Applications/Whatever.app. Spotlight: Busque archivos con mdfind y liste metadata (tal como información de foto EXIF) con mdls. Ten en cuenta que OS X está basado en BSD Unix, y muchos comandos (por ejemplo ps, ls, tail, awk, sed) tiene sutiles variaciones en comparación con Linux, que está en gran parte influenciado por el sistema Unix V-style y herramientas GNU. Comunmente se puede diferenciar al notar que una página man tienen el encabezado “BSD General Commands Manual.” En algunos casos versiones GNU pueden ser instaladas también (tales como gawk y gsed para GNU awk y sed). Si escribe Bash scripts multiplataforma, evite tales comandos (por ejemplo, considere Python o perl) o prueba cuidadosamente. Para obtener la información de la versión del OS X, usa sw_vers. Solo para WindowsEstos son puntos relevantes únicamente para Windows. -En Windows 10, puedes usar Bash de Ubuntu en Windows que proporciona un entorno familiar con la línea de comandos en Unix. Su lado positivo, este permite a los programas de Linux ejecutarse en Windows. Por otro lado este no soporta ejecutar de programas de Windows desde la línea de comandos Bash. Accede al poder del shell de Unix en Microsoft Windows instalando Cygwin. La mayoría de las cosas descritas en este documento funcionaran en su configuración por defecto. Instala programas adicionales de Unix con el gestor de paquetes de Cygwin Usa mintty como tu línea de comando. Accede al portapapeles de Windows a través de /dev/clipboard. Ejecuta cygstart para abrir un archivo arbitrario a través de su aplicación registrada. Accede al registro de Windows con regtool. Ten en cuenta que la ruta C:\ del disco Windows se transforma en /cygdrive/c en Cygwin, y que Cygwin / aparece en C:\cygwin en Windows. Convierte entre Cygwin y rutas de archivos estilo Windows con cygpath. Este es el más útil de los scripts que invocan programas de Windows. Puedes ejecutar y hacer scripts de la mayoría de las tareas administrativas del sistema de Windows desde la línea de comandos aprendiendo y usando wmic. Otra opción para obtener la apariencia y sensación de Unix en Windows es Cash. Ten en cuenta que muy pocos comandos de Unix y opciones de la línea de comandos están disponibles en este entorno. Una opción alternativa para tener herramientas de desarrollo GNU (algo como GCC) en windows es MinGW y MSYS su paquete, que proporciona utilidades tales como bash, gawk, make y grep. MSYS no tiene todas las características al compararse con Cygwin. MinGW es particularmente útil para crear ejecutables nativos de Windows de las herramientas Unix. Más recursos awesome-shell: Una lista curada de herramientas shell y recursos. awesome-osx-command-line: Una guía más detallada para la línea de comandos del OS X. Strict mode para escribir mejores script shell. shellcheck: Una herramienta de análisis estadístico del script shell. Esencialmente, lint para bash/sh/zsh. Filenames and Pathnames in Shell: Las menudencias tristemente complejas sobre cómo manejar nombres de archivos correctamente en shell scripts. AdvertenciaCon la excepción de tareas muy pequeñas, el código está escrito para que otros puedan leerlo. Con el poder llega la responsabilidad. El hecho de que puedes hacer algo en Bash no necesariamente significa que deba hacerlo! ;) Licencia Este trabajo está licenciado bajo Creative Commons Attribution-ShareAlike 4.0 International License.]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%9A%84%E8%89%BA%E6%9C%AF%2FREADME-el%2F</url>
    <content type="text"><![CDATA[🌍Čeština ∙ Deutsch ∙ Ελληνικά ∙ English ∙ Español ∙ Français ∙ Indonesia ∙ Italiano ∙ 日本語 ∙ 한국어 ∙ Português ∙ Română ∙ Русский ∙ Slovenščina ∙ Українська ∙ 简体中文 ∙ 繁體中文 Η Τέχνη της Γραμμής Εντολών+ Meta Τα βασικά Καθημερινή χρήση Επεξεργασία αρχείων και δεδομένων Αποσφαλμάτωση συστήματος Εντολές σε μία γραμμή Ασυνήθιστες αλλά χρήσιμες Μόνο για OS X Μόνο για Windows Περισσότερες πηγές Αποποίηση ευθύνης Η ευχέρεια στη χρήση της γραμμής εντολών είναι μία δεξιότητα συχνά παραμελημένη ή που θεωρείται ότι είναι για τους λίγους.Όμως η ευχέρια αυτή βελτιώνει την ευελιξία και την παραγωγικότητά σας ως μηχανικός τόσο με προφανείς όσο και με λιγότερο ευδιάκριτους τρόπους. Αυτή είναι μία συλλογή από σημειώσεις και συμβουλές που αφορούν τη χρήση της γραμμής εντολών και τις οποίες βρήκαμε χρήσιμες, ενώ εργαζόμασταν σε Linux. Κάποιες συμβουλές είναι εισαγωγικές και μερικές πιο συγκρεκριμένες, εξειδικευμένες ή εις βάθος. Αυτή η σελίδα δεν είναι μεγάλη, αλλά αν μπορείτε να τα θυμάστε όλα, τότε γνωρίζετε πολλά. Αυτή η εργασία είναι αποτέλεσμα πολλών συγγραφέων και μεταφραστών.Μέρος τηςαρχικάδημοσιεύτηκεστο Quora,αλλά έπειτα μετακινήθηκε στο GitHub, όπου άνθρωποι πιο ταλαντούχοι από τον αρχικό συγγραφέα έχουν κάνει πολυάριθμες βελτιώσεις.Παρακαλώ υποβάλετε μία ερώτηση, αν έχετε μία ερώτηση σχετική με τη γραμμή εντολών. Παρακαλώ συνεισφέρετε, αν δείτε ένα λάθος ή κάτι που μπορεί να βελτιωθεί! MetaΑντικείμενο: Αυτός ο οδηγός απευθύνεται τόσο σε αρχάριους όσο και σε έμπειρους. Οι στόχοι είναι το εύρος (ό,τι είναι σημαντικό), η ακρίβεια (να δοθούν συγκεκριμένα παραδείγματα για τις συνηθέστερες περιπτώσεις)και η συντομία (να αποφευχθούν πράγματα που δεν είναι αναγκαία ή παρεκβάσεις που μπορεί κανείς εύκολα να αναζητήσει αλλού). Κάθε συμβουλή είναι απαραίτητη σε κάποια περίπτωση ή εξοικονομεί χρόνο σε σημαντικό βαθμό σε σύγκριση με εναλλακτικές. Το παρόν είναι γραμμένο για Linux, με εξαίρεση των τμημάτων «Μόνο για OS X» και «Μόνο για Windows». Πολλά από τα υπόλοιπα κομμάτια ισχύουν ή μπορούν να εγκατασταθούν σε άλλα Unices ή OS X (ή ακόμη και Cygwin). Εστιάζεται στον διαδραστικό φλοιό Bash, αν και πολλές συμβουλές ισχύουν και για άλλους φλοιούς και γενικότερα στη συγγραφή σεναρίων (scripts) για Bash. Περιλαμβάνει τόσο τις «τυπικές» εντολές Unix καθώς και άλλες που απαιτούν την εγκατάσταση ειδικών πακέτων λογισμικού – αρκεί να είναι αρκετά σημαντικές ώστε να αξίζει να περιληφθούν. Σημειώσεις: Για να κρατηθεί το παρόν σε μία σελίδα, υπάρχει περιεχόμενο που περιλαμβάνεται έμμεσα κάνοντας αναφορά σε αυτό. Είστε αρκετά έξυπνοι ώστε να αναζητήσετε περαιτέρω λεπτομέρειες αλλού, μόλις καταλάβετε την ιδέα ή την εντολή που χρειάζεται να αναζητήσετε στο Google. Χρησιμοποιήστε apt-get, yum, dnf, pacman, pip ή brew (ανάλογα με την περίπτωση) για να εγκαταστήσετε νέα προγράμματα. Χρησιμοποιήστε Explainshell για να έχετε μια χρήσιμη ανάλυση του τι κάνουν κάνουν εντολές, επιλογές, σωληνώσεις κλπ. Τα βασικά Μάθετε τα βασικά του φλοιού Bash. Πράγματι, πληκτρολογήστε man bash και τουλάχιστον ρίξτε μια ματιά σε αυτό που εμφανίζεται· είναι αρκετά εύκολο να το ακολουθήσετε κι όχι και τόσο μεγάλο. Άλλοι φλοιοί μπορεί να είναι μια χαρά, αλλά ο φλοιός Bash έχει πολλές δυνατότητες και είναι πάντα διαθέσιμος (το να μάθετε μόνο zsh, fish κλπ., αν και δελεαστικό όσο δουλεύετε στο δικό σας laptop, σας περιορίζει σε πολλές περιπτώσεις, όπως στην περίπτωση servers που ήδη υπάρχουν). Μάθετε τουλάχιστον έναν text-based επεξεργαστή κειμένου καλά. Ο επεξεργαστής κειμένου nano είναι από τους από τους απλούστερους για βασική επεξεργασία (άνοιγμα, επεξεργασία, αποθήκευση, αναζήτηση). Όμως, για τον έμπειρο χρήστη σε ένα τερματικό κειμένου, δεν υπάρχει υποκατάστατο για τον Vim (vi), τον δύσκολο να τον μάθει κάνεις αλλά αξιόλογο, γρήγορο και ολοκληρωμένο επεξεργαστή κειμένου. Πολλοί χρησιμοποιούν ακόμη τον κλασικό Emacs, ιδιαίτερα για μεγαλύτερες εργασίες που αφορούν επεξεργασία κειμένου. (Βέβαια, κάθε σύγχρονος προγραμματιστής που εργάζεται σε ένα μεγάλο έργο είναι απίθανο να χρησιμοποιεί μόνο έναν απλό text-based επεξεργαστή κειμένου και θα πρέπει να είναι επίσης εξοικειωμένος με σύγχρονα και με γραφικό περιβάλλον IDEs και εργαλεία.) Να γνωρίζετε πώς να διαβάζετε τεκμηρίωση με την εντολή man (για τον περίεργο, η εντολή man man εμφανίζει σε λίστα τους αριθμούς των ενοτήτων, π.χ. η 1 περιέχει τις εντολές του φλοιού, η 5 αρχεία/συμβάσεις και η 8 είναι για διαχείριση). Αναζητήστε σελίδες man με την εντολή apropos. Να γνωρίζετε ότι μερικές εντολές δεν είναι εκτελέσιμα προγράμματα αλλά ενσωματωμένες στον φλοιό και μπορείτε να ζητήσετε βοήθεια σχετικά με αυτές με help και help -d. Μπορείτε να βρείτε αν μια εντολή είναι εκτελέσιμο πρόγραμμα, ή ενσωματωμένη στον φλοιό ή ένα ακόμη όνομα (συντόμευση) που έχει αντιστοιχηθεί στην εντολή αυτή χρησιμοποιώντας την εντολή type command. Μάθετε για την ανακατεύθυνση της εξόδου και της εισόδου με χρήση των τελεστών &gt; και &lt; και για τις σωληνώσεις εντολών με χρήση του |. Να γνωρίζετε ότι ο τελεστής &gt; αντικαθιστά το αρχείο εξόδου και ο &gt;&gt; προσθέτει στο τέλος του αρχείου. Μάθετε για τα stdout και stderr. Μάθετε για την επέκταση αρχείων μπαλαντέρ (glob) με * (και ίσως του ? και […]) και τη χρήση εισαγωγικών και τη διαφορά ανάμεσα στα διπλά &quot; και τα μονά &#39; εισαγωγικά. (Δείτε περισσότερα για την επέκταση μεταβλητών παρακάτω.) Εξοικειωθείτε με τη διαχείριση εργασιών στον Bash: &amp;, ctrl-z, ctrl-c, jobs, fg, bg, kill κλπ. Να γνωρίζετε την εντολή ssh και τα βασικά της αυθεντικοποίησης χωρίς κωδικό με χρήση των ssh-agent, ssh-add κλπ. Βασική διαχείριση αρχείων: ls και ls -l (συγκεκριμένα, μάθετε τι σημαίνει κάθε στήλη που εμφανίζει η ls -l), less, head, tail και tail -f (ή ακόμη καλύτερα, less +F), ln και ln -s (μάθετε τις διαφορές και τα πλεονεκτήματα των κανονικών συνδέσμων σε σύγκριση με τους συμβολικούς), chown, chmod, du (για μία γρήγορη περίληψη της χρήσης του δίσκου: du -hs *). Για διαχείριση του συστήματος αρχείων, df, mount, fdisk, mkfs, lsblk. Μάθετε τι είναι inode (ls -i ή df -i). Βασική διαχείριση δικτύου: ip ή ifconfig, dig, traceroute, route. Μάθετε και χρησιμοποιήστε ένα σύστημα διαχείρισης και ελέγχου εκδόσεων, όπως το git. Να γνωρίζετε καλά κανονικές εκφράσεις και τις διάφορες επιλογές (flags) για τις grep/egrep. Τις επιλογές -i, -o, -v, -A, -Bκαι -C αξίζει να τις γνωρίζετε. Μάθετε να χρησιμοποιείτε τις εντολές apt-get, yum, dnf ή pacman (ανάλογα με τη διανομή του λειτουργικού σας συστήματος) για να βρίσκετε και να εγκαθιστάτε πακέτα λογισμικού. Και βεβαιωθείτε ότι έχετε την pip για να εγκαθιστάτε εργαλεία της γραμμής εντολών που βασίζονται σε Python (μερικά από τα παρακάτω είναι πιο εύκολο να εγκατασταθούν με pip). Καθημερινή χρήση Στον Bash, χρησιμοποιήστε Tab για να ολοκληρώσετε ορίσματα ή να εμφανίσετε σε λίστα όλες τις διαθέσιμες εντολές, ctrl-r για να αναζητήσετε στο ιστορικό των εντολών (αφού πατήσετε, πληκτρολογήστε για να αναζητήσετε, πατήστε ctrl-r επαναλαμβανόμενα για να περιηγηθείτε σε περισσότερα αποτελέσματα αναζήτησης, πατήστε Enter για να εκτελέσετε την εντολή που βρήκατε ή πατήστε το δεξί βέλος για να μεταφέρετε το αποτέλεσμα στην τρέχουσα γραμμή ώστε να μπορείτε να το επεξεργαστείτε). Στον Bash, χρησιμοποιήστε ctrl-w για να διαγράψετε την τελευταία λέξη και ctrl-u για να διαγράψετε το περιεχόμενο από την τρέχουσα θέση του δρομέα μέχρι την αρχή της γραμμής. Χρησιμοποιήστε alt-b και alt-f για να μετακινηθείτε κατά μια λέξη, ctrl-a για να μετακινήσετε τον δρομέα στην αρχή της γραμμής, ctrl-e για να μετακινήσετε τον δρομέα στο τέλος της γραμμής, ctrl-k για να διαγράψετε ως το τέλος της γραμμής, ctrl-l για να καθαρίσετε την οθόνη. Δείτε τη man readline για όλες τις συντομεύσεις πληκτρολογίου στον Bash. Υπάρχουν πολλές. Για παράδειγμα, η alt-. επαναλαμβάνει κυκλικά τα προηγούμενα ορίσματα και η alt- αναπτύσσει ένα μπαλαντέρ (glob). Εναλλακτικά, αν σας αρέσουν οι συντομεύσεις τύπου vi, χρησιμοποιήστε set -o vi (και set -o emacs για να επαναφέρετε). Για την επεξεργασία μεγάλων εντολών, αφού ορίσετε τις ρυθμίσεις του επεξεργαστή κειμένου σας (για παράδειγμα export EDITOR=vim), με ctrl-x ctrl-e θα ανοίξει η τρέχουσα εντολή σε έναν επεξεργαστή κειμένου για επεξεργασία πολλών γραμμών. Ή αν έχετε ορίσει συντομεύσεις τύπου vi, escape-v. Για να δείτε πρόσφατες εντολές χρησιμοποιήστε την εντολή history. Ακολουθήστε την με την εντολή !n (όπου n είναι ο αριθμός της εντολής) για να την εκτελέσετε ξανά. Υπάρχουν πάρα πολλές συντομεύσεις που μπορείτε να χρησιμοποιήσετε. Από αυτές οι πιο χρήσιμες μάλλον είναι η !$ για την τελευταία παράμετρο και η !! για την τελευταία εντολή (δείτε το “HISTORY EXPANSION” στην τεκμηρίωση του φλοιού). Όμως, αυτές συχνά εύκολα αντικαθίστανται από ctrl-r και alt-.. Πηγαίνετε στον προσωπικό σας κατάλογο (home) με cd. Αποκτήστε πρόσβαση σε αρχεία που βρίσκονται σε σχετική θέση με τον προσωπικό κατάλογό σας με το πρόθεμα ~ (π.χ. ~/.bashrc). Σε σενάριο sh μπορείτε να αναφέρεστε στον προσωπικό σας κατάλογο ως $HOME. Για να πάτε στον προηγούμενο κατάλογο όπου εργαζόσαστε: cd -. Αν έχετε γράψει μέχρι τη μέση μία εντολή, αλλά αλλάξατε γνώμη, πατήστε alt-# για να προσθέσετε ένα# στην αρχή και να την προσθέσετε ως ένα σχόλιο (ή χρησιμοποιήστε ctrl-a, #, enter). Μπορείτε να επιστρέψετε σε αυτή αργότερα με το ιστορικό εντολών. Χρησιμοποιήστε xargs (ή parallel). Έχει πολλές δυνατότητες. Σημειώστε ότι μπορείτε να ελέγξετε πόσα στοιχεία θα εκτελέσετε ανά γραμμή (-L) καθώς και παράλληλη εκτέλεση εντολών (-P). Αν δεν είστε σίγουρος ότι θα κάνει το σωστό, χρησιμοποιήστε πρώτα xargs echo. Επίσης, η επιλογή -I{} είναι χρήσιμη. Παραδείγματα: 12find . -name '*.py' | xargs grep some_functioncat hosts | xargs -I&#123;&#125; ssh root@&#123;&#125; hostname pstree -p είναι μία χρήσιμη εμφάνιση του δέντρου διεργασιών. Χρησιμοποιήστε pgrep και pkill για να αναζητήσετε ή να στείλετε σήμα σε διεργασίες με βάση το όνομά τους (η επιλογή -f είναι χρήσιμη). Να γνωρίζετε τα διάφορα σήματα που μπορείτε να στείλετε σε διεργασίες. Για παράδειγμα, για να αναστείλετε μία διεργασία χρησιμοποιήστε kill -STOP [pid]. Για ολόκληρη τη λίστα, δείτε man 7 signal Χρησιμοποιήστε nohup ή disown, αν θέλετε μία διεργασία παρασκηνίου να συνεχίσει να εκτελείται για πάντα. Ελέγξτε ποιες διεργασίες είναι σε αναμονή για κλήση listen με netstat -lntp ή ss -plat (για TCP· προσθέστε -u για UDP) ή lsof -iTCP -sTCP:LISTEN -P -n (που δουλεύει επίσης σε OS X). Δείτε επίσης lsof και fuser για ανοιχτές συνδέσεις δικτύου (sockets) και αρχεία. Δείτε uptime ή w για να δείτε για πόσο το σύστημα βρίσκεται σε λειτουργία. Χρησιμοποιήστε alias για να δημιουργήσετε συντομεύσεις για συχνά χρησιμοποιούμενες εντολές. Για παράδειγμα, η alias ll=&#39;ls -latr&#39; δημιουργεί μία νέα συντόμευση ll. Αποθηκεύστε συντομεύσεις, ρυθμίσεις φλοιού και μεθόδους που χρησιμοποιείτε συχνά στο ~/.bashrcκαι προβλέψτε ώστε οι login φλοιοί να τα διαβάζουν. Αυτό θα κάνει τις ρυθμίσεις σας διαθέσιμες κάθε φορά που χρησιμοποιείτε τον φλοιό. Βάλτε τις ρυθμίσεις των μεταβλητών περιβάλλοντος καθώς και τις εντολές που χρειάζεται να εκτελεστούν με την είσοδό σας στο ~/.bash_profile. Ξεχωριστές ρυθμίσεις θα χρειαστούν για τους φλοιούς που εκτελούνται από είσοδο από γραφικό περιβάλλον και εργασίες cron. Συγχρονίστε τα αρχεία με τις ρυθμίσεις σας (π.χ. .bashrc και .bash_profile) μεταξύ διαφορετικών υπολογιστών χρησιμοποιώντας Git. Κατανοήστε ότι χρειάζεται προσοχή, όταν μεταβλητές και ονόματα αρχείων περιέχουν κενούς (whitespace) χαρακτήρες. Περικλείετε τις μεταβλητές του Bash σε εισαγωγικά, π.χ. &quot;$FOO&quot;. Προτιμήστε τις επιλογές -0 ή -print0 για να επιτρέψετε σε κενούς χαρακτήρες να διαχωρίζουν ονόματα αρχείων, π.χ. locate -0 pattern | xargs -0 ls -al ή find / -print0 -type d | xargs -0 ls -al. Για να περάσετε ένα προς ένα από όλα τα αρχεία που περιέχουν κενούς χαρακτήρες σε έναν βρόχο επανάληψης for, ορίστε τη μεταβλητή IFS να είναι ο χαρακτήρας νέας γραμμής χρησιμοποιώντας IFS=$&#39;\n&#39;. Σε σενάρια για Bash, χρησιμοποιήστε set -x (ή την παραλλαγή set -v, που γράφει τα πρωτογενή στοιχεία, όπως σχόλια και μεταβλητές πριν αντικατασταθούν) για να τα αποσφαλματώσετε. Χρησιμοποιείτε αυστηρές λειτουργίες (strict modes) εκτός κι αν έχετε σημαντικό λόγο να μην το κάνετε: Χρησιμοποιήστε set -e για να εγκαταλείψετε την εκτέλεση σε περίπτωση σφάλματος (μη μηδενικός κωδικός εξόδου). Χρησιμοποιήστε set -u για να ανιχνεύσετε τη χρήση μεταβλητών χωρίς τιμή. Έχετε υπόψη σας και την εντολή set -o pipefail, για να εμφανίσετε τα σφάλματα που προκύπτουν στο ενδιάμεσο σωληνώσεων εντολών (αλλά διαβάστε περισσότερο για αυτή, αν τη χρησιμοποιήσετε καθώς αυτό το θέμα είναι ιδιαίτερα λεπτό). Για πιο πολύπλοκα σενάρια, χρησιμοποιήστε επίσης την εντολή trap για κωδικούς εξόδου EXIT ή ERR. Μια χρήσιμη συνήθεια είναι να ξεκινάτε ένα σενάριο έτσι, κάνοντάς το να ανιχνεύει και να τερματίζει σε συνήθη σφάλματα και να τυπώνει ένα μήνυμα: 12set -euo pipefailtrap "echo 'error: Script failed: see failed command above'" ERR Σε σενάρια για Bash, οι υποφλοιοί (γραμμένοι μέσα σε παρενθέσεις) είναι βολικοί τρόποι ομαδοποίησης εντολών. Ένα συνηθισμένο παράδειγμα είναι η προσωρινή μετακίνηση σε διαφορετικό τρέχοντα κατάλογο, π.χ. 123# do something in current dir(cd /some/other/dir &amp;&amp; other-command)# continue in original dir Στον Bash, σημειώστε ότι υπάρχουν πολλοί τρόποι επέκτασης μίας μεταβλητής. Έλεγχος του αν μία μεταβλητή υπάρχει: ${name:?error message}. Για παράδειγμα, αν ένα σενάριο Bash παίρνει ένα μόνο όρισμα, απλά γράψτε input_file=${1:?usage: $0 input_file}. Χρήση μίας προεπιλεγμένης τιμής αν μία μεταβλητή είναι κενή: ${name:-default}. Αν θέλετε να προσθέσετε μία επιπλέον (προαιρετική) παράμετρο στο προηγούμενο παράδειγμα, μπορείτε να χρησιμοποιήσετε κάτι όπως: output_file=${2:-logfile}. Αν η $2 παραλείπεται και άρα είναι κενή, η τιμή της output_file θα είναι logfile. Αριθμητική επέκταση: i=$(( (i + 1) % 5 )). Ακολουθίες: {1..10}. Περικοπή αλφαριθμητικών: ${var%suffix} και ${var#prefix}. Για παράδειγμα, αν var=foo.pdf, τότε η echo ${var%.pdf}.txt τυπώνει foo.txt. Η επέκταση με αγκύλες χρησιμοποιώντας {…} μπορεί να μειώσει τις φορές που χρειάζεται να πληκτρολογήσετε ξανά παρόμοιο κείμενο και να αυτοματοποιήσει συνδυασμούς στοιχείων. Αυτό είναι χρήσιμο σε παραδείγματα όπως mv foo.{txt,pdf} some-dir (που μετακινεί και τα δύο αρχεία), cp somefile{,.bak} (που επεκτείνεται σε cp somefile somefile.bak) ή mkdir -p test-{a,b,c}/subtest-{1,2,3} (που επεκτείνεται σε όλους τους πιθανούς συνδυασμούς και δημιουργεί ένα δέντρο καταλόγων). Η επέκταση με αγκύλες πραγματοποιείται πριν από οποιαδήποτε άλλη επέκταση. Η σειρά των επεκτάσεων είναι: επέκταση με αγκύλες· επέκταση περισπωμένης, επέκταση παραμέτρων και μεταβλητών, αριθμητική επέκταση και αντικατάσταση εντολής (γίνεται από τα αριστερά προς τα δεξιά)· χωρισμός λέξεων· και επέκταση ονομάτων αρχείων. Για παράδειγμα, ένα εύρος τιμών όπως {1..20} δεν μπορεί να εκφραστεί με μεταβλητές χρησιμοποιώντας {$a..$b}. Χρησιμοποιήστε αντί μεταβλητών την εντολή seq ή μία δομή επανάληψης for, π.χ. seq $a $b ή for((i=a; i&lt;=b; i++)); do ... ; done.) Μπορείτε να χειριστείτε την έξοδο μίας εντολής ως αρχείο &lt;(some command) (είναι γνωστό ως αντικατάσταση διεργασίας). Για παράδειγμα, συγκρίνετε το τοπικό /etc/hosts με ένα απομακρυσμένο: 1diff /etc/hosts &lt;(ssh somehost cat /etc/hosts) Όταν γράφετε σενάρια, ίσως θέλετε να βάλετε όλον σας τον κώδικα μέσα σε άγκριστρα. Αν το δεξί άγκιστρο λείπει, το σενάριό σας δε θα εκτελεστεί λόγω συντακτικού σφάλματος. Αυτό είναι σκόπιμο, όταν το σενάριό σας πρόκειται να μεταφορτωθεί από το διαδίκτυο, αφού έτσι εμποδίζεται η εκτέλεση σεναρίων που έχουν μερικώς ληφθεί: 123&#123; # Your code here&#125; Να γνωρίζετε για το «here documents» στον Bash, όπως στην cat &lt;&lt;EOF .... Στον Bash, ανακατευθύνετε τόσο την έξοδο όσο και την έξοδο σφαλμάτων ως εξής: some-command &gt;logfile 2&gt;&amp;1 ή some-command &amp;&gt;logfile. Συχνά για να βεβαιωθείτε ότι μία εντολή δεν αφήνει μια σύνδεση αρχείου ανοιχτή στην είσοδο, δεσμεύοντας τον στο τερματικό που βρίσκεστε, είναι μία καλή πρακτική να προσθέτετε &lt;/dev/null. Χρησιμοποιήστε man ascii για έναν καλό πίνακα ASCII, με δεξαεξαδικές και δεκαδικές τιμές. Για γενικές πληροφορίες που αφορούν την κωδικοποίηση, οι man unicode, man utf-8 και man latin1είναι χρήσιμες. Χρησιμοποιήστε screen ή tmux για να ενεργοποιήσετε την πολυπλεξία της οθόνης. Αυτό είναι ιδιαίτερα χρήσιμο σε απομακρυσμένες συνεδρίες ssh και για να διακόψετε ή να επαναφέρετε μια συνεδρία. H εντολή byobu ή tmux μπορεί να βελτιώσει την οθόνη παρέχοντας περισσότερες πληροφορίες και πιο εύκολη διαχείριση. Μία πιο απλή εναλλακτική μόνο για τη διατήρηση συνεδριών είναι η dtach. Με ssh, το να γνωρίζετε πώς να προωθήσετε μία θύρα με τις επιλογές -L ή -D (και καμιά φορά με την -R) είναι χρήσιμο, π.χ. για να έχετε πρόσβαση σε ιστοσελίδες από έναν απομακρυσμένο server. Μπορεί να είναι χρήσιμο να κάνετε μερικές βελτιστοποιήσεις στις ssh ρυθμίσεις σας· για παράδειγμα, αυτό ~/.ssh/config περιέχει ρυθμίσεις για να αποφεύγετε τις συνδέσεις που διακόπτονται σε ορισμένα περιβάλλοντα δικτύου, χρησιμοποιεί συμπίεση (που είναι χρήσιμη με scp σε συνδέσεις με περιορισμένο εύρος ζώνης) και πολύπλεξη καναλιών στον ίδιο server με τοπικό αρχείο έλέγχου: 1234567TCPKeepAlive=yesServerAliveInterval=15ServerAliveCountMax=6Compression=yesControlMaster autoControlPath /tmp/%r@%h:%pControlPersist yes Μερικές άλλες επιλογές σχετικές με την ssh είναι ευαίσθητες όσον αφορά την ασφάλεια και θα πρέπει να ενεργοποιούνται με προσοχή, π.χ. ανά υποδίκτυο ή host ή σε έμπιστα δίκτυα: StrictHostKeyChecking=no, ForwardAgent=yes ´Εχετε υπόψη σας την εντολή mosh ως μία εναλλακτική της ssh που χρησιμοποιεί UDP, αποφεύγοντας τις συνδέσεις που διακόπτονται και διευκολύνοντας τη διαδικασία (απαιτεί ρύθμιση στον server). Για να πάρετε τα δικαιώματα ενός αρχείου σε οκταδική μορφή, πράγμα που είναι χρήσιμο για την παραμετροποίηση του συστήματος, αλλά δεν είναι διαθέσιμο με την ls και είναι εύκολο να γίνει άτσαλα, χρησιμοποιήστε κάτι όπως 1stat -c '%A %a %n' /etc/timezone Για διαδραστική επιλογή τιμών από την έξοδο μίας άλλης εντολής, χρησιμοποιήστε percol ή fzf. Για επιλογή αρχείων με βάση την έξοδο μιας άλλη εντολής (όπως της git), χρησιμοποιήστε fpp (PathPicker). Για έναν απλό web server και για όλα τα αρχεία στον τρέχοντα κατάλογο (και υποκαταλόγους) διαθέσιμα σε οποιονδήποτε στο δίκτυο, χρησιμοποιήστε:python -m SimpleHTTPServer 7777 (για τη θύρα 7777 και Python 2) και python -m http.server 7777 (για τη θύρα 7777 και Python 3). Για την εκτέλεση μίας εντολής ως άλλος χρήστης, χρησιμοποιήστε sudo. Από προεπιλογή εκτελείται ως root· χρησιμοποιήστε -u για να ορίσετε άλλον χρήστη. Χρησιμοποιήστε -i για να συνδεθείτε ως αυτός ο χρήστης. (Μπορεί να σας ζητηθεί το συνθηματικό σας.) Για να αλλάξετε τον φλοιό σε άλλον χρήστη, χρησιμοποιήστε su username ή su - username. Το τελευταίο με “-“ φορτώνει το περιβάλλον με τον ίδιο τρόπο όπως αν μόλις συνδεόταν ένας άλλος χρήστης. Παραλείποντας το username χρησιμοποιείτε την προεπιλογή root. Αν δεν είστε root, θα σας ζητηθεί το συνθηματικό. Έχετε υπόψη σας τον περιορισμό των 128K για τις γραμμές εντολών. Το σφάλμα «Η λίστα των ορισμάτων είναι πολύ μεγάλη» είναι κοινό, όταν γίνεται ταίριασμα με χαρακτήρα wildcard ενάντι μεγάλου αριθμού αρχείων. (Όταν συμβαίνει αυτό, εναλλακτικές όπως οι find και xargs μπορεί να βοηθήσουν.) Για να κάνετε μια απλή πράξη αριθμητικής (και βέβαια γενικά για πρόσβαση σε Python), χρησιμοποιήστε τον διερμηνευτή python. Για παράδειγμα, 12&gt;&gt;&gt; 2+35 Επεξεργασία αρχείων και δεδομένων Για να εντοπίσετε ένα αρχείο με βάση το όνομά του στον τρέχοντα κατάλογο, find . -iname &#39;*something*&#39; (ή με παρόμοιο τρόπο). Για να βρείτε ένα αρχείο με το όνομά του οπουδήποτε, χρησιμοποιήστε locate something (αλλά να έχετε στον νου σας ότι η updatedb μπορεί να μην έχει δημιουργήσει ευρετήριο για αρχεία που δημιουργήθηκαν πρόσφατα). Για γενική αναζήτηση σε αρχεία πηγαίου κώδικα ή αρχεία δεδομένων, υπάρχουν αρκετές επιλογές πιο προχωρημένες ή γρήγορες από την grep -r, συμπεριλαμβανομένων (και κατά προσέγγιση ταξινομημένων από την πιο παλιά στη νεότερη) των ack, ag (“the silver searcher”), και rg (ripgrep). Για να μετατρέψετε HTML σε κείμενο: lynx -dump -stdin Για Markdown, HTML και άλλου είδους μετατροπές κειμένου, δοκιμάστε pandoc. Αν χρειάζεται να χειριστείτε XML, η xmlstarlet είναι παλιά αλλά καλή. Για JSON, χρησιμοποιήστε jq. Για διαδραστική χρήση, δείτε επίσης jid και jiq. Για YAML, χρησιμοποιήστε shyaml. Για αρχεία Excel ή CSV, το πακέτο csvkit παρέχει τις in2csv, csvcut, csvjoin, csvgrep κλπ. Για Amazon S3, η s3cmd είναι βολική και η s4cmd είναι γρηγορότερη. Η aws της Amazon και η βελτιωμένη saws είναι απαραίτητες για εργασίες που σχετίζονται με AWS. Να γνωρίζετε για τις sort και uniq, συμπεριλαμβανομένων των επιλογών -u και -d της uniq – παρακάτω δείτε το κομμάτι που αφορά τις εντολές σε μία γραμμή. Δείτε επίσης την comm. Να γνωρίζετε για τις cut, paste και join για να χειρίζεστε αρχεία κειμένου. Πολλοί χρησιμοποιούν την cut, αλλά ξεχνούν την join. Να γνωρίζετε για τη wc για να μετράτε νέες γραμμές (-l), χαρακτήρες (-m), λέξεις (-w) και bytes (-c). Να γνωρίζετε για την tee για να αντιγράφετε από το stdin σε ένα αρχείο κι επίσης στο stdout, όπως στην ls -al | tee file.txt. Για πιο πολύπλοκους υπολογισμούς, όπως ομαδοποίηση, αναστροφή πεδίων και στατιστικούς υπολογισμούς, έχετε υπόψη σας την εντολή datamash. Να γνωρίζετε ότι η τοπική διαμόρφωση του συστήματος (locale, π.χ. ελληνικό) επηρεάζει πολλά εργαλεία γραμμής εντολών με λιγότερο προφανείς τρόπους, συμπεριλαμβανομένων της σειράς ταξινόμησης (collation) και της απόδοσης. Οι περισσότερες εγκαταστάσεις Linux θα έχουν αναθέσει στη μεταβλητή LANG ή σε άλλες σχετικές με locale μεταβλητές τιμή μιας τοπική ρύθμισης όπως η Αγγλική ΗΠΑ. Αλλά να έχετε υπόψη ότι η ταξινόμηση μπορεί να αλλάξει, αν θέσετε άλλο locale. Και να γνωρίζετε ότι οι διεθνοποιημένες ρουτίνες μπορούν να κάνουν την ταξινόμηση ή άλλες εντολές να εκτελούνται πολλές φορές πιο αργά. Σε μερικές περιπτώσεις (όπως στον ορισμό διεργασιών ή της μοναδικότητας διεργασιών παρακάτω) μπορείτε με ασφάλεια να αγνοήσετε εντελώς αργές διεθνοποιημένες ρουτίνες και να χρησιμοποιήσετε παραδοσιακή ταξινόμηση με βάση bytes, χρησιμοποιώντας export LC_ALL=C. Μπορείτε να ορίσετε ένα συγκεκριμένο περιβάλλον για μία εντολή προσθέτοντάς της ως πρόθεμα τις ρυθμίσεις της μεταβλητής περιβάλλοντος, όπως στην TZ=Pacific/Fiji date. Να γνωρίζετε τα βασικά για τις awk και sed για απλή επεξεργασία δεδομένων. Δείτε Εντολές σε μία γραμμή για παραδείγματα. Για να αντικαταστήσετε επί τόπου όλες τις εμφανίσεις ενός αλφαριθμητικού σε ένα ή περισσότερα αρχεία: 1perl -pi.bak -e 's/old-string/new-string/g' my-files-*.txt Για να μετονομάσετε πολλά και/ή να αναζητήσετε και να αντικαταστήσετε σε αρχεία, δοκιμάστε την repren. (Σε ορισμένες περιπτώσεις η εντολή rename επιτρέπει επίσης πολλαπλές μετονομασίες, αλλά να είστε προσεχτικοί καθώς δε συμπεριφέρεται με τον ίδιο τρόπο σε όλες τις διανομές Linux.) 123456# Full rename of filenames, directories, and contents foo -&gt; bar:repren --full --preserve-case --from foo --to bar .# Recover backup files whatever.bak -&gt; whatever:repren --renames --from '(.*)\.bak' --to '\1' *.bak# Same as above, using rename, if available:rename 's/\.bak$//' *.bak Όπως λέει η σελίδα man, η rsync είναι πράγματι ένα γρήγορο και εξαιρετικά ευέλικτο εργαλείο αντιγραφής αρχείων. Είναι γνωστή για τον συγχρονισμό μεταξύ υπολογιστών, αλλά είναι εξίσου χρήσιμη και τοπικά. Όταν οι περιορισμοί ασφάλειας το επιτρέπουν, η χρήση της rsync αντί της scp επιτρέπει τη συνέχιση μιας μεταφοράς χωρίς να ξεκινήσει από την αρχή. Επίσης, είναι ανάμεσα στους πιο γρήγορους τρόπους να διαγράψει κανείς μεγάλο αριθμό αρχείων: 1mkdir empty &amp;&amp; rsync -r --delete empty/ some-dir &amp;&amp; rmdir some-dir Για να παρακολουθείτε την πρόοδο όταν αντιγράφετε αρχεία, χρησιμοποιήστε τις pv, pycp, progress, rsync --progress, ή για αντιγραφή σε επίπεδο μπλοκ την dd status=progress. Χρησιμοποιήστε την shuf για να ανακατέψετε ή να επιλέξετε τυχαίες γραμμές από ένα αρχείο. Να γνωρίζετε τις επιλογές της sort. Για αριθμούς χρησιμοποιήστε τις -n, ή -h για χειρισμό αριθμών που είναι εύκολο να διαβαστούν από άνθρωπο (π.χ. από du -h). Να γνωρίζετε πώς λειτουργούν τα ορίσματα (-t και -k). Συγκεκριμένα, προσέξτε ότι χρειάζεται να γράψετε -k1,1 για να ταξινομήσετε με βάση μόνο το πρώτο πεδίο· -k1 σημαίνει ταξινόμηση με βάση όλη τη γραμμή. Η σταθερή ταξινόμηση (sort -s) μπορεί να είναι χρήσιμη. Για παράδειγμα, για να ταξινομήσετε πρώτα με βάση το πεδίο 2 και δευτερευόντως με βάση το πεδίο 1, μπορείτε να χρησιμοποιήσετε sort -k1,1 | sort -s -k2,2. Αν πότε χρειαστεί να γράψετε έναν χαρακτήρα στηλοθέτη (tab) στη γραμμή εντολών στον Bash (π.χ. για να ταξινομήσετε με βάση το όρισμα της επιλογής -t), πιέστε ctrl-v [Tab] ή γράψτε $&#39;\t&#39; (το τελευταίο είναι καλύτερο, γιατί μπορείτε να το αντιγράψετε/επικολλήσετε). Τα συνήθη εργαλεία αυτοματοποιημένης επεξεργασίας αλλαγών (patch) πηγαίου κώδικα είναι οι εντολές diff (εμφάνιση διαφορών) και patch (εφαρμογή διαφορών σε άλλο αρχείο). Επίσης, δείτε την diffstat για περίληψη στατιστικών στοιχείων της εντολής diff και sdiff για εμφάνιση διαφορών πλάι-πλάι. Σημειώστε ότι η diff -r λειτουργεί για ολόκληρους καταλόγους. Χρησιμοποιήστε την diff -r tree1 tree2 | diffstat για μια περίληψη αλλαγών. Χρησιμοποιήστε την vimdiff για να συγκρίνετε και να επεξεργαστείτε αρχεία μέσω της διεπαφής του vim. Για δυαδικά αρχεία, χρησιμοποιήστε τις hd, hexdump ή την xxd για απλά δεκαεξαδικά dumps και τις bvi, hexedit ή biew για επεξεργασία σε δυαδική μορφή. Επίσης, για δυαδικά αρχεία η strings (και η grep κλπ.) σας δίνει τη δυνατότητα να βρείτε κομματάκια κειμένου που κρύβονται σ’ αυτά. Για δυαδικές διαφορές (συμπίεση δέλτα), χρησιμοποιήστε xdelta3. Για να μετατρέψετε κωδικοποίηση κειμένου, δοκιμάστε την iconv. Ή uconv για πιο προχωρημένη χρήση· υποστηρίζει πιο προχωρημένα στοιχεία του προτύπου Unicode. Για παράδειγμα:: 12345# Εμφανίζει τους δεκαεξαδικούς κωδικούς ή πραγματικά ονόματα χαρακτήρων (χρήσιμο για αποσφαλμάτωση):uconv -f utf-8 -t utf-8 -x '::Any-Hex;' &lt; input.txtuconv -f utf-8 -t utf-8 -x '::Any-Name;' &lt; input.txt# Mετατρέπει σε πεζούς χαρακτήρες και απαλείφει τους τόνους (επεκτείνοντας και απορρίπτοντάς τους):uconv -f utf-8 -t utf-8 -x '::Any-Lower; ::Any-NFD; [:Nonspacing Mark:] &gt;; ::Any-NFC; ' &lt; input.txt &gt; output.txt Για να σπάσετε αρχεία σε κομμάτια, δείτε τη split (για να σπάσετε με βάση το μέγεθος) και τη csplit (για να σπάσετε με βάση πρότυπο). Ημερομηνία και ώρα: Για να πάρετε την τρέχουσα ημερομηνία και ώρα στη χρήσιμη μορφή ISO 8601, χρησιμοποιήστε date -u +&quot;%Y-%m-%dT%H:%M:%SZ&quot; (άλλες επιλογές είναι προβληματικές). Για να χειριστείτε εκφράσεις ημερομηνίας και χρόνου, χρησιμοποιήστε τις εντολές dateadd, datediff, strptime κλπ. από το πακέτο dateutils. Χρησιμοποιήστε zless, zmore, zcatκαι zgrep για να χειριστείτε συμπιεσμένα αρχεία. Ιδιότητες αρχείων μπορούν να οριστούν με την chattr και προσφέρει μία εναλλακτική για τα δικαιώματα των αρχείων σε χαμηλό επίπεδο. Για παράδειγμα, για να προστατευτείτε από κατά λάθος διαγραφή αρχείου χρησιμοποιήστε την επιλογή immutable: sudo chattr +i /critical/directory/or/file Χρησιμοποιήστε τις getfacl και setfacl για να αποθηκεύσετε και να επαναφέρετε δικαιώματα αρχείων. Για παράδειγμα: 12getfacl -R /some/path &gt; permissions.txtsetfacl --restore=permissions.txt Για να δημιουργήσετε άδεια αρχεία γρήγορα, χρηρσιμοποιήστε την truncate (δημιουργεί αραιό αρχείο), τη fallocate (ext4, xfs, btrfs και ocfs2 συστήματα αρχείων), την xfs_mkfile (σχεδόν για κάθε σύστημα αρχείων, περιλαμβάνεται στο πακέτο xfsprogs), τη mkfile (για συστήματα τύπου Unix όπως Solaris, Mac OS). Αποσφαλμάτωση συστήματος Για web αποσφαλμάτωση, οι εντολές curl και curl -I είναι χρήσιμες, ή οι ισοδύναμες wget, ή η πιο καινούρια httpie. Για να γνωρίζετε την τρέχουσα κατάσταση του επεξεργαστή και των δίσκων, τα κλασικά εργαλεία είναι η top (ή η καλύτερη htop), η iostatκαι η iotop. Χρησιμοποιήστε την iostat -mxz 15 για βασικά στατιστικά που αφορούν τον επεξεργαστή ή για λεπτομερή στατιστικά των δίσκων ανά διαμέρισμα και για να έχετε μια εικόνα της απόδοσης. Για λεπτομέρειες που αφορούν τη σύνδεση δικτύου, χρησιμοποιήστε τη netstat και την ss. Για μια γρήγορη επισκόπηση του τι συμβαίνει σε ένα σύστημα, η dstat είναι ιδιαίτερα χρήσιμη. Για καλύτερη επισκόπηση με λεπτομέρειες, χρησιμοποιήστε glances. Για να γνωρίζετε την κατάσταση της μνήμης, εκτελέστε και κατανοήστε την έξοδο των free και vmstat. Συγκεκριμένα, να έχετε υπόψη ότι η «cached» τιμή είναι μνήμη που δεσμεύει ο πυρήνας του Linux ως προσωρινά αποθηκευμένο αρχείο, ώστε στην ουσία προσμετράται ως «free» τιμή. Η αποσφαλμάτωση συστημάτων Java είναι άλλη ιστορία, αλλά ένα απλό κόλπο για το JVM της Oracle και άλλων είναι να τρέξετε την εντολή kill -3 &lt;pid&gt; και ένα πλήρες ίχνος στοίβας και περίληψη σωρού (συμπεριλαμβανομένων και λεπτομερειών που αφορούν τη συλλογή απορριμάτων σε γενιές, που μπορεί να είναι πολύ κατατοπιστικές) θα εμφανιστούν στο stderr/logs. Οι εντολές του JDK jps, jstat, jstack, jmap είναι χρήσιμες. Τα εργαλεία SJK είναι για πιο προχωρημένους. Χρησιμοποιήστε την mtr ως μια βελτίωση της traceroute για να ανιχνεύετε ζητήματα του δικτύου. Για να δείτε γιατί ένας δίσκος είναι γεμάτος, η ncdu εξοικονομεί χρόνο σε σύγκριση με τις συνήθεις εντολές όπως du -sh *. Για να βρείτε ποια δικτυακή σύνδεση ή διεργασία χρησιμοποιεί εύρος ζώνης, δοκιμάστε iftop ή nethogs. Το εργαλείο ab (έρχεται μαζί με Apache) βοηθά στον πρόχειρο έλεγχο της απόδοσης web server. Για πιο σύνθετο έλεγχο φόρτου, δοκιμάστε siege. Για πιο σοβαρή αποσφαλμάτωση δικτύου, wireshark, tshark, ή ngrep. Να γνωρίζετε για τις strace και ltrace. Αυτές μπορεί να φανούν χρήσιμες, όταν ένα πρόγραμμα αποτυγχάνει, παγώνει ή καταρρέει και δε γνωρίζετε γιατί ή αν θέλετε να έχετε μία γενική ιδέα της απόδοσης. Σημειώστε την επιλογή μέτρησης (-c) και τη δυνατότητα να συνδέσετε σε μία διεργασία που εκτελείται (-p). Χρησιμοποιήστε την επιλογή για να παρακολουθείτε τις διεργασίες παιδιά (-f) για να μη χάνετε σημαντικές κλήσεις. Να γνωρίζετε για την ldd ώστε να ελέγχετε διαμοιραζόμενες βιβλιοθήκες κλπ. — αλλά ποτέ να μην την εκτελείτε σε αρχεία που δεν εμπιστεύεστε. Να γνωρίζετε πώς να συνδέεστε σε μία διεργασία που εκτελείται με gdb και να παίρνετε τα ίχνη της στοίβας της. Χρησιμοποιήστε τον κατάλογο /proc. Είναι εκπληκτικά χρήσιμος ορισμένες φορές, όταν αποσφαλματώνετε ζωντανά προβλήματα. Παραδείγματα: /proc/cpuinfo, /proc/meminfo, /proc/cmdline, /proc/xxx/cwd, /proc/xxx/exe, /proc/xxx/fd/, /proc/xxx/smaps (όπου xxx είναι το id της διεργασίας ή pid). Όταν αποσφαλματώνετε κάτι που ήταν λάθος στο παρελθόν, η sar μπορεί να είναι πολύ χρήσιμη. Δείχνει ιστορικά στατιστικά για επεξεργαστή, μνήμη, δίκτυο κλπ. Για πιο εις βάθος ανάλυση συστήματος και απόδοσης, δείτε τις stap (SystemTap), perf και sysdig. Ελέγξτε ποιο είναι το λειτουργικό σύστημά σας με uname ή uname -a (γενικές πληροφορίες Unix/πυρήνα) ή lsb_release -a (πληροφορίες διανομής Linux). Χρησιμοποιήστε την dmesg, όποτε κάτι συμπεριφέρεται πραγματικά παράξενα (μπορεί να έχει να κάνει με υλικό ή με οδηγούς). Αν διαγράψετε ένα αρχείο και δεν απελευθερωθεί ο σύμφωνα με την du αναμενομένος χώρος στον δίσκο, ελέξτε αν το αρχείο χρησιμοποιείται από κάποια διεργασία:lsof | grep deleted | grep &quot;filename-of-my-big-file&quot; Εντολές σε μία γραμμήΜερικά παραδείγματα σωλήνωσης εντολών: Είναι εξαιρετικά βοηθητικό ορισμένες φορές το γεγονός ότι μπορείτε να εφαρμόσετε τις πράξεις της τομής, της ένωσης και της διαφοράς σε αρχεία κειμένου με τις εντολές sort/comm. Έστω ότι a και b είναι ταξινομημένα αρχεία κειμένου. Αυτό είναι γρήγορο και δουλεύει σε αρχεία οποιουδήποτε μεγέθους έως πολλά gigabytes. (H εντολή sort δεν περιορίζεται από τη μνήμη, αν και ίσως χρειαστεί να χρησιμοποιήσετε την επιλογή -T, αν ο /tmp βρίσκεται σε μικρή κατάτμηση (partition). Επίσης, δείτε την παρατήρηση παραπάνω για τη μεταβλητή LC_ALL και την επιλογή -u της εντολής sort (παραλείπεται παρακάτω ώστε να είναι πιο ξεκάθαρο το παράδειγμα). 123sort -mu a b &gt; c # το c είναι a ένωση bcomm -12 a b &gt; c # c είναι a τομή bcomm -23 a b &gt; c # το c είναι η διαφορά του a από το b Χρησιμοποιήστε grep . * για να εξετάσετε γρήγορα το περιεχόμενο όλων των αρχείων ενός καταλόγου (έτσι κάθε γραμμή αρχείου εμφανίζεται σε ζεύγος με το όνομα του αρχείου), ή head -100 * (έτσι κάθε αρχείο έχει μια κεφαλίδα). Αυτό μπορεί να είναι χρήσιμο για καταλόγους γεμάτους με αρχεία ρυθμίσεων όπως αυτά στους καταλόγους /sys, /proc, /etc. Η άθροιση όλων των αριθμών στην τρίτη στήλη ενός αρχείου κειμένου (αυτό είναι μάλλον 3X γρηγορότερο και απαιτεί 3X λιγότερο κώδικα από την αντίστοιχη υλοποίηση σε Python): 1awk '&#123; x += $3 &#125; END &#123; print x &#125;' myfile Για να δείτε μεγέθη/ημερομηνίες σε ένα δέντρο αρχείων, η παρακάτω είναι σα μια αναδρομική ls -l, αλλά είναι πιο ευανάγνωστη από ls -lR: 1find . -type f -ls Έστω ότι έχετε ένα αρχείο κειμένου, όπως το αρχείο καταγραφής (log)/υπ ενός web server και μία συγκεκριμένη τιμή που εμφανίζεται σε μερικές γραμμές, όπως μία παράμετρος acct_id που εμφανίζεται στο URL. Αν θέλετε μια καταμέτρηση του πόσα αιτήματα έγιναν για κάθε acct_id: 1egrep -o 'acct_id=[0-9]+' access.log | cut -d= -f2 | sort | uniq -c | sort -rn Για να παρακολουθείτε συνεχώς αλλαγές, χρησιμοποιήστε watch, π.χ. ελέγξτε αλλαγές σε αρχεία ενός καταλόγου με watch -d -n 2 &#39;ls -rtlh | tail&#39; ή σε ρυθμίσεις δικτύου ενώ επιδιορθώνετε τις ρυθμίσεις wifi με watch -d -n 2 ifconfig. Εκτελέστε αυτή τη μέθοδο για να πάρετε μια τυχαία συμβουλή από αυτό το έγγραφο (αναλύει Markdown και εξάγει ένα στοιχείο): 12345678function taocl() &#123; curl -s https://raw.githubusercontent.com/jlevy/the-art-of-command-line/master/README.md | sed '/cowsay[.]png/d' | pandoc -f markdown -t html | xmlstarlet fo --html --dropdtd | xmlstarlet sel -t -v "(html/body/ul/li[count(p)&gt;0])[$RANDOM mod last()+1]" | xmlstarlet unesc | fmt -80 | iconv -t US&#125; Ασυνήθιστες αλλά χρήσιμες expr: εκτελέστε αριθμητικές και λογικές πράξεις ή εφαρμόζετε κανονικές εκφράσεις m4: απλός μακροεπεξεργαστής yes: τυπώστε ένα αλφαριθμητικό πολλές φορές cal: όμορφο ημερολόγιο env: εκτελέστε μία εντολή (χρήσιμο σε σενάρια) printenv: τυπώστε μεταβλητές περιβάλλοντος (χρήσιμο στην αποσφαλμάτωση και σε σενάρια) look: βρείτε αγγλικές λέξεις (ή γραμμές σε ένα αρχείο) αρχίζοντας με ένα αλφαριθμητικό cut, paste και join: επεξεργασία δεδομένων fmt: μορφοποίηση παραγράφων pr: μορφοποίηση κειμένου σε σελίδες/στήλες fold: τύλιγμα γραμμών κειμένου column: μορφοποίηση πεδίων κειμένου σε στοιχισμένες, σταθερού πλάτους στήλες ή πίνακες tree: εμφανίστε καταλόγους και υποκαταλόγους σε φωλιασμένο δένδρο, όπως η ls αλλά αναδρομική stat: πληροφορίες αρχείου time: εκτελέστε και χρονομετρήστε μία εντολή timeout: εκτελέστε μια εντολή για συγκεκριμένο χρονικό διάστημα και σταμάτησε τη διεργασία, όταν ολοκληρωθεί το χρονικό διάστημα αυτό lockfile: δημιουργήστε αρχεία σημαφόρους που μπορούν να διαγραφούν μόνο με rm -f logrotate: περιστρέψτε, συμπιέστε και στείλτε με ηλ-ταχ αρχεία καταγραφής (logs). watch: εκτελέστε μία εντολή επαναλαμβανόμενα εμφανίζοντας αποτελέσματα ή/και επισημαίνοντας αλλαγές when-changed: εκτελεί όποια εντολή ορίσετε, όποτε βλέπει ότι ένα αρχείο άλλαξε. Δείτε ακόμη τις inotifywait και entr. tac: τυπώστε αρχεία ανεστραμμένα comm: συγκρίνετε ταξινομημένα αρχεία γραμμή προς γραμμή strings: εξάγετε κείμενο από δυαδικά αρχεία tr: μετάφραση χαρακτήρων ή επεξεργασία iconv ή uconv: μετατροπή κωδικοποίησης κειμένου split και csplit: χώρισμα αρχείων sponge: διαβάστε όλη την είσοδο πριν γράψετε σε αυτή, χρήσιμο όταν πρόκειται να διαβάσετε από ένα αρχείο και μετά να γράψετε σε αυτό, π.χ., grep -v something some-file | sponge some-file units: μετατροπές μονάδων και υπολογισμοί· κάνει ό,τι μετατροπές μπορείτε να σκεφτείτε (δείτε επίσης /usr/share/units/definitions.units) apg: δημιουργεί τυχαίους κωδικούς xz: υψηλής αναλογίας συμπίεση αρχείων ldd: πληροφορίες για δυναμικές βιβλιοθήκες nm: σύμβολα από αντικειμενικά αρχεία ab ή wrk: συγκριτική αξιολόγηση web servers strace: αποσφαλμάτωση κλήσης συστήματος mtr: καλύτερο εργαλείο traceroute για αποσφαλμάτωση δικτύου cssh: visual concurrent shell rsync: συγχρονισμός αρχείων και καταλόγων μέσω SSH ή σε τοπικό σύστημα αρχείων wireshark και tshark: συλλογή πακέτων και αποσφαλμάτωση δικτύου ngrep: grep για το επίπεδο δικτύου host και dig: αναζητήσεις DNS lsof: εμφανίστε περιγραφείς αρχείου και πληροφορίες δικτυακών συνδέσεων dstat: χρήσιμα στατιστικά συστήματος glances: υψηλού επιπέδου επισκόπηση πολλαπλών υποσυστημάτων iostat: στατιστικά χρήσης δίσκου mpstat: στατιστικά χρήσης επεξεργαστή vmstat: στατιστικά χρήσης μνήμης htop: βελτιωμένη έκδοση της top last: ιστορικό σύνδεσης (login) w: ποιος συνδέθηκε id: πληροφορίες ταυτότητας χρήστη/ομάδας sar: ιστορικά στατιστικά συστήματος iftop ή nethogs: χρήση δικτύου ανά δικτυακή σύνδεση ή διεργασία ss: στατιστικά ανά δικτυακή σύνδεση dmesg: μηνύματα για σφάλματα κατά την εκκίνηση ή σφάλματα συστήματος sysctl: δείτε και ρυθμίστε τις παραμέτρους του πυρήνα Linux, ενώ εκτελείται hdparm: διαχείριση/απόδοση δίσκου SATA/ATA lsblk: εμφανίστε σε λίστα συσκευές αποθήκευσης: μία προβολή σε δέντρο των δίσκων σας και των διαμερισμάτων τους lshw, lscpu, lspci, lsusb, dmidecode: πληροφορίες υλικού, συμπεριλαμβανομένων επεξεργαστή, BIOS, RAID, γραφικών, συσκευών κλπ. lsmod και modinfo: εμφανίστε σε λίστα και προβάλλετε λεπτομέρειες για λειτουργικές μονάδες του πυρήνα fortune, ddateκαι sl: ε, λοιπόν, εξαρτάται από το αν θεωρείτε τα τρένα με ατμομηχανή και τις ρήσεις του Zippy «χρήσιμα» Μόνο για OS XΤα παρακάτω σημεία σχετίζονται μόνο με OS X. Διαχείριση πακέτων λογισμικού με brew (Homebrew) και/ή port (MacPorts). Μπορούν να χρησιμοποιηθούν για εγκατάσταση σε OS X πολλών από τις παραπάνω εντολές. Αντιγράψτε την έξοδο οποιασδήποτε εντολής σε μια desktop εφαρμογή με pbcopy και επικολλήστε στην είσοδο με pbpaste. Για να ενεργοποιήσετε το πλήκτρο Option σε τερματικό OS X ως πλήκτρο alt (όπως χρησιμοποιείται στις παραπάνω εντολές όπως alt-b, alt-f κλπ.), ανοίξτε Προτιμήσεις -&gt; Προφίλ -&gt; Πληκτρολόγιο και επιλέξτε «Χρήση Option ως μετα-πλήκτρου». Για να ανοίξετε ένα αρχείο με μια desktop εφαρμογή χρησιμοποιήστε open ή open -a /Applications/Whatever.app. Spotlight: Αναζητήστε αρχεία με mdfind και εμφανίστε σε λίστα μεταδεδομένα (όπως τις πληροφορίες EXIF μιας φωτογραφίας) με mdls. Έχετε υπόψη σας ότι το OS X βασίζεται σε BSD Unix και πολλές εντολές (για παράδειγμα ps, ls, tail, awk, sed) έχουν μικρές διαφορές από το Linux, που έχει ευρέως επηρεαστεί από το System V-style Unix και τα εργαλεία GNU. Συνήθως μπορείτε να βρίσκετε τη διαφορά επισημαίνοντας ότι μια man σελίδα έχει την επικεφαλίδα «Εγχειρίδιο γενικών εντολών BSD». Σε ορισμένες περιπτώσεις μπορούν επίσης να εγκατασταθούν εκδόσεις GNU, (όπως οι gawk και gsed για τις GNU awk και sed). Αν γράφετε σενάρια Bash που στοχεύετε να εκτελούνται σε διάφορες πλατφόρμες, αποφύγετε τέτοιες εντολές (για παράδειγμα, έχετε υπόψη σας την Python ή perl) ή ελέγξτε προσεχτικά. Για να πάρετε πληροφορίες για την έκδοση OS X χρησιμοποιήστε sw_vers. Μόνο για WindowsΤα παρακάτω σημεία σχετίζονται μόνο με Windows. Πρόσβαση στα εργαλεία του Unix από Windows Αποκτήστε πρόσβαση στη δύναμη του φλοιού του Unix σε περιβάλλον Microsoft Windows εγκαθιστώντας το Cygwin. Τα περισσότερα από αυτά που περιγράφονται σε αυτό το έγγραφο θα λειτουργήσουν μεμιάς. Σε Windows 10, μπορείτε να χρησιμοποιήσετε το Bash σε Ubuntu για Windows, το οποίο παρέχει ένα περιβάλλον παρόμοιο με του Bash με εργαλεία γραμμής εντολών Unix. Έχει το πλεονέκτημα ότι επιτρέπει σε προγράμματα Linux να εκτελεστούν σε Windows. Από την άλλη πλευρά, σε αντίθεση με το περιβάλλον Cygwin, δεν επιτρέπει την εκτέλεση προγραμμάτων Windows από τη γραμμή εντολών του Bash. Αν σας ενδιαφέρει κυρίως η χρήση των εργαλείων ανάπτυξης GNU (όπως ο μεταγλωττιστής GCC) σε Windows, σκεφτείτε τη χρήση των MinGW και MSYS, τα οποία παρέχουν εργαλεία όπως bash, gawk, make και grep. Το MSYS δεν υποστηρίζει όμως όλες τις δυνατότητες του Cygwin. Το MinGW είναι κυρίως χρήσιμο για να δημιουργήσετε εγγενείς εκδόσεις Windows εργαλείων του Unix. Μια άλλη επιλογή για να έχετε εντολές Unix κάτω από Windows είναι το σύστημα Cash. Αυτό όμως υποστηρίζει πολύ λίγες εντολές και επιλογές του Unix. Χρήσιμα εργαλεία της γραμμής εντολών Windows Μπορείτε να εκτελέσετε και να γράψετε scripts για τις περισσότερες εργασίες διαχείρισης συστήματος των Windows από τη γραμμή εντολών μαθαίνοντας και χρησιμοποιώντας την wmic. Χρήσιμα εγγενή εργαλεία της γραμμής εντολών των Windows για διαχείριση και αποσφαλμάτωση του δικτύου είναι τα ping,ipconfig, traceroute και netstat. Πολλές [χρήσιμες λειτουργίες των Windows] (http://www.thewindowsclub.com/rundll32-shortcut-commands-windows) μπορούν να εκτελεστούν μέσω της εντολής Rundll32. Συμβουλές για αποδοτική χρήση του Cygwin Εγκαταστήστε πρόσθετα προγράμματα Unix με τον διαχειριστή πακέτων του Cygwin. Χρησιμοποιήστε το mintty ως το παράθυρο γραμμής εντολών σας. Αποκτήστε πρόσβαση στο πρόχειρο (clipboard) των Windows μέσω του /dev/clipboard. Εκτελέστε τη cygstart για να ανοίξετε ένα οποιοδήποτε αρχείο με την εφαρμογή που είναι ορισμένη να χρησιμοποιείται για το άνοιγμά του. Αποκτήστε πρόσβαση στο μητρώο των Windows με regtool. Σημειώστε ότι η διαδρομή C:\ των Windows γίνεται /cygdrive/c στο Cygwin και ότι το / του Cygwin εμφανίζεται ως C:\cygwin στα Windows. Μετατρέψετε διαδρομές αρχείων από τη μορφή που χρησιμοποιεί το Cygwin σε αυτή που χρησιμοποιούν τα Windows και αντίστροφα με cygpath. Αυτό είναι πολύ χρήσιμο σε σενάρια που καλούν προγράμματα Windows. Μπορείτε να εκτελέσετε και να γράψετε σενάρια για τις περισσότερες εργασίες διαχείρισης συστήματος των Windows από τη γραμμή εντολών μαθαίνοντας και χρησιμοποιώντας την wmic. Μία άλλη επιλογή για να έχετε την εμφάνιση και την εμπειρία χρήσης Unix σε Windows είναι το Cash. Σημειώστε ότι μόνο πολύ λίγες εντολές Unix και επιλογές γραμμής εντολών είναι διαθέσιμες σε αυτό το περιβάλλον. Περισσότερες πηγές awesome-shell: Μία προσεγμένη λίστα με εργαλεία και πηγές σχετικές με τον φλοιό . awesome-osx-command-line: Ένας περισσότερο εις βάθος οδηγός της γραμμής εντολών του OS X. Strict mode για να γράφετε καλύτερα σενάρια φλοιού. shellcheck: Ένα εργαλείο στατικής ανάλυσης για σενάρια για φλοιό. Στην ουσία, lint για bash/sh/zsh. Filenames and Pathnames in Shell: Οι δυστυχώς περίπλοκες μικρολεπτομέρειες του πώς να διαχειριστεί κανείς σωστά ονόματα αρχείων σε σενάρια για φλοιό. Data Science at the Command Line: Περισσότερες εντολές και εργαλεία χρήσιμα για την άσκηση της επιστήμης δεδομένων, από το βιβλίο με το ίδιο όνομα. Αποποίηση ευθύνηςΜε την εξαίρεση πολύ μικρών εργασιών, ο κώδικας πρέπει να γράφεται ώστε να μπορούν οι άλλοι να τον διαβάζουν. Η δύναμη συνεπάγεται ευθύνη. Το γεγονός ότι μπορείτε να κάνετε κάτι με Bash δε σημαίνει απαραίτητα ότι θα έπρεπε! ;) Άδεια χρήσης Η εργασία αυτή έχει αδειοδοτηθεί με Creative Commons Attribution-ShareAlike 4.0 International License.]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%9A%84%E8%89%BA%E6%9C%AF%2FREADME-de%2F</url>
    <content type="text"><![CDATA[🌍Čeština ∙ Deutsch ∙ Ελληνικά ∙ English ∙ Español ∙ Français ∙ Indonesia ∙ Italiano ∙ 日本語 ∙ 한국어 ∙ Português ∙ Română ∙ Русский ∙ Slovenščina ∙ Українська ∙ 简体中文 ∙ 繁體中文 The Art of Command Line Kurzbeschreibung Grundlagen Täglicher Gebrauch Umgang mit Dateien und Daten Fehlerbehebung auf Systemebene Einzeiler Eigenartig aber hilfreich Nur MacOS X Nur Windows Weitere Quellen Haftungsausschluss Der flüssige Umgang mit der Befehlszeile (auch Kommandozeile, engl. “command line”) ist eine oft vernachlässigte oder als undurchsichtig empfundene Fähigkeit, steigert jedoch Flexibilität und Produktivität eines Informatikers auf offensichtliche als auch subtile Weise. Was folgt, ist eine Auswahl an Notizen und Tipps im Umgang mit der Befehlszeile, welche ich beim Arbeiten mit Linux zu schätzen gelernt habe. Manche dieser Hinweise beinhalten Grundwissen, andere sind sehr spezifisch, fortgeschritten oder auch eigenartig. Die Seite ist nicht lang, aber wenn du alle Punkte verstanden hast und anwenden kannst, weißt du eine ganze Menge. Vieles davonerschienursprünglichauf Quora,aber angesichts des Interesses scheint es vielversprechend, Github zu nutzen, wo talentiertere Menschen als ich es bin kontinuierlich Verbesserungen vorschlagen können. Wenn du einen Fehler entdeckst oder etwas, das man besser machen könnte, erstelle ein Issue oder einen PR! (Lies aber bitte zuerst die Kurzbeschreibung und überprüfe bereits vorhandene Issues/PRs.) KurzbeschreibungUmfang: Diese Anleitung richtet sich an Anfänger und Fortgeschrittene. Die Ziele sind Breite (alles ist wichtig), Genauigkeit (konkrete Beispiele für die gebräuchlichsten Anwendungsfälle) und Knappheit (Dinge, die nicht wesentlich sind oder leicht anderswo nachgeschlagen werden können, sollen vermieden werden). Jeder Tipp ist in einer bestimmten Situation wesentlich oder deutlich zeitsparend gegenüber bestehenden Alternativen. Sie ist für Linux geschrieben, mit der Ausnahme der Abschnitte “Nur MacOS X“ und “Nur Windows“. Viele der anderen Punkte lassen sich nutzen oder sind installierbar auf anderen Unices oder MacOS (oder sogar Cygwin). Der Fokus liegt auf interaktiver Bash, allerdings gelten viele Tipps auch auf anderen Shells sowie für allgemeines Bash-Skripting. Sie beinhaltet sowohl “normale” Unix-Befehle als auch solche, die bestimmte installierte Pakete voaussetzen – sofern sie wichtig genug sind, dass sie die Aufnahme in diese Anleitung verdienen. Hinweise: Um eine Seite nicht zu sprengen, ist ihr Inhalt durchgängig anhand von Verweisen aufgelistet. du bist schlau genug, anderswo zusätzliche Informationen nachzuschlagen, sobald du die Idee bzw. den Befehl dahinter kennst. Verwende apt-get, yum, dnf, pacman, pip oder brew, um ggf. neue Programme zu installieren. Verwende Explainshell, um einen hilfreichen Einblick zu erhalten, was es mit Befehlen, Optionen, Pipes etc. auf sich hat. Grundlagen Lerne Bash-Grundlagen. Tatsächlich, gib man bash ein und überfliege das Ganze zumindest; es ist leicht zu verstehen und nicht allzu lang. Alternative Shells sind nett, aber Bash ist mächtig und immer verfügbar (nur zsh, fish, etc. zu lernen ist auf dem eigenen Laptop vielleicht reizvoll, beschränkt jedoch deine Möglichkeiten in vielerlei Hinsicht, etwa beim Arbeiten mit bestehenden Servern). Lerne mindestens einen Text-basierten Editor zu benutzen. Idealerweise Vim (vi), da es letztlich keinen vergleichbaren Mitbewerber für gelegentliche Einsätze in einem Terminal gibt (selbst dann, wenn man eine große Entwicklungsumgebung wie Emacs oder die meiste Zeit einen modernen Hipster-Editor benutzt). Wisse, wie man Dokumentationen mit man liest (für Neugierige, man man listet Abschnittsnummern, bspw. stehen unter 1 “reguläre” Befehle, 5 beinhaltet Dateien/Konventionen und unter 8 solche zur Rechnerverwaltung). Finde man-Seiten (“man pages”) mit apropos. Wisse, dass manche Befehle keine ausführbaren Dateien, sondern Bash-Builtins sind, und dass du Hilfe zu diesen mit help und help -d erhälst. Lerne etwas über die Umleitung von Ein- und Ausgaben per &gt; und &lt; sowie | für Pipes. Wisse, dass &gt; die Ausgabedatei überschreibt und &gt;&gt; etwas anhängt. Lerne etwas über stdout und stderr. Lerne etwas über die Dateinamenerweiterung mittels * (und eventuell ? und […]) sowie Anführungszeichen, etwa den Unterschied zwischen doppelten &quot; und einfachen &#39;. (Mehr zur Variablenerweiterung findest du unten.) Mach dich vertraut mit Bash-Jobmanagement: &amp;, ctrl-z, ctrl-c, jobs, fg, bg, kill, etc. Kenne ssh und die Grundlagen passwortloser Authentifizierung mittels ssh-agent, ssh-add, etc. Grundlegende Dateiverwaltung: ls and ls -l (und spezieller, lerne die Funktion jeder einzelnen Spalte von ls -l kennen), less, head, tail und tail -f (oder noch besser, less +F), ln und ln -s (lerne die Unterschiede und Vorteile von Hard- und Softlinks), chown, chmod, du (für eine Kurzzusammenfassung der Festplattenbelegung: du -hs *). Für Dateisystemmanagement df, mount, fdisk, mkfs, lsblk. Lerne, was ein Inode (engl. index node) ist (ls -i oder df -i). Grundlagen der Netzwerkverwaltung: ip oder ifconfig, dig. Lerne etwas über Versionskontrolle und benutze ein entsprechendes System, wie etwa git. Kenne reguläre Ausdrücke gut, und die verschiedenen Statusindikatoren zu grep/egrep. Die Optionen -i, -o, -v, -A, -B, und -C sind gut zu wissen. Lerne den Umgang mit apt-get, yum, dnf oder pacman (je nach Linux-Distribution), um Pakete zu finden bzw. zu installieren. Und stell sicher, dass du pip hast, um Python-basierte Befehlszeilen-Werkzeuge nutzen zu können (einige der untenstehenden werden am einfachsten über pip installiert). Täglicher Gebrauch In Bash kannst du mit Tab Parameter vervollständigen sowie alle verfügbaren Befehle anzeigen lassen und mit ctrl-r bereits benutzte Befehle durchsuchen (drück die Kombination, gib dann deinen Suchtext ein und springe anschließend durch wiederholtes Drücken von ctrl-r durch die Suchergebnisse, mit Enter kannst du den gefundenen Befehl ausführen sowie mit der rechten Pfeiltaste in die aktuelle Zeile einfügen, um ihn zu bearbeiten). In Bash kannst du mit ctrl-w das letzte Wort löschen und mit ctrl-u alles bis zum Anfang einer Zeile. Verwende alt-b und alt-f, um dich Wort für Wort fortzubewegen, springe mit ctrl-a zum Beginn einer Zeile, mit ctrl-e zum Ende einer Zeile, lösche mit ctrl-k alles bis zum Ende einer Zeile und bereinige mit ctrl-l den Bildschirm. Siehe man readline für alle voreingestellten Tastenbelegungen in Bash. Davon gibt’s viele. Zum Beispiel alt-. wechselt durch vorherige Parameter und alt-* erweitert ein Suchmuster. Alternativ, falls du vi-artige Tastenbelegungen magst, verwende set -o vi (und set -o emacs, um es wiederzuholen). Um kürzlich genutzte Befehle zu sehen, history. Es gibt außerdem viele Abkürzungen wie etwa !$ (letzter Parameter) und !! (letzter Befehl), wenngleich diese oft einfach ersetzt werden durch ctrl-r und alt-.. Um lange Befehle zu bearbeiten, kannst du sie (nachdem du deinen Editor angegeben hast, etwa mit export EDITOR=vim) mit ctrl-x ctrl-e im Editor öffnen, um mehrere Zeilen bearbeiten zu können. Oder vi-Style, escape-v. Um kürzlich verwendete Befehle anzuzeigen, benutze history. Anschließend !n (wobei n die Nummer des Befehls ist), um es erneut auszuführen. Es gibt zudem zahlreiche Abkürzungen, die man verwenden kann, die nützlichste ist wahrscheinlich !$ für den letzten Parameter und !! für den letzten Befehl (siehe “HISTORY EXPANSION” in der man-Seite). Diese werden allerdings oft einfach ersetzt durch ctrl-r und alt-.. In dein Benutzerverzeichnis gelangst du mit cd. Auf Dateien relativ zu diesem kannst du mit dem Präfix ~ zugreifen (etwa so ~/.bashrc). In sh-Skripts heißt das Benutzerverzeichnis $HOME. Um ins vorangegangene Arbeitsverzeichnis zu gelangen: cd - Wenn du einen Befehl eingibst und es dir auf halbem Wege anders überlegst, drücke alt-#, um am Zeilenanfang ein # einzufügen und ihn damit als Kommentar auszuweisen (oder benutze ctrl-a, #, enter). du kannst später über die Befehlsgeschichte zurückgelangen. Verwende xargs (oder parallel). Es ist sehr mächtig. Beachte, wie du viele Dinge pro Zeile (-L) als auch parallel (-P) ausführen kannst. Wenn du dir nicht sicher bist, ob das Richtige dabei herauskommt, verwende zunächst xargs echo. Außerdem ist-I{} nützlich. Beispiele: 12find . -name '*.py' | xargs grep irgendeine_funktioncat hosts | xargs -I&#123;&#125; ssh root@&#123;&#125; hostname pstree -p liefert eine hilfreiche Anzeige des Prozessbaums. Verwende pgrep und pkill, um Prozesse anhand eines Namens zu finden oder festzustellen (-f ist hilfreich). Kenne die verschiedenen Signale, welche du Prozessen senden kannst. Um einen Prozess etwa zu unterbrechen, verwende kill -STOP [pid]. Für die vollständige Liste, siehe man 7 signal Verwende nohup oder disown, wenn du einen Hintergrundprozess für immer laufen lassen willst. Überprüfe mithörende Prozesse mit netstat -lntp oder ss -plat (für TCP; füge -u für UDP hinzu). Siehe zudem lsof für offene Sockets und Dateien. Siehe uptime oder w, um die laufende Betriebszeit des Systems zu erfahren, Verwende alias, um Verknüpfungen für gebräuchliche Befehle zu erstellen. So erstellt etwa alias ll=&#39;ls -latr&#39; den neuen Alias ll. Speichere diese Alternativnamen (“aliases”), Shell-Einstellungen und häufig benutzte Funktionen in ~/.bashrc und stelle sie anderen Login-Shells zur Verfügung. So hast du auf dein Setup auch in allen anderen Shell-Sessions Zugriff. Platziere Einstellungen von Umgebungsvariablen sowie Befehle, welche nach einer Anmeldung ausgeführt werden sollen, in ~/.bash_profile. Eine separate Konfiguration ist notwendig für Shells, welche du von einer grafischen Benutzeroberfläche startest sowie für cron-Jobs. Synchronisiere deine Konfigurationsdateien (etwa .bashrc und .bash_profile) zwischen mehreren Computern mit Git. Verstehe, dass Vorsicht geboten ist, wenn Variablen und Dateinamen Leerzeichen enthalten. Setze deine Bashvariablen daher mit Anführungszeichen: &quot;$FOO&quot;. Bevorzuge die Optionen -0 oder -print0, um ungültige Schriftzeichen zu aktivieren und so Dateinamen zu begrenzen, bspw. locate -0 pattern | xargs -0 ls -al oder find / -print0 -type d | xargs -0 ls -al. Um in einem “for loop” Dateinamen durchzugehen, die Leerzeichen enthalten, sorge mit IFS=$&#39;\n&#39; dafür, dass dein IFS immer auf einer neuen Zeile steht. Benutze in Bash-Skripts set -x (oder die Abwandlung set -v, welche unverarbeiteten Input akzeptiert, einschließlich Kommentare und unexpandierte Variablen) zum Output der Fehlerbehebung. Benutze “strict modes”, es sei denn, gute Gründe sprechen dagegen: Benutze set -e, um bei Fehlern abzubrechen (“nonzero exit code”). Benutze set -u, um die Verwendung nicht gesetzer Variablen aufzuspüren. Erwäge auch set -o pipefail für Fehler in Pipes (lies jedoch mehr zu diesem Thema, wenn du es vorhast, denn es ist ein wenig heikel). Benutze bei komplizierteren Skripts auch trap bei EXIT oder ERR. Es ist eine nützliche Angewohnheit, ein Skript folgendermaßen zu beginnen, um Fehler zu erkennen und sie ggf. mit einer entsprechenden Fehlermeldung abzubrechen: 12set -euo pipefailtrap "echo 'error: Script failed: see failed command above'" ERR In Bash-Skripts stellen Subshells (geschrieben in runden Klammern) einen praktischen Weg dar, Befehle zusammenzufassen. Ein gebräuchliches Beispiel ist die vorübergehende Arbeit in einem anderen Arbeitsverzeichnis: 123# erledige etwas im aktuellen Verzeichnis(cd /irgendein/anderes/verzeichnis &amp;&amp; anderer-befehl)# fahre fort im aktuellen Verzeichnis Beachte, dass es in Bash viele Möglichkeiten gibt, Variablen zu erweitern. Überprüfen, ob eine Variable existiert: ${name:?error message}.Wenn bspw. ein Bash-Skript nur einen einzelnen Parameter benötigt, schreibe einfach input_file=${1:?usage: $0 input_file}. Arithmetische Erweiterung: i=$(( (i + 1) % 5 )). Sequenzen: {1..10}. Zeichenkette kürzen: ${var%suffix} und ${var#prefix}. Wenn bspw. var=foo.pdf, dann gibt echo ${var%.pdf}.txt die Ausgabe foo.txt aus. Klammererweiterung mittels {…} kann dafür sorgen, ähnlichen Text seltener wiederholen zu müssen und ermöglicht die Kombination von Objekten. Das ist etwa in Fällen nützlich wie mv foo.{txt,pdf} zielverzeichnis (verschiebt beide Dateien), cp datei{,.bak} (erweitert den Ausdruck um cp datei datei.bak) oder mkdir -p test-{a,b,c}/subtest-{1,2,3} (erweitert alle denkbaren Kombinationen und erstellt einen Verzeichnisbaum). Die Ausgabe eines Befehls kann wie eine Datei behandelt werden mit &lt;(befehl). Das Vergleichen der lokalen /etc/hosts mit einer entfernten: 1diff /etc/hosts &lt;(ssh andererhost cat /etc/hosts) Beim Schreiben von Skripts wirst du deinen Code womöglich in geschweifte Klammern setzen wollen. Falls die schließende Klammer fehlt, wird dein Skript aufgrund eines Syntaxfehlers nicht ausgeführt. Das ist etwa dann sinnvoll, wenn es im Internet verfügbar ist, da ein unvollständig heruntergeladenes Skript so an der Ausführung gehindert wird: 123&#123; # Hier koennte dein Code stehen!&#125; Kenne “here documents” in Bash, wie etwa in cat &lt;&lt;EOF .... In Bash, leite sowohl den standard output als auch den standard error um mit: irgendein-befehl &gt;logfile 2&gt;&amp;1. Oftmals ist es gute Praxis, einen Befehl an das verwendete Terminal zu binden, um keinen offenen Dateizugriff im standard input zu erzeugen, also &lt;/dev/null hinzuzufügen. Verwende man ascii für eine gute ASCII-Tabelle, Mit Dezimal- und Hexadezimalwerten. Für allgemeine Informationen zu Kodierung sind man unicode, man utf-8 und man latin1 hilfreich. Verwende screen oder tmux, um einen Bildschirm zu multiplexen, besonders hilfreich ist dies für Fernzugriffe per ssh und zur Trennung und Neuverbindung mit einer Session. Eine minimalistische Alternative allein zur Aufrechterhaltung einer Session ist dtach. Bei SSH ist es hilfreich zu wissen, wie man einen Porttunnel mit -L oder -D (gelegentlich auch -R) einrichtet, etwa beim Zugriff auf Webseiten von einem Remote-Server. Es kann nützlich sein, ein paar Verbesserungen an den SSH-Einstellungen vorzunehmen; so enthält bspw. diese ~/.ssh/config Einstellungen, um das Abreißen der Verbindung in bestimmten Netzwerkumgebungen zu vermeiden, verwendet Kompression (was hilfreich ist bei SCP über Verbindungen mit niedriger Bandbreite) und Multiplex-Kanäle zu demselben Server mithilfe einer lokalen Kontrolldatei: 1234567TCPKeepAlive=yesServerAliveInterval=15ServerAliveCountMax=6Compression=yesControlMaster autoControlPath /tmp/%r@%h:%pControlPersist yes Einige andere Optionen im Zusammenhang mit SSH sind sicherheitsrelevant und sollten nur mit Bedacht aktiviert werden, etwa Zugriff per Subnet oder Host sowie in vertrauenswürdigen Netzwerken: StrictHostKeyChecking=no, ForwardAgent=yes. Erwäge mosh als Alternative zu ssh, die UDP benutzt, um so abgebrochene Verbindungen zu vermeiden, was ja in gewisser Hinsicht auch komfortabel ist (benötigt Server-seitiges Setup). Um Zugriff auf eine Datei in Oktalform zu erhalten, was zur Systemkonfiguration zwar nützlich, jedoch über ls nicht verfügbar und leicht zu vermasseln ist, verwende etwas wie 1stat -c '%A %a %n' /etc/timezone Verwende zur interaktiven Auswahl von Werten aus dem Output eines anderen Befehls percol oder fzf. Verwende fpp (PathPicker) zur Interaktion mit Dateien als Output eines anderen Befehls (wie etwa git). Verwende für einen einfachen Webserver für alle Dateien im aktuellen Verzeichnis (sowie Unterverzeichnisse), der für alle in deinem Netzwerk abrufbar ist: python -m SimpleHTTPServer 7777 (für Port 7777 und Python 2) sowie python -m http.server 7777 (für Port 7777 und Python 3). Benutze sudo, um einen Befehl als ein anderer Benutzer auszuführen. Standardmäßig ist dies die Ausführung als root; benutze -u zur Angabe eines anderen benutzers sowie -i, um dich als dieser anzumelden (du wirst nach deinem Passwort gefragt). Benutze su benutzername oder su - benutzername, um mit der Shell zu einem anderen Benutzer zu wechseln. Füge - hinzu, um eine Umgebung zu erhalten, als hättest du dich gerade mit diesem Benutzer angemeldet. Das Weglassen des Benutzernamens führt zur Anmeldung als root. du wirst gefragt nach dem Passwort des Benutzers, als der du dich anmelden willst. Kenne das 128K-Limit der Befehlszeile. Der “Argument list too long”-Fehler erscheint häufig, wenn auf sehr viele Dateien über Wildcards) zugegriffen wird (wenn das passiert, können Alternativen wie find und xargs helfen). Benutze den python-Interpreter als einfachen Taschenrechner (und natürlich für den Zugriff auf Python im Allgemeinen). Beispiel: 12&gt;&gt;&gt; 2+35 Umgang mit Dateien und Daten Um eine Datei im aktuellen Verzeichnis anhand des Namens zu finden, find . -iname &#39;*irgendwas*&#39;. Um eine Datei unabhängig vom Verzeichnis anhand des Namens zu finden, verwende locate irgendwas (bedenke jedoch, dass updatedb kürzlich erstellte Datein möglicherweise noch nicht indexiert hat). Für das allgemeine durchsuchen von (Quell-)Dateien (fortgeschrttener als grep -r), verwende ag. Um HTML in Text zu konvertieren: lynx -dump -stdin Für Markdown, HTML und alle möglichen Arten von Dokumentkonvertierung, versuch’s mit pandoc. Wenn du mit XML arbeiten musst, xmlstarlet ist alt, aber gut. Für JSON, verwende jq. Für YAML gibt’s shyaml. Für Excel- bzw. CSV-Dateien hält csvkit in2csv, csvcut, csvjoin, csvgrep, etc bereit. Für Amazon S3 ist s3cmd praktisch und s4cmd schneller. Amazons aws sowie das verbesserte saws sind essentiell für andere AWS-bezogene Aufgaben. Kenne sort und uniq, letzteres einschließlich der Optionen -u und -d – siehe die Einzeiler unten. Siehe auch comm. Kenne cut, paste und join zur Arbeit mit Textdateien. Viele Leute nutzen cut, vergessen aber join. Kenne wc, um neue Zeilen (-l), Zeichen (-m), Wörter (-w) und Bytes (-c) zu zählen. Kenne tee, um von stdin in eine Datei und sogar nach stdout zu kopieren, wie etwa mit ls -al | tee datei.txt. Bei komplexeren Berechnungen, einschließlich Gruppieren, Tauschen von Feldern und statistische Berechnungen, könnte datamash passend sein. Sei dir bewusst, dass die regionale Spracheinstellung (“locale”) viele Befehlszeilen-Werkzeuge auf subtile Art und Weise beeinflusst, inklusive der Sortierreihenfolge und ihrer Performance. Die meisten Linux Installation setzen LANG oder andere lokale Variablen auf eine lokale Einstellung wie z.B. “US English”. Aber sei dir bewusst, dass sich das Sortierverhalten ändern wird, falls du die “locale” änderst. Und wisse, dass “i18n”-Routinen sort und andere Befehle stark verlangsamen können. In manchen Situationen (wie den Mengen oder Identitätsfunktionen unterhalb) kann man ruhigen Gewissens langsame “i18n”-Routinen ignorieren und traditionelle byte-basierte Sortierreihenfolge nutzen, indem man export LC_ALL=C setzt. Du kannst einem bestimmten Befehl eine Umgebung zuteilen, indem seinem Aufruf die Einstellung der Umgebungsvariable vorangestellt wird, wie hier: TZ=Pacific/Fiji date. Kenne Grundlagen vonawk und sed für einfache Datenverarbeitung. Um z.B. alle Zahlen in der dritten Spalte einer Textdatei aufzusummieren: awk &#39;{ x += $3 } END { print x }&#39;. Das ist wahrscheinlich 3X schneller und 3X kürzer als das Python Äquivalent. Um mehrere Dateien umzubenennen sowie innerhalb von Dateien zu suchen/ersetzen, probier repren aus (gelegentlich kann man auch mit rename mehrere Dateien umbenennen, aber sei vorsichtig, da dessen Funktionsweise je nach Linux-Distribution abweicht). 123456# Vollständige Umbenennung von Dateinamen, Ordnern und Inhalten - foo -&gt; bar:repren --full --preserve-case --from foo --to bar .# Backupdateien wiederherstellen - whatever.bak -&gt; whatever:repren --renames --from '(.*)\.bak' --to '\1' *.bak# Wie oben, aber mit rename, sofern verfügbar:rename 's/\.bak$//' *.bak Wie die man-Seite richtig sagt, ist rsync ein schnelles und vielseitiges Werkzeug zum Kopieren von Dateien. Es ist bekannt für das Synchronisieren zwischen Rechnern, ist lokal aber ebenso nützlich. Wenn es die Sicherheitsbestimmungen zulassen, erlaubt rsync im Gegensatz zu scp die Wiederaufnahme einer Übertragung, ohne nochmal von vorn beginnen zu müssen. Es ist zudem einer der schnellsten Wege, um große Mengen an Dateien zu löschen: 1mkdir leeres-verzeichnis &amp;&amp; rsync -r --delete leeres-verzeichnis/ verzeichnis &amp;&amp; rmdir verzeichnis Benutze shuf zum Mischen oder um zufällige Zeilen aus einer Datei auszuwählen. Kenne die Optionen von sort. Benutze -n für Zahlen, oder -h um mit menschenlesbaren Zahlen umzugehen (wie z.B. von du -h). Sei dir bewusst, wie Schlüssel funktionieren (-t und -k). Sei dir insbesondere bewusst, dass du -k1,1 verwenden musst, um bezüglich des ersten Felds zu sortieren;-k1 bedeutet, sortiere anhand der ganzen Zeile. Stabiles Suchen (sort -s) kann ebenfalls nützlich sein. Um bspw. primär nach Feld 2 und sekundär nach Feld 1 zu sortieren, kannst du sort -k1,1 | sort -s -k2,2 benutzen. Falls du jemals ein Tabulator Literal in eine Befehlszeile in Bash schreiben musst (etwa den Parameter -t für sort), drücke ctrl-v [Tab] oder schreibe $&#39;\t&#39; (letzteres ist besser, da man es Kopieren/Einfügen kann). Die Standardwerkzeuge für das Patchen von Quellcode sind diff und patch. Siehe auch diffstat, um zusammenfassende Statistiken eines diffs zu erhalten. Beachte, dass diff -r für komplette Verzeichnisse funktioniert. Nutze diff -r tree1 tree2 | diffstat, um eine Übersicht aller Änderungen zu bekommen. Benutze vimdiff, um Dateien zu vergleichen und zu bearbeiten. Benutze für Binärdateien hd, hexdump or xxd zur Erstellung einfacher Hexdumps und bvi oder biew zur binären Bearbeitung. Ebenfalls für Binärdateien kann strings (und grep, etc.) benutzt werden, um Textpassagen zu finden. Um Diffs für Binärdateien zu erstellen (Delta Kompression), nutze xdelta3. Um zwischen Textkodierungen zu konvertieren, solltest du iconv probieren, oder aber uconv für fortgeschrittene Anwendungsfälle; es unterstüzt einige fortgeschrittene Unicode-Dinge. Dieser Befehl bspw. wandelt alle Buchstaben in Kleinbuchstaben um und entfernt alle Akzente (indem sie erweitert und verworfen werden): 1uconv -f utf-8 -t utf-8 -x '::Any-Lower; ::Any-NFD; [:Nonspacing Mark:] &gt;; ::Any-NFC; ' &lt; input.txt &gt; output.txt Um Dateien aufzuteilen, siehe split (Teilung anhand einer bestimmten Größe) und csplit (Teilung anhand eines bestimmten Musters). Benutze zless, zmore, zcat, und zgrep um mit komprimierten Dateien zu arbeiten. Dateieigenschaften können mit chattr gesetzt werden und stellen eine niederschwelligere Alternative zu Dateiberechtungen dar. So kann man etwa, um das versehentliche Löschen einer Datei zu verhindern, eine entsprechende Flag (“immutable flag”) setzen: sudo chattr +i /wichtiges/verzeichnis/oder/datei Benutze getfacl und setfacl, um Dateiberechtigungen zu speichern und wiederherzustellen. Beispiel: 12getfacl -R /irgendein/pfad &gt; berechtigungen.txtsetfacl --restore=berechtigungen.txt Fehlerbehebung auf Systemebene Zur Fehlersuche bei Webanwendungen sind curl und curl -I hilfreich, ebenso wie ihre wget Äquivalente oder das modernere httpie. Um den aktuellen CPU-/Festplattenstatus zu erfahren, sind die Klassiker top (oder das bessere htop), iostat und iotop. Benutze iostat -mxz 15 for basic CPU and detailed per-partition disk stats and performance insight. Benutze für Informationen zu Netzwerkverbindungen netstat und ss. Für eine schnelle Übersicht, was sich auf einem System abspielt, ist dstat sehr nützlich. Für einen guten Gesamtüberblick bietet sich zudem glances an. Um den Zustand des Speichers zu erfahren, führst du am besten free und vmstat aus und verstehst deren Ausgabe. Sei dir insbesondere bewusst, dass der “cached”-Wert jener Wert ist, der vom Linux-Kernel als Dateicache genutzt wird, da dieser effektiv als zum “free”-Wert addiert werden kann. Fehlerbehebung (“debugging”) auf Java-Systemen ist ein anderes Paar Schuhe, aber ein simpler Trick für die Oracle JVM (der teilweise auch für andere JVMs funktioniert) ist kill -3 &lt;pid&gt;, sodass ein vollständiger Strack trace und Heap Informationen (inklusive Garbage Collection Details, die sehr informativ sein können) nach stderr/logs ausgegeben werden. Die JDK-Befehle jps, jstat, jstack, jmap sind ebenfalls nützlich. SJK-Werkzeuge sind noch weiter fortgeschritten. Benutze mtr als ein besseres traceroute, um Netzwerkprobleme zu identifizieren. Willst du wissen, warum eine Festplatte voll ist, dann spart ncdu Zeit gegenüber den üblichen Befehlen wie du -sh *. Um herauszufunden, welcher Socket oder Prozess Bandbreite verbraucht, kannst du iftop oder nethogs verwenden. Das ab-Werkzeug (ein Teil vom Apache) ist hilfreich, um schnell und pragmatisch die Performance eines Webservers zu messen. Für komplexere Messungen kannst du siege ausprobieren. Für eine tiefergehende Netzwerk Problemsuche, wireshark, tshark, oder ngrep. Kenne strace und ltrace. Diese können hilfreich sein, falls ein Programm fehlschlägt, hängt oder abstürzt und du weißt nicht warum, oder um einen generellen Eindruck von der Performance zu bekommen. Beachte die Profiling-Option (-c) und die Fähigkeit, sich mit laufenden Prozessen zu verbinden (-p). Kenne ldd, um “shared libraries” zu überprüfen. Sei in der Lage, dich mittels gdb mit einem laufenden Prozess zu verbinden und dessen “stack traces” zu holen. Benutze /proc. Es ist manchmal unglaublich hilfreich, um Probleme in Echtzeit zu debuggen. Beispiele: /proc/cpuinfo, /proc/meminfo, /proc/cmdline, /proc/xxx/cwd, /proc/xxx/exe, /proc/xxx/fd/, /proc/xxx/smaps (wobei xxx die Prozess-ID / pid ist). Bei der Frage, warum in der Vergangenheit etwas schief gelaufen ist, kann sar sehr hilfreich sein. Es zeigt historische Statistiken über CPU, Speicher, Netzwerk, etc. Für eine genauere System und Performanceanalyse, solltest du dir stap (SystemTap), perf), und sysdig ansehen. Finde heraus, welches Betriebssystem du nutzt mittels uname oder uname -a (allgemeine Unix-/Kernelinformationen) oder lsb_release -a (Informationen zur verwendeten Linux-Distribution) Benutze dmesg wenn sich etwas merkdwürdig verhält (es könnte ein Hardware oder Treiber Problem sein) Wenn du eine Datei löschst, jedoch laut du nicht der erwartete Festplattenspeicher frei wird, dann überprüfe, ob die Datei von einem Prozess verwendet wird: lsof | grep deleted | grep &quot;dateiname&quot; EinzeilerEin paar Beispiele, wie man Befehle zusammen benutzen kann: Manchmal ist es unglaublich hilfreich, dass man die Schnittmenge, Vereinigung und den Unterschied zwischen Textdateien via sort/uniq bilden kann. Angenommen, a und b sind Textdateien, die bereits “unique” sind. Diese Herangehensweise ist schnell und funktioniert mit Dateien beliebiger Größe, bis zu mehreren Gigabytes (sort ist nicht durch Speicher beschränkt, obwohl man eventuell die -T-Option nutzen muss, falls /tmp auf einer kleinen Root-Partition liegt). Siehe auch die Bemerkung über LC_ALL weiter oben und die -u-Option von sort (wurde oben aus Gründen der Übersichtlichkeit ausgelassen). 123cat a b | sort | uniq &gt; c # c ist a vereint mit bcat a b | sort | uniq -d &gt; c # c ist a geschnitten bcat a b b | sort | uniq -u &gt; c # c ist die Menge mit unterschiedlichen Elementen a - b Eine schnelle Überprüfung der Inhalte aller Dateien in einem Verzeichnis erreichst du mit grep . * (damit enthält jede Zeile den Dateinamen) oder head -100 * (damit erhält jede Datei eine Überschrift). Dies kann nützlich sein für Verzeichnisse, die Konfigurationsdateien enthalten wie jene in /sys, /proc und /etc. Alle Zahlen in der dritten Spalte einer Textdatei aufsummieren (dieser Ansatz ist wahrscheinlich dreimal schneller und enthält dreimal weniger Code als dessen Entsprechung in Python): 1awk '&#123; x += $3 &#125; END &#123; print x &#125;' meinedatei Falls man die Größen/Datumsangaben von einem Dateibaum wissen möchte, funktioniert das Folgende wie ein rekursives ls -l, aber ist leichter zu lesen als ls -lR: 1find . -type f -ls Um Größen/Datumsangaben in einem Verzeichnisbaum zu sehen, wirkt dies wie ein umgedrehtes ls -l, ist aber einfacher zu lesen als ls -lR: 1find . -type f -ls Angenommen innerhalb einer Textdatei, so wie ein server web log, tauch ein gewisser Wert in manchen Zeilen auf, wie z.B. ein acct_id Parameter in der URL. Falls eine Aufzählung gewünscht ist, wie viele Anfragen es jeweils für eine acct_id gibt: 1cat access.log | egrep -o 'acct_id=[0-9]+' | cut -d= -f2 | sort | uniq -c | sort -rn Um durchgehend Änderungen zu überwachen, solltest du “watch” benutzen; z.B. Dateiänderungen in einem Verzeichnis können mittels watch -d -n 2 &#39;ls -rtlh | tail&#39; überwacht werden, während du Deine Wifi Einstellungen mittels watch -d -n 2 ifconfig auf Fehler überprüfen kannst. Führe diese Funktion aus, um einen zufälligen Tip aus diesem Dokument zu erhalten(parst das Markdown Dokument und extrahiert ein Element) 1234567function taocl() &#123; curl -s https://raw.githubusercontent.com/jlevy/the-art-of-command-line/master/README-de.md | pandoc -f markdown -t html | xmlstarlet fo --html --dropdtd | xmlstarlet sel -t -v "(html/body/ul/li[count(p)&gt;0])[$RANDOM mod last()+1]" | xmlstarlet unesc | fmt -80&#125; Eigenartig aber hilfreich expr: Führe arithmetische oder bool’sche Operationen aus oder werte reguläre Ausdrücke aus m4: Simpler Macro-Auswerter yes: Gib eine Zeichenkette sehr oft aus cal: Netter Kalender env: Führe einen Befehl aus (nützlich für Skripte) printenv: Gebe Umgebungsvariablen aus (nützlich zum Debuggen und für Skripte) look: Finde englische Worte (oder Zeilen in einer Datei), die mit einer bestimmten Zeichenkette anfangen cut, paste und join: Datenmanipulation fmt: Formatiere Textabsätze pr: Formatiere Text als Seiten/Spalten fold: Breche Textzeilen um column: Formatiere Textfelder als bündige Spalten oder Tabellen mit fester Größe expand und unexpand: Konvertiere zwischen Tabs und Spaces nl: Füge Zeilennummern hinzu seq: Gib Zahlen aus bc: Taschenrechner factor: Faktorisiere Ganzzahlen gpg: Verschlüsseln und Signieren von Dateien toe: Tabelle von terminfo-Einträgen nc: Netzwerk-Debugging und Datentransfer socat: Socket- und TCP-Port-Weiterleitung (ähnlich wie netcat) slurm: Visulaisierung des Netzwerkverkehrs (“traffic”) dd: Daten zwischen Dateien und Geräten bewegen file: Identifiziere den Typ einer Datei tree: Zeige Verzeichnisse und Unterverzeichnisse als verschachtelten Baum; wie ls aber rekursiv stat: Datei Infomationen time: Führe einen Befehl aus und messe die Zeit timeout: Führe einen Befehl für eine bestimmte Zeit aus und beende ihn anschließend wieder lockfile: Erstelle eine Semaphordatei, die nur gelöscht werden kann mit rm -f logrotate: Rotiert, komprimiert und mailt System-Log-Dateien watch: Führe einen Befehl wiederholt aus, wobei die Ergebnisse angezeigt und/oder Änderungen hervorgehoben werden tac: Gebe Dateien in umgekehrter Reihenfolge aus shuf: Zufällige Auswahl von Zeilen von einer Datei comm: Vergleiche sortierte Dateien Zeile für Zeile pv: Überwache den Fortschritt von Daten durch eine Pipe hd, hexdump, xxd, biew und bvi: Ausgabe und Editieren von Binärdateien strings: Text aus Binärdateien extrahieren tr: Buchstabenübersetzung und -manipulation iconv oder uconv: Konvertierung von Zeichensätzen split und csplit: Dateien aufteilen sponge: Liest die gesamte Eingabe, bevor sie wieder ausgegeben wird. Nützlich, um aus derselben Datei zu lesen und in diese zu schreiben, bspw. grep -v irgendwas irgendeine-datei | sponge irgendeine-datei units: Einheiten Konvertierungen und Berechnungen; konvertiert Furlong(Achtelmeile)/Fortnights(2 Wochen) zu twips/blink (siehe /usr/share/units/definitions.units) apg: Generiert zufällige Passwörter xz: Hochgradige Dateikompression ldd: Informationen zu dynamisch gelinkten Bibliotheken nm: Symbole aus Objektdateien anzeigen ab: Webserver benchmarken strace: Debugging von Syscalls mtr: Ein besseres “traceroute” zum Netzwerk-Debugging cssh: Visuelle, nebenläufige Shell rsync: Synchronisiere Dateien und Ordner über SSH oder im lokalen Dateisystem wireshark and tshark: Pakete aufzeichnen und Netzwerk-Debugging ngrep: grep für die Netzwerkschicht host und dig: DNS-Auflösung lsof: Prozess Datei Deskriptor und Socket Informationen dstat: Nützliche Systemstatistiken glances: Grobe Übersicht über zahlreiche Subsysteme iostat: Fesplatten-Nutzungsstatistiken mpstat: CPU-Nutzungstatistiken vmstat: Speicher-Nutzungsstatistiken htop: Verbesserte Version von top last: Loginverlauf who: Wer gerade angemeldet ist id: Identitätsinformationen zu Benutzern/Gruppen sar: Historische Systemstatistiken iftop or nethogs: Netzwerknutzung durch Sockets oder Prozesse ss: Socket-Statistiken dmesg: Bootvorgang und System-Fehlermeldungen sysctl: Anzeige und Konfiguration von Linux Kernel Parametern zur Laufzeit hdparm: SATA/ATA-Festplattenmanipulation/-performanceinformationen lsblk: Auflisten von block devices: eine Baumansicht deiner Festplatten und Partitionen lshw, lscpu, lspci, lsusb, dmidecode: Hardware-Informationen, inklusive CPU, BIOS, RAID, Grafikkarten, Geräte, etc. lsmod und modinfo: Auflisten und Details anzeigen von Kernelmodulen fortune, ddate, und sl: Ähm ja, kommt darauf an, ob man Dampflokomotiven und flotte Zitate “nützlich” findet Nur MacOS XDiese Hinweise sind nur für MacOS relevant. Paketverwaltung mit brew (Homebrew) und/oder port (MacPorts). Mit diesen Werkzeugen kann man viele der obrigen Programme für MacOs installieren. Kopiere die Ausgabe eines beliebigen Befehls an eine Desktop App mit pbcopy und füge die Eingabe von einer solchen ein mit pbpaste. Um die Option Taste als alt-Taste in einer Mac OS Konsole zu nutzen (so wie in den obrigen Befehle wie alt-b, alt-f, etc.), öffne Einstellungen -&gt; Profile -&gt; Tastatur und aktiviere “Benutze Option Taste als Meta Taste” Um eine Datei mit einer Desktopanwendung zu öffnen, kann man open oder open -a /Applications/Whatever.app benutzen. Spotlight: Dateisuche mit mdfind und Ausgabe von Metadaten (wie z.B. photo EXIF info) mit mdls. Man sollte sich bewusst sein, dass MacOS auf BSD Unix basiert und sich viele Befehle (wie z.B. ps, ls, tail, awk, sed) bezüglich subtiler Kleinigkeiten von Linux, das stark von System V-style Unix und GNU tools beeinflusst ist, unterscheiden. Oft kann man den Unterschied daran erkennen, dass eine man-Seite die Überschrift “BSD General Commands Manual” trägt. In manchen Fällen kann auch die GNU-Version installiert werden (wie z.B. bei gawk und gsed für GNU awk und sed). Falls manplattformübergreifende Bash-Skripte schreiben möchte, sollte man solche Befehle vermeiden (und z.B. Python oder perl in Betracht ziehen) oder sorgfätig testen. Benutze sw_vers für OS X Systeminformationen. Nur WindowsDiese Hinweise sind nur für Windows relevant. Möglichkeiten, Unix-Tools unter Windows zu erhalten Zugriff auf die Macht der Unix-Shell erhälst du unter Microsoft Windows durch die Installation von Cygwin. Die meisten hier beschriebenen Dinge funktionieren damit ohne weiteren Aufwand. Mit Windows 10 kannst du Bash on Ubuntu on Windows benutzen, das eine vertraute Bash-Umgebung mit Unix-Befehlszeilen-Werkzeugen. Dies erlaubt einerseits die Nutzung von Linux-Programmen auf Windows, unterstützt andererseits jedoch nicht die Ausführung von Windows-Programmen von der Bash-Konsole. Eine weitere Option, GNU-Entwicklerwerkzeuge (etwa GCC) auf Windows zu nutzen, besteht darin, MinGW und dessen Paket MSYS, das Hilfsprogramme wie bash, gawk, make and grep beinhaltet, zu installieren. MSYS bringt allerdings nicht so viele Features mit wie etwa Cygwin. MinGW ist besonders nützlich für die Erstellung nativer Windows-Ports von Unix-Werkzeugen. Eine andere Möglichkeit, ein wenig Unix auf dein Windows-System zu bringen, bietet Cash. Beachte allerdings, dass nur sehr wenige Unix-Befehle und Befehlszeilen-Optionen in dieser Umgebung zur Verfügung stehen. Nützliche Windows Befehlszeilen-Werkzeugen Du kannst die meisten Aufgaben der Windows-Systemverwaltung von der Befehlszeile ausführen und skripten, indem du den Umgang mit wmic lernst. Native Windows Befehlszeilen Netzwerk Werkzeugen, die du nützlich finden kannst, gehören ping,ipconfig, traceroute und netstat. Du kannst [viele nützliche Windows-Aufgaben] (http://www.thewindowsclub.com/rundll32-shortcut-commands-windows) durch Aufrufen des Befehls Rundll32 ausführen. Cygwin Tipps und Tricks Installiere zusätzliche Unix-Programme mit Cygwins Paketmanager. Benutze mintty als dein Befehlszeilenfenster. Greife mit /dev/clipboard auf die Zwischenablage von Windows zu. Öffne beliebige Dateien über cygstart mit deren Standardprogramm. Greife mit regtool auf die Windows-Registry zu. Beachte, dass der Windows-Pfad C:\ unter Cygwin zu /cygdrive/c wird und dass Cygwins / unter Windows als C:\cygwin verfügbar ist. Für die Umwandlung zwischen Cygwin- und Windows-Pfaden steht cygpath zur Verfügung. Dies ist inbesondere für Skripte nützlich, welche Windows-Programme ausführen. Weitere Quellen awesome-shell: Eine hilfreiche Liste von Shell-Werkzeugen und Quellen. awesome-osx-command-line: Eine ausführliche Anleitung für die Befehlszeile unter OS X. Strict mode, um bessere Shell-Skripte zu schreiben. shellcheck: Ein statisches Analysetool für Shell-Skripte. Im Grunde lint für bash/sh/zsh. Filenames and Pathnames in Shell: Entmutigend komplexe Einzelheiten darüber, wie Dateinamen in Shell-Skripts richtig eingesetzt werden. Data Science at the Command Line: Mehr Befehle und Werkzeuge, die für “data science” hilfreich sind, aus dem gleichnamigen Buch. HaftungsausschlussMit der Ausnahme einiger sehr kleiner Aufgaben ist der Code so geschrieben, dass andere ihn lesen können. Mit Macht kommt Verantwortung. Die Tatsache etwas in Bash tun zu können, heißt nicht zwangsläufig, dass du es tun solltest! Lizenz Dieses Werk ist lizensiert gemäß der Creative Commons Attribution-ShareAlike 4.0 International License.]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%9A%84%E8%89%BA%E6%9C%AF%2FREADME-cs%2F</url>
    <content type="text"><![CDATA[🌍Čeština ∙ Deutsch ∙ Ελληνικά ∙ English ∙ Español ∙ Français ∙ Indonesia ∙ Italiano ∙ 日本語 ∙ 한국어 ∙ Português ∙ Română ∙ Русский ∙ Slovenščina ∙ Українська ∙ 简体中文 ∙ 繁體中文 Umění příkazové řádky Meta Základy Každodenní použití Zpracování souborů a dat Ladění systému Jednořádkové příkazy Neobvyklé ale užitečné Pouze pro OS X Další zdroje Zřeknutí se odpovědnosti Plynulost práce na příkazové řádce je umění často opomíjené nebo považované za překonané, ale zlepšuje vaši flexibilitu a produktivitu jako inženýr jak očividně tak nenápadně. Toto je výběr poznámek a tipů pro použití příkazové řádky které shledáváme užitečnými při práci na Linuxu. Některé tipy jsou základní a některé jsou velmi specifické, komplikované či nejasné. Tato stránka není dlouhá, ale pokud dokážete použít a vybavit si všechny věci zde zmíněné, máte dostatečně rozsáhlé vědomosti. Tato práce je výsledkem mnoha autorů a překladatelů.Mnoho sepůvodněobjevilona webu Quora,ale s ohledem na zájem, který tam panoval, se zdálo vhodné použít GitHub, kde lidé více talentovaní než původní autor mohli okamžitě navrhovat zlepšení. Pokud najdete chybu či něco, co by mohlo být vylepšeno, prosím vytvořte issue nebo pull request! (Samozřejmě nejdříve zkontrolujte meta sekci a existující pull requesty a issues.) MetaRozsah: Tento průvodce je pro začátečníky i pro pokročilé. Cílem je široký záběr (vše důležité), specifičnost (poskytnout konkrétní příklady nejčastějšího použití) a stručnost (vyhnout se věcem, které nejsou nezbytné nebo podobným tématům, které lze vyhledat jinde). Každý tip je v některých případech nenahraditelný nebo značně šetří čas oproti alternativám. Tento dokument je napsán pro Linux s vyjímkou sekcí označených jako “Pouze pro OS X“. Mnoho ostatních položek lze použít nebo je lze nainstalovat na jiných Unixových systémech nebo MacOS (dokonce i na Cygwin). Zaměření dokumentu je na inteaktivní Bash ačkoli mnoho tipů lze aplikovat na jiné shelly a obecné bashové scriptování.. Jsou zahrnuty jak “standardní” Unixové příkazy tak příkazy vyžadující instalaci extra balíčků – pokud jsou dost důležité aby zasloužily zmínku. Poznámky: Pro udržení délky textu na jednu stranu, obsah je implicitně obsažen v odkazech. Jste dostatečně inteligentní aby jste si vyhledali více detailů z jiných zdrojů jakmile znáte příkaz či myšlenku na Googlu. Použijte apt-get, yum, dnf, pacman, pip nebo brew podle distribuce k instalaci nových progamů. Použijte Explainshell pro užitečné vysvětlení co příkazy, možnosti, roury a jiné dělají. Základy Naučte se základy Bashe. Vlastně, napište man bash a alespoň si to proleťte; je to celkem jednoduché a ne tak dlouhé. Jiné shelly mohou být dobré, ale Bash je mocný a vždy dostupný (znalost pouze zsh, fish a jiných ačkoli lákavá na vlastním notebooku omezuje v mnoha situacích, jako například při použití existujících serverů). Poznejte alespoň jeden textový editor dobře. Nejlépe Vim (vi) jelikož opravdu nemá pro občasné úpravy v terminálu nemá konkurenci (ani pokud většinu času používáte Emacs, velké IDE nebo moderní okenní editor). Naučte se číst dokumentaci pomocí man (pro zvědavce, man man vypíše čísla sekcí, například 1 jsou “obvyklé” příkazy, 5 jsou soubory/konvence a 8 je administrace). Hledejte manuálové stránky pomocí apropos. Vězte, že některé příkazy nejsou spustitelné programy, ale funkce zabudované v Bashi a nápovědu k nim můžete zobrazit příkazem help a help-d. Naučte se přesměrování výstupu a vstupu pomocí &gt; a &lt; a roury pomocí |. Pamatujte, že &gt; přepíše obsah výstupního souboru a &gt;&gt; přidá na jeho konec. Nezapomeňte na stdout (stndardní výstup) a stderr (standardní chybový výstup). Poznejte souborovou hromadnou expanzi za pomoci * (případně ? a […]) a úvozovkách a rozdílu mezi dvojitými uvozovkami &quot; a jednoduchými &#39;. (Více na expanzi proměných níže.) Seznamte se se správou činností v Bashi: &amp;, ctrl-z, ctrl-c**, jobs, fg, bg, kill, atd. Seznamte se s ssh a základy bezheslové autentizace pomocí ssh-agent, ssh-add, atd. Základní správa souborů: ls a ls -l (zejména co který sloupec v ls -l znamená), less, head, tail a tail -f (nebo ještě lépe less +F), ln a ln -s (pochopte rozdíly a výhody pevného odkazu a symoblického odkazu), chown, chmod, du (pro krátký souhrn využití disku: du -hs *). Pro správu souborového systému, df, mount, fdisk, mkfs, lsblk. Pochopte co je inode (ls -i nebo df -i). základní správa síťí: ip nebo ifconfig, dig. Dobře se naučte regulárních výrazů a rozličné příznaky pro grep/egrep. Přepínače -i, -o, -v, -A, -B a -C je také vhodné znát. Naučte se používat apt-get, yum, dnf nebo pacman (podle vaší distribuce) k hledání a instalaci balíků. A ujistěte se, že máte pip k instalace Pythonových terminálových nástrojů (některé je nejjednodušší nainstalovat pomocí pip). Každodenní použití V Bashi používejte Tab k dokončení argumentů nebo vylistování všech dostupných příkazů a ctrl-r k vyhledávání v historii příkazů (po stisknutí pište pro hledání a poté mačkejte opakovaně ctrl-r k procházení více shod, Enter k provedení nalezeného příkazu nebo šipku vpravo pro vložení výsledku hledání do terminálu a následnou editaci). V Bashi používejte ctrl-w pro smazní posledního slova a ctrl-u pro smazání všeho od současné pozice kurzoru až po začátek řádku. Používejte alt-b a alt-f k procházení řádku po slovech, ctrl-a pro skok na začátek řádku, ctrl-e pro skok kurzoru na konec řádku, ctrl-k pro smazání všeho od současné pozice až ke konci řádku, ctrl-l pro vyčištění obrazovky. Prohlédněte si man readline pro všechny defaultní klávesové zkratky v Bashi. Je jich hodně. Například alt-. projíždí předchozí argumenty a alt-* rozšíří řetězec. Pokud milujete klávesové zkratky ve stylu vi, použijte set -o vi (a set -o emacs pro návrat ke standardnímu rozložení). Pro úpravu dlouhých příkazů, po nastavení vašeho editoru (například export EDITOR=vim), ctrl-x ctrl-e v něm otevře stávající příkaz pro víceřádkovou úpravu. Nebo ve vi stylu, escape-v. Zobrazení nedávných příkazů se provádí pomocí history. Existuje spousta zkratek jako !$ (poslední argument) a !! (poslední příkaz), ale tyto jsou jednoduše nahraditelné pomocí ctrl-r a alt-.. Pro přechod do předchozího pracovního adresáře: cd -. Pokud máte zpola napsaný příkaz, ale rozmyslíte si to, stiskněte alt-# pro přidání # na začátek řádku a vložte ho jako komentář (nebo použijte ctrl-a, #, enter). Takto se k němu můžete později vrátit v historii příkazů. Používejte xargs (nebo parallel). Jde o mocný příkaz. Nezapomeňte, že můžete ovládat kolik položek se má vykonat na řádku (-L) stejně jako paralelismus (-P). Pokud si nejste jisti zda to udělá co má, zkuste nejdříve xargs echo. Hodí se také -I{}.Příklady: 12find . -name '*.py' | xargs grep nejaka_funkcecat hosts | xargs -I&#123;&#125; ssh root@&#123;&#125; hostname pstree -p je užitečné zobrazení stromu procesů. Používejte pgrep a pkill k hledání nebo posílání signálů procesům podle jména. (-f je také užitečné). Pamatujte si rozličné signály, které lze posílat procesům. Například, k pozastavení procesu, použijte kill -STOP [pid]. Celý seznam signálů v man 7 signal. Používejte nohup nebo disown pokud chcete, aby proces na pozadí běžel navždy. Kontrolujte, které procesy naslouchají pomocí netstat -lntp nebo ss -plat (pro TCP; přidejte -u pro UDP). Podívejte se také na lsof pro otevřené sockety a soubory. Jak dlouho systém běží poznáte díky uptime nebo w. Pomocí alias si nastavte zkratky pro často používané příkazy. Například alias ll=&#39;ls -latr&#39; vytvoří novou zkratku ll. V Bashových scriptech používejte set -x (nebo jeho variantu set -v, která zaznamenává nezpracovaný vstup včetně nečekaných proměnných a komentářů) pro ladící výstup. Používejte striktní módy pokud nemáte dobrý důvod proč to tak nedělat: Příkazem set -e nastavíte přerušení při chybě (nenulový návratový kód). Použijte set -u pro zjištění použití neinicializovaných proměnných. Zvažte také set -o pipefail pro chyby v rourách (přečtěte si na tohle téma více pokud tuto možnost využijete, jelikož jde o citlivé téma). Pro více zapojených scriptů použijte trap na EXIT nebo ERR. Dobrým zvykem bývá začínat scripty takto, což zachytí a ukončí běh na běžných chybách a vypíše zprávu: 12set -euo pipefailtrap "echo 'error: Script selhal: neuspesny prikaz vyse'" ERR V Bash scriptech jsou subshelly (psané s kulatými závorkami) vhodným způsobem shlukování příkazů. Běžným příkladem budiž dočasný přesun do jiného pracovního adresáře, například: 123# udelej neco v soucasnem pracovnim adresari(cd /nejaky/jiny/adresar &amp;&amp; jiny-prikaz)# pokracuj v puvodnim adresari Nezapomeňte, že v Bashi je mnoho druhů expanze proměnných. KOntrola, že proměnná existuje ${jmeno:?chybova hlaska}. například, pokud script vyžaduje jediný argument, napište vstupni_soubor=${1:?pouziti: $0 vstupni_soubor}. Aritmetická expanze: i=$(( (i + 1) % 5 )). Sekvence: {1..10}. Ořezání (trimming) řetězců: ${var%suffix} a ${var#prefix}. Pokud například var=foo.pdf, pak echo ${var%.pdf}.txt zobrazí foo.txt. Expanze složených závorek použitím {…} může snížit potřebu přepisovat podobné texty a zautomatizovat kombinaci položek. Toto může být užitečné například v mv foo.{txt,pdf} nejaky-adresar (což přesune oba soubory), cp nejakysoubor{,.bak} (což se rozšíří do cp nejakysoubor nejakysoubor.bak) nebo mkdir -p test-{a,b,c}/subtest-{1,2,3} (což se rozšíří do všech možných kombinací a vytvoří příslušný adresářový strom). S výstupem některých příkazů lze zacházet jako se souborem pomocí &lt;(nejaky prikaz). Například porovnání lokálního /etc/hosts se vzdáleným: 1diff /etc/hosts &lt;(ssh nejakyhost cat /etc/hosts) Poznejte “zdejší dokumenty” v Bashi, míněno cat &lt;&lt;EOF .... -Přesměrujte jak standardní výstup tak standardní chybový výstup v Bashi pomocí: nejaky-prikaz &gt; logsoubor 2&gt;&amp;1 nebo nejaky-prikaz &amp;&gt;logsoubor. Častokrát, k zajištění, že příkaz nezanechá otevřený souborový držák (handle), navázání ho na terminál ve kterém jste, je dobrá praktika také přidat &lt;/dev/null. Používejte man ascii pro dobrou ASCII tabulku se šestnáctkovými i dekadickými hodnotami. Pro obecné kódovací informace jsou užitečné man unicode, man utf-8 a man latin1. Používejte screen nebo tmux k rozšíření obrazovky, což je užitečné zejména na vzdálených ssh připojeních a k odpojení a znovu-připojení k sezení. byobu dokáže vylepšit obrazovku nebo tmux a poskytovat více informací a jednodušší správu. Více minimalistická varianta pouze pro přetrvání sezení je dtach. v ssh je důležité vědět, jak tunelovat porty s pomocí -L nebo -D (a příležitostně -R) například k přístupu na webovou stránku ze vzdáleného serveru. Může být užitečné udělat trochu optimalizačních úprav vašeho ssh připojení; například v ~/.ssh/config je nastavení pro vyhýbání se odhozeným spojením v jistých sítích, používá kompresi (což je užitečné se scp přeš síť s malou šířkou pásma připojení) a multiplexové kanály ke stejnému serveru v lokálním souboru. 1234567TCPKeepAlive=yesServerAliveInterval=15ServerAliveCountMax=6Compression=yesControlMaster autoControlPath /tmp/%r@%h:%pControlPersist yes Některé další možnosti vstahující se k ssh jsou bezpečnostně citlivé a měli by být povoleny s opatrností, například pro jednotlivé podsítě nebo hosty v důvěryhodných sítích: StrictHostKeyChecking=no, ForwardAgent=yes Zvažte mosh jako alternativu k ssh, která používá UDP, vyhýbá se padlým spojením a přidává pohodlí na cestách (vyžaduje nastavení na serveru). K získání oprávnění k souboru v osmičkové formě, což je užitečné pro systémovou konfiguraci, ale nedostupné v ls a lehko zpackatelné, použijte něco jako 1stat -c '%A %a %n' /etc/timezone Pro interaktivní výběr hodnot ze vstupu jiného příkazu použijte percol nebo fzf. Pro interakci se soubory v závislosti na vstupu jiného příkazu (třeba git), použijte fpp (PathPicker). Po zpřístupnění jednoduchého webového serveru pro všechny soubory v současném adresáři (a podadresářích), přístupného každému na vaší síti použijte:python -m SimpleHTTPServer 7777 (pro port 7777 a Python 2) a python -m http.server 7777 (pro port 7777 a Python 3). Pro spuštění příkazu s právy použijte sudo (pro roota) nebo sudo -u (pro jiného uživatele). Používejte su nebo sudo bash pokud chcete aby shell běžel skutečně pod daným uživatelem. Použitím su - simulujte čerstvé přihlášení jako root nebo jiný uživatel. Zpracovaní souboru a dat K nalezení souboru podle jména v pracovním adresáři: find . -iname &#39;*something*&#39; (nebo podobně). K nalezení souboru podle jména kdekoliv na disku, použijte locate jmeno (pamatujte, že updatedb nemuselo nutně zaindexovat nedávno vytvořené soubory). Pro obecné prohledávání zdrojů nebo datových souborů (více sofistikované než grep -r), použijte ag. Převeďte HTML na text pomocí lynx -dump -stdin. Vyzkoušejte pandoc pro Markdown, HTML a všechny druhy převodu dokumentů. Pokud musíte pracovat s XML xmlstarlet je starý, ale dobrý. Pro JSON použijte jq. Pro YAML, použijte shyaml. Pro Excel nebo CSV suobory, csvkit poskytuje in2csv, csvcut, csvjoin, csvgrep, atd. Pro Amazon S3, s3cmd je pohodlnější a s4cmd je rychlejší. aws od Amazonu a vylepšený saws jsou nezbytné pro ostatní AWS úkoly. Mějte přehled o sort a uniq, včetně přepínače -u pro uniq a -d – shlédněte jednořádkové příklady níže. A také comm. Mějte přehled také o cut, paste a join pro manipulaci s textovými soubory. Mnoho lidí používá cut, ale zapomínají na join. Udržujte přehled také o wc na počítání nových řádků (-l), znaků (-m), slov (-w) a bytů (-c). A přehled je dobré mít také o tee pro kopírování ze stdin do souboru a na stdout, podobně jako za použití ls -la | tee soubor.txt. Mějte na paměti, že nastavení lokalizace ovlivňuje mnoho příkazů v shellu mnoha způsoby včetně pořadí při třídění a výkonu. Většina Linuxových instalací nastaví LANG nebo jinou lokalizační proměnnou na lokální nastavení jako americká angličtina. Nezapomínejte však, že vaše třídění se změní změníte-li lokalizaci. A myslete na to, že i18n rutiny mohou způsobit, že třídění nebo jiné příkazy mohou běžet mnohokrát pomaleji. V některých situacích (při nastavování nebo testu unikátnost jako níže) lze bezpečně ignorovat pomalé i18n rutiny úplně a použít tradiční bytový pořádek pří třídění s export LC_ALL=C. Měli byste znát základní awk a sed pro jednoduché operace s daty. Například sčítání všech čísel ve třetím sloupci textového souboru: awk &#39;{ x += $3 } END { print x }&#39;. Tento příkaz je pravděpodobně 3x rychlejší a obsahuje 3x méně kódu než jeho ekvivalent v Pythonu. K nahrazení všech výskytů řetězce v jedno místě nebo ve více souborech: 1perl -pi.bak -e 's/stary-retezec/novy-retezec/g' moje-soubory-*.txt K přejmenování více souborů a/nebo vyhledávání a nahrazení uvnitř těchto souborů zkuste repren. (V některých případech příkazech rename také dovoluje vícenásobné přejmenování, ale buďte opatrní neboť není stejný na všech Linuxových distribucích). 123456# Plne jméno souboru, adresaru a obsahu foo -&gt; bar:repren --full --preserve-case --from foo --to bar .# Obnov zalozni soubory cokoliv.bak -&gt; cokoli:repren --renames --from '(.*)\.bak' --to '\1' *.bak# Stejne jako vyse za pouziti jmena pokud mozne:rename 's/\.bak$//' *.bak Jak říká manuálová stránka, rsync je skutečně rychlý a neobyčejně univerzální nástroj na kopírování souborů. Je znám pro synchronizaci mezi stroji, ale je stejně užitečný lokálně. Jde také o jednu z nejrychlejších cest k odstranění velkého množství souborů: 1mkdir prazdny &amp;&amp; rsync -r --delete prazdny/ nejaky-adr &amp;&amp; rmdir nejaky-adr Použijte shuf k zamíchání nebo vybrání náhodných řádek ze souboru. Mějte přehled v sort možnostech. Pro čísla, použijte -n nebo -h pro práci s lidsky čitelnými čísly (například z du -h). Pochopte jak fungují klíče (-t a -k). Zejména mějte na paměti, že musíte psát -k,1 pro třídění za použití pouze prvního pole; -k1 znamená třídění podle celého řádku. Stabilní třídění (sort -s) může být užitečné. Například k setřídění primárně podle druhého pole a sekundárně podle druhého pole můžete použít sort -k1,1 | sort -s -k2,2. Pokud někdy potřebujete zapsat znak tabulátor do příkazové řádky v Bashi (například pro -t argument pro třídění), stiskněte press ctrl-v [Tab] nebo napište $’\t’` (druhá možnost je lepší, protože výsledek můžete zkopírovat/vložit). Standardní nástroje pro porovnávání zdrojového kódu jsou diff a patch. Za zmínku stojí také diffstat zobrazující statistiky z diffu a sdiff pro rozdíly bok po boku. Nezapomeňte, že diff -r funguje pro celé adresáře. Použijte diff -r strom1 strom2 | diffstat pro shrnutí změn. A vimdiff pro porovnání a úpravu souborů. Pro binární soubory použijte hd, hexdump nebo xxd pro jednoduché hex dumpy a bvi nebo biew pro editaci binárek. Pro binární soubory můžete také použít strings (například spolu s grep, atd), což je nástroj pro hledání částí textu. Pro binární rozdíly (delta komprese) použijte xdelta3. Pro konverzi testových kódování zkuste iconv. Nebo uconv pro pokročilejší použití; podporuje některé pokročilé Unicode věci. Například tento příkaz mění text na malé znaky a odstraňuje akcenty (jejich rozvinutím a zahozením): 1uconv -f utf-8 -t utf-8 -x '::Any-Lower; ::Any-NFD; [:Nonspacing Mark:] &gt;; ::Any-NFC; ' &lt; input.txt &gt; output.txt Na rozdělení souborů do částí zkuste split (na rozdělení podle velikosti) a csplit (na rozdělení podle řetězce). K manipulaci s datem a časem použijte dateadd, datediff, strptime atd. z dateutils. Použijte zless, zmore, zcat, a zgrep k operacím s komprimovanými soubory. Ladění systému Pro webové ladění jsou vhodné curl a curl /I nebo jejich wget ekvivalenty nebo více moderní httpie. Pro zjištění současného procesorového/diskového stavu, klasické nástroje jako top (nebo lépe htop). Použijte iostat -mxz 15 pro základní CPU a detailní diskové stavy pro každý diskový oddíl a výkonostní statistiky. Pro detaily ohledně síťové konektivity použijte netstat a ss. Rychlý přehled co se děje v systému získáte pomocí užitečného dstat. Pro širší přehled s detaily použijte glances. Na zjištění stavu paměti spusťte free a vmstat a pokuste se porozumět jejich výstupům. Zejména dbejte na “cached” hodnotu což je paměť držená Linuxovým kernelem jako souborová cache, tudíž se počítá do “volné” paměťi. Ladění Javy je odlišný šálek čaje, ale jednoduchý trik na Javu od Oraclu a některé jiné JVM je, že stále můžete použít kill -3 &lt;pid&gt; a výpis zásobníku a haldy (včetně obecnějších detailů z garbage collectoru, které mohou být nesmírně informativní) bude zapsán do stderr/logs. Nástroje JDK jako jps, jstat, jstack a jmap jsou také užitečné, avšak SJK tools jsou více pokročilé. Použijte mtr jako lepší traceroute pro identifikování potíží se sítí. Při zjištování proč je disk plný, ncdu šetří čas oproti obvyklým příkazům jako du /sh *. Ke zjištění, který socket nebo proces zahlcuje pásmo, zkuste iftop nebo nethogs. Nástroj ab (přibalený k Apachi) je užitečný pro rychlé a hrubé zkontrolování výkonosti webového serveru. Komplexnější měření umožňuje siege. Pro důslednější síťové ladění, wireshark, tshark nebo ngrep jsou to pravé. Nezapomínejte na strace a ltrace. Mohou být nápomocné zejména pokud některý program selhává, zasekává se nebo padá a nevíte proč nebo pokud chcete mít obecnou představu o výkonu. Myslete na přepínač profilingu (-c) a schopnost připnout se k běžícímu procesu (-p). Dynamické knihovny vám umožní zkontrolovat ldd. Je důležité umět se připojit k běžícímu procesu za pomoci gdb a získat výpis jeho chodu. Používejte /proc. Je úžasně nápomocný v okamžicích, kdy ladíte živé problémy. Příklady: /proc/cpuinfo,/proc/meminfo,/proc/cmdline,/proc/xxx/cwd,/proc/xxx/exe,/proc/xxx/fd/,/proc/xxx/smaps(kdexxx` je id nebo pid procesu.). Když zjišťujete proč se něco v minulosti pokazilo, sar může být nedocenitelný. Ukazuje historické statistiky CPU, paměti, sítě, atd. Pro hlubší systémovou a výkonostní analýzu se podívejte na stap(SystemTap), perf), a sysdig. Zkontrolujte na jakém jste OS za pomoci uname nebo uname -a (obecné Unix/kernel informace) nebo lsb_release -a (v Linuxových distribucích). Použijte dmesg kdykoli se něco chová neočekávaně (může jít o hardwarový nebo driverový problém). Jednořádkové příkazyPár příkladů na spojování příkazů: Někdy je pozoruhodně užitečné dělat průnik, sjednocení a rozdíl textových souborů pomocí sort/uniq. Předpokládejte, že a a b jsou unikátní textové soubory. Toto je rychlé a funguje na souborech libovolné velikosti až do mnoha gigabytů. (Třídění pomocí sort není omezené pamětí, ale je možné, že budete muset použít -T přepínač, pokud se /tmp nachází na malém diskovém oddílu). Podívejte se také na poznámku o LC_ALL výše a přepínač sortu -u (vynechaný pro přehlednost). 123cat a b | sort | uniq &gt; c # c je sjednocení bcat a b | sort | uniq -d &gt; c # c je průnik bcat a b b | sort | uniq -u &gt; c # c je rozdíl a - b Použijte grep .* pro rychlé prošetření obsahu všech souborů v adresáři (každý soubor je spojen s názvem souboru) nebo head -100 * (aby každý soubor měl záhlaví). Může být užitečné pro adresáře s konfiguračními soubory jako jsou například /sys, /proc a /etc. Součet všech čísel ve třetím sloupci textového souboru (pravděpodobně 3x rychlejší a 3x méně kódu než ekvivalentní funkce v Pythonu): 1awk '&#123; x += $3 &#125; END &#123; print x &#125;' mujsoubor Pokud chcete zobrazit velikosti/datumy na souborovém stromu, následující příkaz je jako rekurzivní ls -l, ale jedodušší na čtení než ls -lR: 1find . -type f -ls Řekněme, že máte textový soubor, jako log webového serveru, a jisté hodnoty, které se objevují na některých řádcích, jako například acct_id parametr, který se vyskytuje v URL. Pokud chcete záznam kolik požadavků pro každý acct_id: 1cat access.log | egrep -o 'acct_id=[0-9]+' | cut -d= -f2 | sort | uniq -c | sort -rn K průběžnému monitorování změn použijte watch, například změn souborů v adresáři pomocí watch -d -n 2 &#39;ls -rth | tail&#39; nebo síťových nastavení při řešení potíží nastavení wifi: watch -d -n 2 ifconfig. Spusťte tuto funkci k získání náhodného tipu z tohoto dokumentu (parsuje Markdown a vyextrahuje jednu položku): 1234567function taocl() &#123; curl -s https://raw.githubusercontent.com/jlevy/the-art-of-command-line/master/README.md | pandoc -f markdown -t html | xmlstarlet fo --html --dropdtd | xmlstarlet sel -t -v "(html/body/ul/li[count(p)&gt;0])[$RANDOM mod last()+1]" | xmlstarlet unesc | fmt -80&#125; Neobvyklé ale užitečné expr: provede aritmetické nebo logické operace nebo vyhodnotí regulární výrazy m4: jednoduchý procesor maker yes: tiskne řetězec vícekrát cal: hezký kalendář env: provede příkaz (užitečné ve scriptech) printenv: vypíše proměnné prostředí (užitečné při ladění a ve scriptech) look: najde anglická slova (nebo řádky v souboru) začínající řetězcem cut, paste a join: manipulace s daty fmt: formátuje text do odstavců pr: formátuje text do stránek/sloupců fold: zalamuje řádky textu column: formátuje textová pole do zarovnaných sloupců nebo tabulek s danou šířkou expand a unexpand: převádí tabulátory a mezery nl: přidá čísla řádků seq: tiskne čísla bc: kalkulačka factor: provádí faktorizaci celých čísel (15 = 5 a 3) gpg: šifruje a podepisuje soubory toe: tabulka informací o dostupných terminálech nc: síťové ladění a přenos dat socat: socketové relé a tcp port přesměrování (podobné netcat) slurm: visualizace síťového provozu dd: přesun dat mezi soubory nebo zařízeními file: identifikuje typ souboru tree: zobrazí adresáře a podadresáře jako vnořený strom; podobně jako ls ale rekurzivně stat: informace o souboru time: provede a načasuje příkaz timeout: provádí příkaz po specifikovanou dobu a zastaví proces když daná doba uplyne lockfile: vytvoří semaforový soubor, který lze odstranit pouze pomocí rm -f logrotate: rotuje, komprimuje a posílá logy emailem watch: spouští opakovaně příkaz a zobrazuje výsledky a/nebo zvýrazňuje změny tac: tiskne soubory pozpátku (po řádcích) shuf: náhodně vybere řádky ze souboru comm: porovná seřazení soubory řádek po řádku pv: monitoruje postup dat skrz rouru hd, hexdump, xxd, biew a bvi: vypíše nebo edituje binární soubory strings: vypreparuje textové řetězce z binárních souborů tr: překládá znaky nebo s nimi manipuluje iconv nebo uconv: převod pro kódování textu split a csplit: dělí soubory sponge: čte všechen vstup před tím než ho zapíše, užitečné pro čtení a následný zápis do téhož souboru, např. grep -v neco nejaky-soubor | sponge nejaky-soubor units: převody jednotek a výpočty; převádí jednotky mezi sebou, (viz. /usr/share/units/definitions.units) apg: generuje náhodná hesla 7z: vysoko-poměrová datová komprese ldd: informace o dynamických knihovnách nm: vypíše symboly z objektových souborů ab: zátěžové testy webserverů strace: ladění systému mtr: vylepšení traceroute pro síťové ladění cssh: vizuální souběžný shell rsync: synchronizuje soubory a adresáře přes SSH nebo v lokálním systému souborů wireshark a tshark: zachytávání packetů a síťové ladění ngrep: grep pro síťovou vrstvu host a dig: DNS vyhledávání lsof: zpracovává souborové popisovače (descriptory) a informace o socketech dstat: užitečné systémové informace glances: vysoko úrovňový, multi-systémový přehled iostat: statistiky využití disku mpstat: statistiky využití CPU vmstat: statistiky využití paměti htop: vylepšená verze top (správa procesů) last: historie přihlášení w: kdo je přihlášen id: informace o identitě uživatele/skupiny sar: historické systémové statistiky iftop nebo nethogs: využití sítě pro proces nebo socket ss: statistika socketů dmesg: bootovací a systémové chybové zprávy sysctl: zobrazení a konfigurace parametrů Linuxového kernelu za běhu hdparm: SATA/ATA disková manipulace/výkon lsblk: seznam blokových zařízení: stromové zobrazení disků a diskových oddílů lshw, lscpu, lspci, lsusb, dmidecode: informace o hardwaru zahrnující CPU, BIOS, RAID, grafiku, zařízení, atd. lsmod a modinfo: seznam a detaily kernelových modulů fortune, ddate, a sl: hm, no, záleží jestli považujete parní lokomotivy a Zippyho citáty za “užitečné” Pouze pro OS XTyto věci jsou relevantní pouze pro macOS. Balíčky spravované pomocí brew (Homebrew) a/nebo port (MacPorts). Mohou být použity k instalaci mnoha předešlých příkazů na macOS. Kopírujte výstup jakéhokoli příkazu do desktopové aplikace pomocí pbcopy a vložte vstup z nějaké pomocí pbpaste. K povolení klávesy Option v Terminálu Mac OS jako klávesu Alt (pro použití v příkazech jako alt-b, alt-f, atd.), otevřete Předvolby -&gt; Profily -&gt; Klávesnice a zvolte “Použít Option jako Meta klávesu”. K otevření souboru za pomoci desktopové aplikace použijte open nebo open -a /Aplikace/Cokoli.app. Spotlight: Prohledávejte soubory s mdfind a vypište metadata (například EXIF informace fotografie) pomocí mdls. Nezapomínejte, že macOS je založen na BSD Unixu a mnoho příkazů (například ps, ls, tail, awk, sed) mají spoustu jemných odlišností od Linuxu, což je z velké části ovlivněno System V (System Five) stylem Unixu a GNU nástroji. Mnohokrát mmůžete rozdíl poznat podle manuálové stránky mající v nadpise “BSD General Commands Manual”. V některých případech mohou být GNU verze instalovány také (třeba gawk a gsed pro GNU awk a sed). Pokud píšete multi-platformní Bashové scripty, vyhýbejte se takovým příkazům (například, zvažte Python či perl) nebo pečlivě testujte. K získání informací o verzi vydání macOS použijte sw_vers. Další zdroje awesome-shell: Organizovaný seznam shellových nástrojů a zdrojů. awesome-osx-command-line: Průvodce Mac OS příkazovou řádkou více do hloubky. Striktní mód pro psaní lepších shellových scriptů. shellcheck: Nástroj pro statickou analýzu shellových scriptů. V podstatě lint pro bash/sh/zsh. Souborové názvy a cesty v shellu: Bohužel velmi komplexní drobnosti o korektní práci se souborovými jmény v shellových scriptech. Zřeknutí se odpovědnostiS vyjímkou velmi malých úkolů je kód psán tak, aby ho ostatní mohli přečíst. S mocí přichází zodpovědnost. Skutečnost, že něco můžete v Bashi udělat nemusí nutně znamenat, že byste měli! ;) License Tato práce je licencována pod Creative Commons Attribution-ShareAlike 4.0 International License.]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%9A%84%E8%89%BA%E6%9C%AF%2FREADME%2F</url>
    <content type="text"><![CDATA[🌍Čeština ∙ Deutsch ∙ Ελληνικά ∙ English ∙ Español ∙ Français ∙ Indonesia ∙ Italiano ∙ 日本語 ∙ 한국어 ∙ Português ∙ Română ∙ Русский ∙ Slovenščina ∙ Українська ∙ 简体中文 ∙ 繁體中文 The Art of Command LineNote: I’m looking for a new (and potentially paid) lead author to help expand this to a more comprehensive Guide. While it’s very popoular, it could be both deeper and more helpful. If you like to write and are close to being an expert on this material and willing to consider helping, please drop me a note at josh (0x40) holloway.com. –jlevy, Holloway Meta Basics Everyday use Processing files and data System debugging One-liners Obscure but useful macOS only Windows only More resources Disclaimer Fluency on the command line is a skill often neglected or considered arcane, but it improves your flexibility and productivity as an engineer in both obvious and subtle ways. This is a selection of notes and tips on using the command-line that we’ve found useful when working on Linux. Some tips are elementary, and some are fairly specific, sophisticated, or obscure. This page is not long, but if you can use and recall all the items here, you know a lot. This work is the result of many authors and translators.Some of thisoriginallyappearedon Quora,but it has since moved to GitHub, where people more talented than the original author have made numerous improvements.Please submit a question if you have a question related to the command line. Please contribute if you see an error or something that could be better! MetaScope: This guide is both for beginners and the experienced. The goals are breadth (everything important), specificity (give concrete examples of the most common case), and brevity (avoid things that aren’t essential or digressions you can easily look up elsewhere). Every tip is essential in some situation or significantly saves time over alternatives. This is written for Linux, with the exception of the “macOS only“ and “Windows only“ sections. Many of the other items apply or can be installed on other Unices or macOS (or even Cygwin). The focus is on interactive Bash, though many tips apply to other shells and to general Bash scripting. It includes both “standard” Unix commands as well as ones that require special package installs – so long as they are important enough to merit inclusion. Notes: To keep this to one page, content is implicitly included by reference. You’re smart enough to look up more detail elsewhere once you know the idea or command to Google. Use apt, yum, dnf, pacman, pip or brew (as appropriate) to install new programs. Use Explainshell to get a helpful breakdown of what commands, options, pipes etc. do. Basics Learn basic Bash. Actually, type man bash and at least skim the whole thing; it’s pretty easy to follow and not that long. Alternate shells can be nice, but Bash is powerful and always available (learning only zsh, fish, etc., while tempting on your own laptop, restricts you in many situations, such as using existing servers). Learn at least one text-based editor well. The nano editor is one of the simplest for basic editing (opening, editing, saving, searching). However, for the power user in a text terminal, there is no substitute for Vim (vi), the hard-to-learn but venerable, fast, and full-featured editor. Many people also use the classic Emacs, particularly for larger editing tasks. (Of course, any modern software developer working on an extensive project is unlikely to use only a pure text-based editor and should also be familiar with modern graphical IDEs and tools.) Finding documentation: Know how to read official documentation with man (for the inquisitive, man man lists the section numbers, e.g. 1 is “regular” commands, 5 is files/conventions, and 8 are for administration). Find man pages with apropos. Know that some commands are not executables, but Bash builtins, and that you can get help on them with help and help -d. You can find out whether a command is an executable, shell builtin or an alias by using type command. curl cheat.sh/command will give a brief “cheat sheet” with common examples of how to use a shell command. Learn about redirection of output and input using &gt; and &lt; and pipes using |. Know &gt; overwrites the output file and &gt;&gt; appends. Learn about stdout and stderr. Learn about file glob expansion with * (and perhaps ? and […]) and quoting and the difference between double &quot; and single &#39; quotes. (See more on variable expansion below.) Be familiar with Bash job management: &amp;, ctrl-z, ctrl-c, jobs, fg, bg, kill, etc. Know ssh, and the basics of passwordless authentication, via ssh-agent, ssh-add, etc. Basic file management: ls and ls -l (in particular, learn what every column in ls -l means), less, head, tail and tail -f (or even better, less +F), ln and ln -s (learn the differences and advantages of hard versus soft links), chown, chmod, du (for a quick summary of disk usage: du -hs *). For filesystem management, df, mount, fdisk, mkfs, lsblk. Learn what an inode is (ls -i or df -i). Basic network management: ip or ifconfig, dig, traceroute, route. Learn and use a version control management system, such as git. Know regular expressions well, and the various flags to grep/egrep. The -i, -o, -v, -A, -B, and -C options are worth knowing. Learn to use apt-get, yum, dnf or pacman (depending on distro) to find and install packages. And make sure you have pip to install Python-based command-line tools (a few below are easiest to install via pip). Everyday use In Bash, use Tab to complete arguments or list all available commands and ctrl-r to search through command history (after pressing, type to search, press ctrl-r repeatedly to cycle through more matches, press Enter to execute the found command, or hit the right arrow to put the result in the current line to allow editing). In Bash, use ctrl-w to delete the last word, and ctrl-u to delete the content from current cursor back to the start of the line. Use alt-b and alt-f to move by word, ctrl-a to move cursor to beginning of line, ctrl-e to move cursor to end of line, ctrl-k to kill to the end of the line, ctrl-l to clear the screen. See man readline for all the default keybindings in Bash. There are a lot. For example alt-. cycles through previous arguments, and alt-* expands a glob. Alternatively, if you love vi-style key-bindings, use set -o vi (and set -o emacs to put it back). For editing long commands, after setting your editor (for example export EDITOR=vim), ctrl-x ctrl-e will open the current command in an editor for multi-line editing. Or in vi style, escape-v. To see recent commands, use history. Follow with !n (where n is the command number) to execute again. There are also many abbreviations you can use, the most useful probably being !$ for last argument and !! for last command (see “HISTORY EXPANSION” in the man page). However, these are often easily replaced with ctrl-r and alt-.. Go to your home directory with cd. Access files relative to your home directory with the ~ prefix (e.g. ~/.bashrc). In sh scripts refer to the home directory as $HOME. To go back to the previous working directory: cd -. If you are halfway through typing a command but change your mind, hit alt-# to add a # at the beginning and enter it as a comment (or use ctrl-a, #, enter). You can then return to it later via command history. Use xargs (or parallel). It’s very powerful. Note you can control how many items execute per line (-L) as well as parallelism (-P). If you’re not sure if it’ll do the right thing, use xargs echo first. Also, -I{} is handy. Examples: 12find . -name '*.py' | xargs grep some_functioncat hosts | xargs -I&#123;&#125; ssh root@&#123;&#125; hostname pstree -p is a helpful display of the process tree. Use pgrep and pkill to find or signal processes by name (-f is helpful). Know the various signals you can send processes. For example, to suspend a process, use kill -STOP [pid]. For the full list, see man 7 signal Use nohup or disown if you want a background process to keep running forever. Check what processes are listening via netstat -lntp or ss -plat (for TCP; add -u for UDP) or lsof -iTCP -sTCP:LISTEN -P -n (which also works on macOS). See also lsof and fuser for open sockets and files. See uptime or w to know how long the system has been running. Use alias to create shortcuts for commonly used commands. For example, alias ll=&#39;ls -latr&#39; creates a new alias ll. Save aliases, shell settings, and functions you commonly use in ~/.bashrc, and arrange for login shells to source it. This will make your setup available in all your shell sessions. Put the settings of environment variables as well as commands that should be executed when you login in ~/.bash_profile. Separate configuration will be needed for shells you launch from graphical environment logins and cron jobs. Synchronize your configuration files (e.g. .bashrc and .bash_profile) among various computers with Git. Understand that care is needed when variables and filenames include whitespace. Surround your Bash variables with quotes, e.g. &quot;$FOO&quot;. Prefer the -0 or -print0 options to enable null characters to delimit filenames, e.g. locate -0 pattern | xargs -0 ls -al or find / -print0 -type d | xargs -0 ls -al. To iterate on filenames containing whitespace in a for loop, set your IFS to be a newline only using IFS=$&#39;\n&#39;. In Bash scripts, use set -x (or the variant set -v, which logs raw input, including unexpanded variables and comments) for debugging output. Use strict modes unless you have a good reason not to: Use set -e to abort on errors (nonzero exit code). Use set -u to detect unset variable usages. Consider set -o pipefail too, to abort on errors within pipes (though read up on it more if you do, as this topic is a bit subtle). For more involved scripts, also use trap on EXIT or ERR. A useful habit is to start a script like this, which will make it detect and abort on common errors and print a message: 12set -euo pipefailtrap "echo 'error: Script failed: see failed command above'" ERR In Bash scripts, subshells (written with parentheses) are convenient ways to group commands. A common example is to temporarily move to a different working directory, e.g. 123# do something in current dir(cd /some/other/dir &amp;&amp; other-command)# continue in original dir In Bash, note there are lots of kinds of variable expansion. Checking a variable exists: ${name:?error message}. For example, if a Bash script requires a single argument, just write input_file=${1:?usage: $0 input_file}. Using a default value if a variable is empty: ${name:-default}. If you want to have an additional (optional) parameter added to the previous example, you can use something like output_file=${2:-logfile}. If $2 is omitted and thus empty, output_file will be set to logfile. Arithmetic expansion: i=$(( (i + 1) % 5 )). Sequences: {1..10}. Trimming of strings: ${var%suffix} and ${var#prefix}. For example if var=foo.pdf, then echo ${var%.pdf}.txt prints foo.txt. Brace expansion using {…} can reduce having to re-type similar text and automate combinations of items. This is helpful in examples like mv foo.{txt,pdf} some-dir (which moves both files), cp somefile{,.bak} (which expands to cp somefile somefile.bak) or mkdir -p test-{a,b,c}/subtest-{1,2,3} (which expands all possible combinations and creates a directory tree). Brace expansion is performed before any other expansion. The order of expansions is: brace expansion; tilde expansion, parameter and variable expansion, arithmetic expansion, and command substitution (done in a left-to-right fashion); word splitting; and filename expansion. (For example, a range like {1..20} cannot be expressed with variables using {$a..$b}. Use seq or a for loop instead, e.g., seq $a $b or for((i=a; i&lt;=b; i++)); do ... ; done.) The output of a command can be treated like a file via &lt;(some command) (known as process substitution). For example, compare local /etc/hosts with a remote one: 1diff /etc/hosts &lt;(ssh somehost cat /etc/hosts) When writing scripts you may want to put all of your code in curly braces. If the closing brace is missing, your script will be prevented from executing due to a syntax error. This makes sense when your script is going to be downloaded from the web, since it prevents partially downloaded scripts from executing: 123&#123; # Your code here&#125; A “here document” allows redirection of multiple lines of input as if from a file: 1234cat &lt;&lt;EOFinputon multiple linesEOF In Bash, redirect both standard output and standard error via: some-command &gt;logfile 2&gt;&amp;1 or some-command &amp;&gt;logfile. Often, to ensure a command does not leave an open file handle to standard input, tying it to the terminal you are in, it is also good practice to add &lt;/dev/null. Use man ascii for a good ASCII table, with hex and decimal values. For general encoding info, man unicode, man utf-8, and man latin1 are helpful. Use screen or tmux to multiplex the screen, especially useful on remote ssh sessions and to detach and re-attach to a session. byobu can enhance screen or tmux by providing more information and easier management. A more minimal alternative for session persistence only is dtach. In ssh, knowing how to port tunnel with -L or -D (and occasionally -R) is useful, e.g. to access web sites from a remote server. It can be useful to make a few optimizations to your ssh configuration; for example, this ~/.ssh/config contains settings to avoid dropped connections in certain network environments, uses compression (which is helpful with scp over low-bandwidth connections), and multiplex channels to the same server with a local control file: 1234567TCPKeepAlive=yesServerAliveInterval=15ServerAliveCountMax=6Compression=yesControlMaster autoControlPath /tmp/%r@%h:%pControlPersist yes A few other options relevant to ssh are security sensitive and should be enabled with care, e.g. per subnet or host or in trusted networks: StrictHostKeyChecking=no, ForwardAgent=yes Consider mosh an alternative to ssh that uses UDP, avoiding dropped connections and adding convenience on the road (requires server-side setup). To get the permissions on a file in octal form, which is useful for system configuration but not available in ls and easy to bungle, use something like 1stat -c '%A %a %n' /etc/timezone For interactive selection of values from the output of another command, use percol or fzf. For interaction with files based on the output of another command (like git), use fpp (PathPicker). For a simple web server for all files in the current directory (and subdirs), available to anyone on your network, use:python -m SimpleHTTPServer 7777 (for port 7777 and Python 2) and python -m http.server 7777 (for port 7777 and Python 3). For running a command as another user, use sudo. Defaults to running as root; use -u to specify another user. Use -i to login as that user (you will be asked for your password). For switching the shell to another user, use su username or su - username. The latter with “-“ gets an environment as if another user just logged in. Omitting the username defaults to root. You will be asked for the password of the user you are switching to. Know about the 128K limit on command lines. This “Argument list too long” error is common when wildcard matching large numbers of files. (When this happens alternatives like find and xargs may help.) For a basic calculator (and of course access to Python in general), use the python interpreter. For example, 12&gt;&gt;&gt; 2+35 Processing files and data To locate a file by name in the current directory, find . -iname &#39;*something*&#39; (or similar). To find a file anywhere by name, use locate something (but bear in mind updatedb may not have indexed recently created files). For general searching through source or data files, there are several options more advanced or faster than grep -r, including (in rough order from older to newer) ack, ag (“the silver searcher”), and rg (ripgrep). To convert HTML to text: lynx -dump -stdin For Markdown, HTML, and all kinds of document conversion, try pandoc. For example, to convert a Markdown document to Word format: pandoc README.md --from markdown --to docx -o temp.docx If you must handle XML, xmlstarlet is old but good. For JSON, use jq. For interactive use, also see jid and jiq. For YAML, use shyaml. For Excel or CSV files, csvkit provides in2csv, csvcut, csvjoin, csvgrep, etc. For Amazon S3, s3cmd is convenient and s4cmd is faster. Amazon’s aws and the improved saws are essential for other AWS-related tasks. Know about sort and uniq, including uniq’s -u and -d options – see one-liners below. See also comm. Know about cut, paste, and join to manipulate text files. Many people use cut but forget about join. Know about wc to count newlines (-l), characters (-m), words (-w) and bytes (-c). Know about tee to copy from stdin to a file and also to stdout, as in ls -al | tee file.txt. For more complex calculations, including grouping, reversing fields, and statistical calculations, consider datamash. Know that locale affects a lot of command line tools in subtle ways, including sorting order (collation) and performance. Most Linux installations will set LANG or other locale variables to a local setting like US English. But be aware sorting will change if you change locale. And know i18n routines can make sort or other commands run many times slower. In some situations (such as the set operations or uniqueness operations below) you can safely ignore slow i18n routines entirely and use traditional byte-based sort order, using export LC_ALL=C. You can set a specific command’s environment by prefixing its invocation with the environment variable settings, as in TZ=Pacific/Fiji date. Know basic awk and sed for simple data munging. See One-liners for examples. To replace all occurrences of a string in place, in one or more files: 1perl -pi.bak -e 's/old-string/new-string/g' my-files-*.txt To rename multiple files and/or search and replace within files, try repren. (In some cases the rename command also allows multiple renames, but be careful as its functionality is not the same on all Linux distributions.) 123456# Full rename of filenames, directories, and contents foo -&gt; bar:repren --full --preserve-case --from foo --to bar .# Recover backup files whatever.bak -&gt; whatever:repren --renames --from '(.*)\.bak' --to '\1' *.bak# Same as above, using rename, if available:rename 's/\.bak$//' *.bak As the man page says, rsync really is a fast and extraordinarily versatile file copying tool. It’s known for synchronizing between machines but is equally useful locally. When security restrictions allow, using rsync instead of scp allows recovery of a transfer without restarting from scratch. It also is among the fastest ways to delete large numbers of files: 1mkdir empty &amp;&amp; rsync -r --delete empty/ some-dir &amp;&amp; rmdir some-dir For monitoring progress when processing files, use pv, pycp, pmonitor, progress, rsync --progress, or, for block-level copying, dd status=progress. Use shuf to shuffle or select random lines from a file. Know sort‘s options. For numbers, use -n, or -h for handling human-readable numbers (e.g. from du -h). Know how keys work (-t and -k). In particular, watch out that you need to write -k1,1 to sort by only the first field; -k1 means sort according to the whole line. Stable sort (sort -s) can be useful. For example, to sort first by field 2, then secondarily by field 1, you can use sort -k1,1 | sort -s -k2,2. If you ever need to write a tab literal in a command line in Bash (e.g. for the -t argument to sort), press ctrl-v [Tab] or write $&#39;\t&#39; (the latter is better as you can copy/paste it). The standard tools for patching source code are diff and patch. See also diffstat for summary statistics of a diff and sdiff for a side-by-side diff. Note diff -r works for entire directories. Use diff -r tree1 tree2 | diffstat for a summary of changes. Use vimdiff to compare and edit files. For binary files, use hd, hexdump or xxd for simple hex dumps and bvi, hexedit or biew for binary editing. Also for binary files, strings (plus grep, etc.) lets you find bits of text. For binary diffs (delta compression), use xdelta3. To convert text encodings, try iconv. Or uconv for more advanced use; it supports some advanced Unicode things. For example: 12345# Displays hex codes or actual names of characters (useful for debugging):uconv -f utf-8 -t utf-8 -x '::Any-Hex;' &lt; input.txtuconv -f utf-8 -t utf-8 -x '::Any-Name;' &lt; input.txt# Lowercase and removes all accents (by expanding and dropping them):uconv -f utf-8 -t utf-8 -x '::Any-Lower; ::Any-NFD; [:Nonspacing Mark:] &gt;; ::Any-NFC;' &lt; input.txt &gt; output.txt To split files into pieces, see split (to split by size) and csplit (to split by a pattern). Date and time: To get the current date and time in the helpful ISO 8601 format, use date -u +&quot;%Y-%m-%dT%H:%M:%SZ&quot; (other options are problematic). To manipulate date and time expressions, use dateadd, datediff, strptime etc. from dateutils. Use zless, zmore, zcat, and zgrep to operate on compressed files. File attributes are settable via chattr and offer a lower-level alternative to file permissions. For example, to protect against accidental file deletion the immutable flag: sudo chattr +i /critical/directory/or/file Use getfacl and setfacl to save and restore file permissions. For example: 12getfacl -R /some/path &gt; permissions.txtsetfacl --restore=permissions.txt To create empty files quickly, use truncate (creates sparse file), fallocate (ext4, xfs, btrfs and ocfs2 filesystems), xfs_mkfile (almost any filesystems, comes in xfsprogs package), mkfile (for Unix-like systems like Solaris, Mac OS). System debugging For web debugging, curl and curl -I are handy, or their wget equivalents, or the more modern httpie. To know current cpu/disk status, the classic tools are top (or the better htop), iostat, and iotop. Use iostat -mxz 15 for basic CPU and detailed per-partition disk stats and performance insight. For network connection details, use netstat and ss. For a quick overview of what’s happening on a system, dstat is especially useful. For broadest overview with details, use glances. To know memory status, run and understand the output of free and vmstat. In particular, be aware the “cached” value is memory held by the Linux kernel as file cache, so effectively counts toward the “free” value. Java system debugging is a different kettle of fish, but a simple trick on Oracle’s and some other JVMs is that you can run kill -3 &lt;pid&gt; and a full stack trace and heap summary (including generational garbage collection details, which can be highly informative) will be dumped to stderr/logs. The JDK’s jps, jstat, jstack, jmap are useful. SJK tools are more advanced. Use mtr as a better traceroute, to identify network issues. For looking at why a disk is full, ncdu saves time over the usual commands like du -sh *. To find which socket or process is using bandwidth, try iftop or nethogs. The ab tool (comes with Apache) is helpful for quick-and-dirty checking of web server performance. For more complex load testing, try siege. For more serious network debugging, wireshark, tshark, or ngrep. Know about strace and ltrace. These can be helpful if a program is failing, hanging, or crashing, and you don’t know why, or if you want to get a general idea of performance. Note the profiling option (-c), and the ability to attach to a running process (-p). Use trace child option (-f) to avoid missing important calls. Know about ldd to check shared libraries etc — but never run it on untrusted files. Know how to connect to a running process with gdb and get its stack traces. Use /proc. It’s amazingly helpful sometimes when debugging live problems. Examples: /proc/cpuinfo, /proc/meminfo, /proc/cmdline, /proc/xxx/cwd, /proc/xxx/exe, /proc/xxx/fd/, /proc/xxx/smaps (where xxx is the process id or pid). When debugging why something went wrong in the past, sar can be very helpful. It shows historic statistics on CPU, memory, network, etc. For deeper systems and performance analyses, look at stap (SystemTap), perf, and sysdig. Check what OS you’re on with uname or uname -a (general Unix/kernel info) or lsb_release -a (Linux distro info). Use dmesg whenever something’s acting really funny (it could be hardware or driver issues). If you delete a file and it doesn’t free up expected disk space as reported by du, check whether the file is in use by a process:lsof | grep deleted | grep &quot;filename-of-my-big-file&quot; One-linersA few examples of piecing together commands: It is remarkably helpful sometimes that you can do set intersection, union, and difference of text files via sort/uniq. Suppose a and b are text files that are already uniqued. This is fast, and works on files of arbitrary size, up to many gigabytes. (Sort is not limited by memory, though you may need to use the -T option if /tmp is on a small root partition.) See also the note about LC_ALL above and sort‘s -u option (left out for clarity below). 123sort a b | uniq &gt; c # c is a union bsort a b | uniq -d &gt; c # c is a intersect bsort a b b | uniq -u &gt; c # c is set difference a - b Pretty-print two JSON files, normalizing their syntax, then coloring and paginating the result: 1diff &lt;(jq --sort-keys . &lt; file1.json) &lt;(jq --sort-keys . &lt; file2.json) | colordiff | less -R Use grep . * to quickly examine the contents of all files in a directory (so each line is paired with the filename), or head -100 * (so each file has a heading). This can be useful for directories filled with config settings like those in /sys, /proc, /etc. Summing all numbers in the third column of a text file (this is probably 3X faster and 3X less code than equivalent Python): 1awk '&#123; x += $3 &#125; END &#123; print x &#125;' myfile To see sizes/dates on a tree of files, this is like a recursive ls -l but is easier to read than ls -lR: 1find . -type f -ls Say you have a text file, like a web server log, and a certain value that appears on some lines, such as an acct_id parameter that is present in the URL. If you want a tally of how many requests for each acct_id: 1egrep -o 'acct_id=[0-9]+' access.log | cut -d= -f2 | sort | uniq -c | sort -rn To continuously monitor changes, use watch, e.g. check changes to files in a directory with watch -d -n 2 &#39;ls -rtlh | tail&#39; or to network settings while troubleshooting your wifi settings with watch -d -n 2 ifconfig. Run this function to get a random tip from this document (parses Markdown and extracts an item): 12345678function taocl() &#123; curl -s https://raw.githubusercontent.com/jlevy/the-art-of-command-line/master/README.md | sed '/cowsay[.]png/d' | pandoc -f markdown -t html | xmlstarlet fo --html --dropdtd | xmlstarlet sel -t -v "(html/body/ul/li[count(p)&gt;0])[$RANDOM mod last()+1]" | xmlstarlet unesc | fmt -80 | iconv -t US&#125; Obscure but useful expr: perform arithmetic or boolean operations or evaluate regular expressions m4: simple macro processor yes: print a string a lot cal: nice calendar env: run a command (useful in scripts) printenv: print out environment variables (useful in debugging and scripts) look: find English words (or lines in a file) beginning with a string cut, paste and join: data manipulation fmt: format text paragraphs pr: format text into pages/columns fold: wrap lines of text column: format text fields into aligned, fixed-width columns or tables expand and unexpand: convert between tabs and spaces nl: add line numbers seq: print numbers bc: calculator factor: factor integers gpg: encrypt and sign files toe: table of terminfo entries nc: network debugging and data transfer socat: socket relay and tcp port forwarder (similar to netcat) slurm: network traffic visualization dd: moving data between files or devices file: identify type of a file tree: display directories and subdirectories as a nesting tree; like ls but recursive stat: file info time: execute and time a command timeout: execute a command for specified amount of time and stop the process when the specified amount of time completes. lockfile: create semaphore file that can only be removed by rm -f logrotate: rotate, compress and mail logs. watch: run a command repeatedly, showing results and/or highlighting changes when-changed: runs any command you specify whenever it sees file changed. See inotifywait and entr as well. tac: print files in reverse comm: compare sorted files line by line strings: extract text from binary files tr: character translation or manipulation iconv or uconv: conversion for text encodings split and csplit: splitting files sponge: read all input before writing it, useful for reading from then writing to the same file, e.g., grep -v something some-file | sponge some-file units: unit conversions and calculations; converts furlongs per fortnight to twips per blink (see also /usr/share/units/definitions.units) apg: generates random passwords xz: high-ratio file compression ldd: dynamic library info nm: symbols from object files ab or wrk: benchmarking web servers strace: system call debugging mtr: better traceroute for network debugging cssh: visual concurrent shell rsync: sync files and folders over SSH or in local file system wireshark and tshark: packet capture and network debugging ngrep: grep for the network layer host and dig: DNS lookups lsof: process file descriptor and socket info dstat: useful system stats glances: high level, multi-subsystem overview iostat: Disk usage stats mpstat: CPU usage stats vmstat: Memory usage stats htop: improved version of top last: login history w: who’s logged on id: user/group identity info sar: historic system stats iftop or nethogs: network utilization by socket or process ss: socket statistics dmesg: boot and system error messages sysctl: view and configure Linux kernel parameters at run time hdparm: SATA/ATA disk manipulation/performance lsblk: list block devices: a tree view of your disks and disk partitions lshw, lscpu, lspci, lsusb, dmidecode: hardware information, including CPU, BIOS, RAID, graphics, devices, etc. lsmod and modinfo: List and show details of kernel modules. fortune, ddate, and sl: um, well, it depends on whether you consider steam locomotives and Zippy quotations “useful” macOS onlyThese are items relevant only on macOS. Package management with brew (Homebrew) and/or port (MacPorts). These can be used to install on macOS many of the above commands. Copy output of any command to a desktop app with pbcopy and paste input from one with pbpaste. To enable the Option key in macOS Terminal as an alt key (such as used in the commands above like alt-b, alt-f, etc.), open Preferences -&gt; Profiles -&gt; Keyboard and select “Use Option as Meta key”. To open a file with a desktop app, use open or open -a /Applications/Whatever.app. Spotlight: Search files with mdfind and list metadata (such as photo EXIF info) with mdls. Be aware macOS is based on BSD Unix, and many commands (for example ps, ls, tail, awk, sed) have many subtle variations from Linux, which is largely influenced by System V-style Unix and GNU tools. You can often tell the difference by noting a man page has the heading “BSD General Commands Manual.” In some cases GNU versions can be installed, too (such as gawk and gsed for GNU awk and sed). If writing cross-platform Bash scripts, avoid such commands (for example, consider Python or perl) or test carefully. To get macOS release information, use sw_vers. Windows onlyThese items are relevant only on Windows. Ways to obtain Unix tools under Windows Access the power of the Unix shell under Microsoft Windows by installing Cygwin. Most of the things described in this document will work out of the box. On Windows 10, you can use Windows Subsystem for Linux (WSL), which provides a familiar Bash environment with Unix command line utilities. If you mainly want to use GNU developer tools (such as GCC) on Windows, consider MinGW and its MSYS package, which provides utilities such as bash, gawk, make and grep. MSYS doesn’t have all the features compared to Cygwin. MinGW is particularly useful for creating native Windows ports of Unix tools. Another option to get Unix look and feel under Windows is Cash. Note that only very few Unix commands and command-line options are available in this environment. Useful Windows command-line tools You can perform and script most Windows system administration tasks from the command line by learning and using wmic. Native command-line Windows networking tools you may find useful include ping, ipconfig, tracert, and netstat. You can perform many useful Windows tasks by invoking the Rundll32 command. Cygwin tips and tricks Install additional Unix programs with the Cygwin’s package manager. Use mintty as your command-line window. Access the Windows clipboard through /dev/clipboard. Run cygstart to open an arbitrary file through its registered application. Access the Windows registry with regtool. Note that a C:\ Windows drive path becomes /cygdrive/c under Cygwin, and that Cygwin’s / appears under C:\cygwin on Windows. Convert between Cygwin and Windows-style file paths with cygpath. This is most useful in scripts that invoke Windows programs. More resources awesome-shell: A curated list of shell tools and resources. awesome-osx-command-line: A more in-depth guide for the macOS command line. Strict mode for writing better shell scripts. shellcheck: A shell script static analysis tool. Essentially, lint for bash/sh/zsh. Filenames and Pathnames in Shell: The sadly complex minutiae on how to handle filenames correctly in shell scripts. Data Science at the Command Line: More commands and tools helpful for doing data science, from the book of the same name DisclaimerWith the exception of very small tasks, code is written so others can read it. With power comes responsibility. The fact you can do something in Bash doesn’t necessarily mean you should! ;) License This work is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License.]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%9A%84%E8%89%BA%E6%9C%AF%2FCONTRIBUTING%2F</url>
    <content type="text"><![CDATA[Contributing to The Art of Command LineThis guide is a collaborative effort, based on the generous work of many contributors. Questions The simplest thing you can do to help is submit any questions you might have.The more the better. Questions help identify where the guide needs to be improved. ContributionsContributions of all kinds, including corrections, additions, improvements, and translations, are welcome! We hope you’ll join and help, in small ways or large.Here are few notes before you jump in. Style Stay close to the existing style of the document when possible. Remember to focus on brevity, specificity, and utility. Avoid long explanations and instead prefer links to resources. Using issues and PRs Please create and comment on issues freely to discuss. A lot of the difficulty in accepting PRs is around style and format, and whether changes should be made at all, so rationale or explanations for the change are useful. Please review open issues and pull requests before submitting a new one, to help reduce duplication. To the extent possible, break up changes into multiple PRs so they can be approved separately. Large contributions are also welcome, but are harder and slower to approve, as they tend to require discussion or rewriting. TranslationsThe guide is now available in many languages. Here is the process for maintaining translations: This original version and content of the guide is maintained in English. Translations follow the content of the original. Note this means contributors to a translation must be able to read some English, so that translations do not diverge (unless it is only fixing a typo). Each translation has a maintainer to update the translation as the original evolves and to review others’ changes. This doesn’t require a lot of time, but review by the maintainer is important to maintain quality. See the AUTHORS.md file for current maintainers. (This file is generated from the authors-info.yml file.) Changes to translations Changes to content should be made to the English version first, and then translated to each other language. Changes that improve translations should be made directly on the file for that language. PRs should only modify one language at a time. Submit a PR with changes to the file in that language. Each language has a maintainer, who reviews changes in that language. Then the primary maintainer @jlevy merges it in. Prefix PRs and issues with language codes if they are for that translation only, e.g. “es: Improve grammar”, so maintainers can find them easily. Adding a translation to a new languageTranslations to new languages are always welcome! Keep in mind a transation must be maintained, so it’s needed to have one person maintain each translation. Check existing issues to see if a translation is in progress or stalled. If so, offer to help. Do you have time to be a maintainer for the new language? Please say so so we know we can count on you in the future. If it is not in progress, file an issue for your language so people know you are working on it and we can arrange. Confirm you are native level in the language and are willing to maintain the translation, so it’s not orphaned. To get it started, fork the repo, then submit a PR with the single file README-xx.md added, where xx is the language code. Use standard IETF language tags, i.e. the same as is used by Wikipedia, not the code for a single country. These are usually just the two-letter lowercase code, for example, fr for French and uk for Ukrainian (not ua, which is for the country). For languages that have variations, use the shortest tag, such as zh-Hant. Invite friends to review if possible. Tranlsations are difficult and usually have erros others need to find. If desired, feel free to invite them to help your original translation by letting them fork your repo, then merging their PRs. Add links to your translation at the top of every README*.md file. (For consistency, the link should be added in alphabetical order by ISO code, and the anchor text should be in the native language.) When done, indicate on the PR that it’s ready to be merged into the main repo. Further questionsUnsure of the process?Or do you have skills and inclination to help in a more substantial way?File an issue or e-mail the original author @jlevy.]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%9A%84%E8%89%BA%E6%9C%AF%2FAUTHORS%2F</url>
    <content type="text"><![CDATA[AuthorsThis work is the result of the effort of many people around the world.Contributors are listed in alphabetical order by GitHub login. Some contributors are also assigned roles as maintainers.They have kindly agreed to review and help update future contributions for the translation or section they own. Maintainers Ahmad Zafrullah (23Pstars) — 3+/1+ — translation maintainer (id) Anna Damtsa (anna-d) — 24+/7+ — translation maintainer (el) Carlos Mantilla (ceoaliongroo) — 29+/16+ — translation maintainer (es) Dmytro Kovalov (uk: Дмитро Ковальов) (dmytro) — 6+/4+ — translation maintainer (uk) Hayato Matsuura (doublemarket) — 2+/1+ — translation maintainer (ja) Diomidis Spinellis (dspinellis) — 15+/11+ — section maintainer (Windows) Éric Guirbal (ericguirbal) — 31+/14+ — translation maintainer (fr) Francesco Malatesta (francescomalatesta) — 0+/3+ — translation maintainer (it) Joshua Levy (jlevy) — 162+/59+ — original author and project maintainer kevingo (kevingo) — 0+/2+ — translation maintainer (zh-Hant) lsrom — 14+/2+ — translation maintainer (cs) Mihai Maruseac (mihaimaruseac) — 10+/3+ — translation maintainer (ro) Nilton Vasques (niltonvasques) — 24+/2+ — translation maintainer (pt) Oleg Berman (olegberman) — 15+/2+ — translation maintainer (ru) Peter Kokot (petk) — 54+/39+ — translation maintainer (sl) Chujie Zeng (Psycho7) — 25+/9+ — translation maintainer (zh) Martin Folkers (S1SYPHOS) — 0+/1+ — translation maintainer (de) Stepan Babala (stepan0904) — 37+/6+ — translation (uk) Ungsik Yun (Ungsik-Yun) — 15+/3+ — translation maintainer (ko) Translators Antonio Ossa (aaossa) — 5+/1+ — translator (es) Chong Guo (Armour) — 2+/0+ — translator (zh) Bogdan Luput (bgdnlp) — translator (ro) Alex Vergara Gil (BishopWolf) — 4+/3+ — translator (es) Gernot Pointner (gernd) — 6+/1+ — translator (de) githubashto — 1+/0+ — translator (ru) Grigory Rechistov (grigory-rechistov) — 1+/0+ — translator (ru) Sung Kim (hunkim) — 1+/1+ — translator (ko) kstn (kastian) — 1+/0+ — translator (ru) Kohei Takada (koh7) — 2+/3+ — translator (ja) osmero — 1+/1+ — translator (ru) Remi Verchere (rverchere) — translator (fr) Snowcat8436 (Snowcat8436) — 4+/0+ — translator (ko) spmbt (spmbt) — 13+/0+ — translator (ru) Steven Liu (stevenlordiam) — 2+/1+ — translator (zh) Thomas Sungjin Kang (ujuc) — 6+/0+ — translator (ko) Valeria de Paiva (vcvpaiva) — 2+/0+ — translator (pt) Xu Chunyang (xuchunyang) — 13+/7+ — translator (zh) Contributors 0xCD — 4+/1+ 0xmohit — 2+/3+ Jiang Guoxi (374632897) — 3+/1+ Andrii (aaabramov) — 0+/1+ Ahmet Alp Balkan (ahmetb) — 1+/1+ Alexander Bodin (AlexanderBodin) — 0+/1+ Semir Patel (analogue) — 1+/1+ Andreas Hofmann (andreas-hofmann) — 2+/1+ Desmond Stonie (aneasystone) — 3+/8+ anna-4 — 2+/0+ Brad Beyenhof (augmentedfourth) — 0+/1+ b-jazz (b-jazz) — 1+/1+ bafoed — 0+/1+ Colas BROUX (brouxco) — 1+/2+ Alex Cabrera (cabreraalex) — 1+/1+ Chris Kuehl (chriskuehl) — 1+/1+ Christopher Biscardi (ChristopherBiscardi) — 0+/1+ Sihan Li (ClumsyLee) — 12+/1+ Corey Richardson (cmr) — 1+/3+ CodinCat (CodinCat) — 2+/1+ Colin Wang (colinwjd) — 0+/2+ Chris Rhodes (crr0004) — 1+/4+ Daniel t. (danasmera) — 0+/3+ Dmytro Danylevskyi (danylevskyi) — 1+/1+ Dave Loyall (daveloyall) — 2+/1+ Kirill (DDyst) — 0+/1+ Deborah Gertrude Digges (Deborah-Digges) — 1+/1+ Jamie Luck (delucks) — 2+/1+ Dillon Flamand (dflamand) — 0+/1+ Michael Diamond (dimo414) — 0+/4+ Vincent Wong (EaterOA) — 1+/1+ Veck Hsiao (fbukevin) — 0+/1+ Fernando Almeida (fernandoalmeida) — 8+/2+ Sami (fnzv) — 0+/1+ Gaga Pan (gaga5lala) — 0+/1+ Massimiliano Arione (garak) — 0+/1+ XinYu Zheng (gayu-mike) — 0+/1+ Konstantin Gribov (grossws) — 3+/6+ Ashhar Hasan (hashhar) — 0+/1+ Beau Hastings (hastinbe) — 1+/4+ Iliana Panagopoulou (hpanago) — 3+/2+ Space exploration enthusiast (Hunter-Github) — 0+/5+ Hyojin Kwak (hyojin) — 0+/1+ Ihor Dvoretskyi (idvoretskyi) — 2+/1+ Kevin Morales (iKenshu) — 3+/1+ Ilja Krauchanka (ikrauchanka) — 0+/1+ Sergey Isaev (isvforall) — 0+/1+ Igor Veksler (iveksl2) — 0+/1+ J Alan Brogan (jalanb) — 2+/3+ James Kolce (jameskolce) — 0+/1+ Dotan J. Nahum (jondot) — 0+/1+ Jesse Sightler (jsight) — 1+/1+ Konstantin Mikhailov (jtraub) — 1+/1+ Jakub Wilk (jwilk) — 2+/2+ Wael Nasreddine (kalbasit) — 1+/1+ Colin Chan (kalgynirae) — 1+/1+ Michalis Kargakis (kargakis) — 1+/1+ Kesu J (kesu) — 2+/3+ Takuma Yamaguchi (kumon) — 0+/1+ Dmytro Prokhorenkov (l13t) — 0+/1+ Mikhail Letunovskiy (l3xx) — 2+/1+ Lakshmipathi (Lakshmipathi) — 10+/1+ Pavel Zhukov (landgraf) — 1+/0+ lcmtwn — 0+/1+ Lampros Mountrakis (lmount) — 0+/1+ Luke Yeager (lukeyeager) — 0+/1+ TAKAGI Masahiro (m-takagi) — 0+/1+ Who? Me?! (mark-i-m) — 5+/1+ marocchino — 0+/1+ Matjaž Lipuš (matjaz) — 1+/1+ Mayra Cabrera (mayra-cabrera) — 0+/1+ Michael Barlow (michaelbarlow7) — 2+/1+ Jinhui-Lin (mintisan) — 0+/1+ Crisoforo Gaspar Hernández (mitogh) — 3+/1+ miuc (miuc) — 0+/2+ Michael Kwardakov (mkwardakov) — 7+/14+ Harry Moreno (morenoh149) — 1+/1+ Dongliang Mu (mudongliang) — 3+/10+ Lilian Besson (Naereen) — 2+/1+ Namgoo Lee (nglee) — 0+/1+ Serg Petrov (p12se) — 1+/0+ 王霄池(wangxiaochi) (picasso250) — 0+/1+ pravdomil (pravdomil) — 0+/1+ Rahul Kavale (rahulkavale) — 0+/1+ Rasmus Wriedt Larsen (RasmusWL) — 1+/1+ Riley Shaw (rileyjshaw) — 0+/1+ Ryan Delaney (rpdelaney) — 0+/2+ Haoxuan Li (Sagir1) — 0+/1+ Saksham Sharma (sakshamsharma) — 1+/3+ Semen Martynov (SemenMartynov) — 0+/1+ Kit Chan (shukitchan) — 2+/2+ Simarpreet Singh (simar7) — 1+/2+ snowme34 (snowme34) — 2+/1+ Soham Chakraborty (SohamChakraborty) — 0+/3+ Fabien Dubosson (StreakyCobra) — 1+/1+ Chengcheng Tang (tangchengcheng) — 0+/1+ taxusyew — 1+/2+ Timur (tim-teufel) — 4+/3+ Timotei Dolean (timotei) — 2+/1+ Haoyu Qiu (timothyqiu) — 4+/2+ René Ribaud (uggla) — 5+/10+ Joe Block (unixorn) — 0+/1+ vitzli — 1+/1+ Eduardo Rolim (vndmtrx) — 1+/1+ senhtry (w169q169) — 3+/1+ Evan Wong (wyf88) — 2+/2+ Okunev Yu Dmitry (xaionaro) — 1+/1+ yasuhiroki (yasuhiroki) — 2+/2+ Alex F. (youmee) — 1+/1+ Youngwoo Kim (youngwookim) — 0+/1+ yssmcl — 0+/1+ Zack Piper (zackp30) — 2+/1+ Aleksandr Zhuravlev (zelark) — 2+/1+ Xudong Zhang (zxdvd) — 0+/1+ Numbers link to commits/issues.For simplicity, this file is maintained only in English. If your name does not appear as you would like it above, verify your name on your GitHub profile.Also confirm that your commits are using the correct e-mail to it is linked to your profile. If you see inaccuracies or omissions, please file an issue, or edit the authors-info.yml file, regenerate, and file a PR. (This file was auto-generated by ghizmo assemble-authors.)]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%9A%84%E8%89%BA%E6%9C%AF%2Fadmin%2Fauthors-info%2F</url>
    <content type="text"><![CDATA[{"header":"This work is the result of the effort of many people around the world.\nContributors are listed in alphabetical order by GitHub login.\n\nSome contributors are also assigned roles as maintainers.\nThey have kindly agreed to review and help update future contributions for the translation or section they own.\n","footer":"Numbers link to commits/issues.\nFor simplicity, this file is maintained only in English.\n\nIf your name does not appear as you would like it above, verify your name on your GitHub profile.\nAlso confirm that your commits are using the correct e-mail to it is linked to your profile.\n\nIf you see inaccuracies or omissions, please file an issue, or edit the authors-info.yml file, regenerate, and file a PR.\n","exclude":"gitter-badger ReadmeCritic","roles":{"jlevy":"original author and project maintainer","ceoaliongroo":"translation maintainer (es)","aaossa":"translator (es)","BishopWolf":"translator (es)","doublemarket":"translation maintainer (ja)","Ungsik-Yun":"translation maintainer (ko)","Snowcat8436":"translator (ko)","ujuc":"translator (ko)","hunkim":"translator (ko)","niltonvasques":"translation maintainer (pt)","vcvpaiva":"translator (pt)","olegberman":"translation maintainer (ru)","spmbt":"translator (ru)","osmero":"translator (ru)","grigory-rechistov":"translator (ru)","kastian":"translator (ru)","githubashto":"translator (ru)","petk":"translation maintainer (sl)","Psycho7":"translation maintainer (zh)","xuchunyang":"translator (zh)","stevenlordiam":"translator (zh)","Armour":"translator (zh)","stepan0904":"translation (uk)","dmytro":"translation maintainer (uk)","francescomalatesta":"translation maintainer (it)","lsrom":"translation maintainer (cs)","ericguirbal":"translation maintainer (fr)","rverchere":"translator (fr)","kevingo":"translation maintainer (zh-Hant)","anna-d":"translation maintainer (el)","S1SYPHOS":"translation maintainer (de)","gernd":"translator (de)","dspinellis":"section maintainer (Windows)","mihaimaruseac":"translation maintainer (ro)","bgdnlp":"translator (ro)","23Pstars":"translation maintainer (id)","koh7":"translator (ja)"},"groups":[{"name":"Maintainers","members":["jlevy","ceoaliongroo","doublemarket","Ungsik-Yun","niltonvasques","olegberman","petk","Psycho7","stepan0904","dmytro","francescomalatesta","lsrom","ericguirbal","kevingo","anna-d","S1SYPHOS","dspinellis","mihaimaruseac","23Pstars"]},{"name":"Translators","members":["aaossa","BishopWolf","Snowcat8436","ujuc","hunkim","vcvpaiva","spmbt","osmero","grigory-rechistov","kastian","githubashto","xuchunyang","stevenlordiam","Armour","rverchere","gernd","bgdnlp","koh7"]},{"name":"Contributors"}]}]]></content>
  </entry>
  <entry>
    <title><![CDATA[命令行的艺术]]></title>
    <url>%2F%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%9A%84%E8%89%BA%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[#🌍 Čeština ∙ Deutsch ∙ Ελληνικά ∙ English ∙ Español ∙ Français ∙ Indonesia ∙ Italiano ∙ 日本語 ∙ 한국어 ∙ Português ∙ Română ∙ Русский ∙ Slovenščina ∙ Українська ∙ 简体中文 ∙ 繁體中文 命令行的艺术 前言 基础 日常使用 文件及数据处理 系统调试 单行脚本 冷门但有用 仅限 OS X 系统 仅限 Windows 系统 更多资源 免责声明 熟练使用命令行是一种常常被忽视，或被认为难以掌握的技能，但实际上，它会提高你作为工程师的灵活性以及生产力。本文是一份我在 Linux 上工作时，发现的一些命令行使用技巧的摘要。有些技巧非常基础，而另一些则相当复杂，甚至晦涩难懂。这篇文章并不长，但当你能够熟练掌握这里列出的所有技巧时，你就学会了很多关于命令行的东西了。 这篇文章是许多作者和译者共同的成果。这里的部分内容首次出现于 Quora，但已经迁移到了 Github，并由众多高手做出了许多改进。如果你在本文中发现了错误或者存在可以改善的地方，请贡献你的一份力量。 前言涵盖范围： 这篇文章不仅能帮助刚接触命令行的新手，而且对具有经验的人也大有裨益。本文致力于做到覆盖面广（涉及所有重要的内容），具体（给出具体的最常用的例子），以及简洁（避免冗余的内容，或是可以在其他地方轻松查到的细枝末节）。在特定应用场景下，本文的内容属于基本功或者能帮助您节约大量的时间。 本文主要为 Linux 所写，但在仅限 OS X 系统章节和仅限 Windows 系统章节中也包含有对应操作系统的内容。除去这两个章节外，其它的内容大部分均可在其他类 Unix 系统或 OS X，甚至 Cygwin 中得到应用。 本文主要关注于交互式 Bash，但也有很多技巧可以应用于其他 shell 和 Bash 脚本当中。 除去“标准的”Unix 命令，本文还包括了一些依赖于特定软件包的命令（前提是它们具有足够的价值）。 注意事项： 为了能在一页内展示尽量多的东西，一些具体的信息可以在引用的页面中找到。我们相信机智的你知道如何使用 Google 或者其他搜索引擎来查阅到更多的详细信息。文中部分命令需要您使用 apt-get，yum，dnf，pacman， pip 或 brew（以及其它合适的包管理器）来安装依赖的程序。 遇到问题的话，请尝试使用 Explainshell 去获取相关命令、参数、管道等内容的解释。 基础 学习 Bash 的基础知识。具体地，在命令行中输入 man bash 并至少全文浏览一遍; 它理解起来很简单并且不冗长。其他的 shell 可能很好用，但 Bash 的功能已经足够强大并且到几乎总是可用的（ 如果你只学习 zsh，fish 或其他的 shell 的话，在你自己的设备上会显得很方便，但过度依赖这些功能会给您带来不便，例如当你需要在服务器上工作时）。 熟悉至少一个基于文本的编辑器。通常而言 Vim （vi） 会是你最好的选择，毕竟在终端中编辑文本时 Vim 是最好用的工具（甚至大部分情况下 Vim 要比 Emacs、大型 IDE 或是炫酷的编辑器更好用）。 学会如何使用 man 命令去阅读文档。学会使用 apropos 去查找文档。知道有些命令并不对应可执行文件，而是在 Bash 内置好的，此时可以使用 help 和 help -d 命令获取帮助信息。你可以用 type 命令 来判断这个命令到底是可执行文件、shell 内置命令还是别名。 学会使用 &gt; 和 &lt; 来重定向输出和输入，学会使用 | 来重定向管道。明白 &gt; 会覆盖了输出文件而 &gt;&gt; 是在文件末添加。了解标准输出 stdout 和标准错误 stderr。 学会使用通配符 * （或许再算上 ? 和 […]） 和引用以及引用中 &#39; 和 &quot; 的区别（后文中有一些具体的例子）。 熟悉 Bash 中的任务管理工具：&amp;，ctrl-z，ctrl-c，jobs，fg，bg，kill 等。 学会使用 ssh 进行远程命令行登录，最好知道如何使用 ssh-agent，ssh-add 等命令来实现基础的无密码认证登录。 学会基本的文件管理工具：ls 和 ls -l （了解 ls -l 中每一列代表的意义），less，head，tail 和 tail -f （甚至 less +F），ln 和 ln -s （了解硬链接与软链接的区别），chown，chmod，du （硬盘使用情况概述：du -hs *）。 关于文件系统的管理，学习 df，mount，fdisk，mkfs，lsblk。知道 inode 是什么（与 ls -i 和 df -i 等命令相关）。 学习基本的网络管理工具：ip 或 ifconfig，dig。 学习并使用一种版本控制管理系统，例如 git。 熟悉正则表达式，学会使用 grep／egrep，它们的参数中 -i，-o，-v，-A，-B 和 -C 这些是很常用并值得认真学习的。 学会使用 apt-get，yum，dnf 或 pacman （具体使用哪个取决于你使用的 Linux 发行版）来查找和安装软件包。并确保你的环境中有 pip 来安装基于 Python 的命令行工具 （接下来提到的部分程序使用 pip 来安装会很方便）。 日常使用 在 Bash 中，可以通过按 Tab 键实现自动补全参数，使用 ctrl-r 搜索命令行历史记录（按下按键之后，输入关键字便可以搜索，重复按下 ctrl-r 会向后查找匹配项，按下 Enter 键会执行当前匹配的命令，而按下右方向键会将匹配项放入当前行中，不会直接执行，以便做出修改）。 在 Bash 中，可以按下 ctrl-w 删除你键入的最后一个单词，ctrl-u 可以删除行内光标所在位置之前的内容，alt-b 和 alt-f 可以以单词为单位移动光标，ctrl-a 可以将光标移至行首，ctrl-e 可以将光标移至行尾，ctrl-k 可以删除光标至行尾的所有内容，ctrl-l 可以清屏。键入 man readline 可以查看 Bash 中的默认快捷键。内容有很多，例如 alt-. 循环地移向前一个参数，而 alt-* 可以展开通配符。 你喜欢的话，可以执行 set -o vi 来使用 vi 风格的快捷键，而执行 set -o emacs 可以把它改回来。 为了便于编辑长命令，在设置你的默认编辑器后（例如 export EDITOR=vim），ctrl-x ctrl-e 会打开一个编辑器来编辑当前输入的命令。在 vi 风格下快捷键则是 escape-v。 键入 history 查看命令行历史记录，再用 !n（n 是命令编号）就可以再次执行。其中有许多缩写，最有用的大概就是 !$， 它用于指代上次键入的参数，而 !! 可以指代上次键入的命令了（参考 man 页面中的“HISTORY EXPANSION”）。不过这些功能，你也可以通过快捷键 ctrl-r 和 alt-. 来实现。 cd 命令可以切换工作路径，输入 cd ~ 可以进入 home 目录。要访问你的 home 目录中的文件，可以使用前缀 ~（例如 ~/.bashrc）。在 sh 脚本里则用环境变量 $HOME 指代 home 目录的路径。 回到前一个工作路径：cd -。 如果你输入命令的时候中途改了主意，按下 alt-# 在行首添加 # 把它当做注释再按下回车执行（或者依次按下 ctrl-a， #， enter）。这样做的话，之后借助命令行历史记录，你可以很方便恢复你刚才输入到一半的命令。 使用 xargs （ 或 parallel）。他们非常给力。注意到你可以控制每行参数个数（-L）和最大并行数（-P）。如果你不确定它们是否会按你想的那样工作，先使用 xargs echo 查看一下。此外，使用 -I{} 会很方便。例如： 12find . -name '*.py' | xargs grep some_functioncat hosts | xargs -I&#123;&#125; ssh root@&#123;&#125; hostname pstree -p 以一种优雅的方式展示进程树。 使用 pgrep 和 pkill 根据名字查找进程或发送信号（-f 参数通常有用）。 了解你可以发往进程的信号的种类。比如，使用 kill -STOP [pid] 停止一个进程。使用 man 7 signal 查看详细列表。 使用 nohup 或 disown 使一个后台进程持续运行。 使用 netstat -lntp 或 ss -plat 检查哪些进程在监听端口（默认是检查 TCP 端口; 添加参数 -u 则检查 UDP 端口）或者 lsof -iTCP -sTCP:LISTEN -P -n (这也可以在 OS X 上运行)。 lsof 来查看开启的套接字和文件。 使用 uptime 或 w 来查看系统已经运行多长时间。 使用 alias 来创建常用命令的快捷形式。例如：alias ll=&#39;ls -latr&#39; 创建了一个新的命令别名 ll。 可以把别名、shell 选项和常用函数保存在 ~/.bashrc，具体看下这篇文章。这样做的话你就可以在所有 shell 会话中使用你的设定。 把环境变量的设定以及登陆时要执行的命令保存在 ~/.bash_profile。而对于从图形界面启动的 shell 和 cron 启动的 shell，则需要单独配置文件。 要想在几台电脑中同步你的配置文件（例如 .bashrc 和 .bash_profile），可以借助 Git。 当变量和文件名中包含空格的时候要格外小心。Bash 变量要用引号括起来，比如 &quot;$FOO&quot;。尽量使用 -0 或 -print0 选项以便用 NULL 来分隔文件名，例如 locate -0 pattern | xargs -0 ls -al 或 find / -print0 -type d | xargs -0 ls -al。如果 for 循环中循环访问的文件名含有空字符（空格、tab 等字符），只需用 IFS=$&#39;\n&#39; 把内部字段分隔符设为换行符。 在 Bash 脚本中，使用 set -x 去调试输出（或者使用它的变体 set -v，它会记录原始输入，包括多余的参数和注释）。尽可能地使用严格模式：使用 set -e 令脚本在发生错误时退出而不是继续运行；使用 set -u 来检查是否使用了未赋值的变量；试试 set -o pipefail，它可以监测管道中的错误。当牵扯到很多脚本时，使用 trap 来检测 ERR 和 EXIT。一个好的习惯是在脚本文件开头这样写，这会使它能够检测一些错误，并在错误发生时中断程序并输出信息： 12set -euo pipefailtrap "echo 'error: Script failed: see failed command above'" ERR 在 Bash 脚本中，子 shell（使用括号 (...)）是一种组织参数的便捷方式。一个常见的例子是临时地移动工作路径，代码如下： 123# do something in current dir(cd /some/other/dir &amp;&amp; other-command)# continue in original dir 在 Bash 中，变量有许多的扩展方式。${name:?error message} 用于检查变量是否存在。此外，当 Bash 脚本只需要一个参数时，可以使用这样的代码 input_file=${1:?usage: $0 input_file}。在变量为空时使用默认值：${name:-default}。如果你要在之前的例子中再加一个（可选的）参数，可以使用类似这样的代码 output_file=${2:-logfile}，如果省略了 $2，它的值就为空，于是 output_file 就会被设为 logfile。数学表达式：i=$(( (i + 1) % 5 ))。序列：{1..10}。截断字符串：${var%suffix} 和 ${var#prefix}。例如，假设 var=foo.pdf，那么 echo ${var%.pdf}.txt 将输出 foo.txt。 使用括号扩展（{…}）来减少输入相似文本，并自动化文本组合。这在某些情况下会很有用，例如 mv foo.{txt,pdf} some-dir（同时移动两个文件），cp somefile{,.bak}（会被扩展成 cp somefile somefile.bak）或者 mkdir -p test-{a,b,c}/subtest-{1,2,3}（会被扩展成所有可能的组合，并创建一个目录树）。 通过使用 &lt;(some command) 可以将输出视为文件。例如，对比本地文件 /etc/hosts 和一个远程文件： 1diff /etc/hosts &lt;(ssh somehost cat /etc/hosts) 编写脚本时，你可能会想要把代码都放在大括号里。缺少右括号的话，代码就会因为语法错误而无法执行。如果你的脚本是要放在网上分享供他人使用的，这样的写法就体现出它的好处了，因为这样可以防止下载不完全代码被执行。 123&#123; # 在这里写代码&#125; 了解 Bash 中的“here documents”，例如 cat &lt;&lt;EOF ...。 在 Bash 中，同时重定向标准输出和标准错误：some-command &gt;logfile 2&gt;&amp;1 或者 some-command &amp;&gt;logfile。通常，为了保证命令不会在标准输入里残留一个未关闭的文件句柄捆绑在你当前所在的终端上，在命令后添加 &lt;/dev/null 是一个好习惯。 使用 man ascii 查看具有十六进制和十进制值的ASCII表。man unicode，man utf-8，以及 man latin1 有助于你去了解通用的编码信息。 使用 screen 或 tmux 来使用多份屏幕，当你在使用 ssh 时（保存 session 信息）将尤为有用。而 byobu 可以为它们提供更多的信息和易用的管理工具。另一个轻量级的 session 持久化解决方案是 dtach。 ssh 中，了解如何使用 -L 或 -D（偶尔需要用 -R）开启隧道是非常有用的，比如当你需要从一台远程服务器上访问 web 页面。 对 ssh 设置做一些小优化可能是很有用的，例如这个 ~/.ssh/config 文件包含了防止特定网络环境下连接断开、压缩数据、多通道等选项： 1234567TCPKeepAlive=yesServerAliveInterval=15ServerAliveCountMax=6Compression=yesControlMaster autoControlPath /tmp/%r@%h:%pControlPersist yes 一些其他的关于 ssh 的选项是与安全相关的，应当小心翼翼的使用。例如你应当只能在可信任的网络中启用 StrictHostKeyChecking=no，ForwardAgent=yes。 考虑使用 mosh 作为 ssh 的替代品，它使用 UDP 协议。它可以避免连接被中断并且对带宽需求更小，但它需要在服务端做相应的配置。 获取八进制形式的文件访问权限（修改系统设置时通常需要，但 ls 的功能不那么好用并且通常会搞砸），可以使用类似如下的代码： 1stat -c '%A %a %n' /etc/timezone 使用 percol 或者 fzf 可以交互式地从另一个命令输出中选取值。 使用 fpp（PathPicker）可以与基于另一个命令(例如 git）输出的文件交互。 将 web 服务器上当前目录下所有的文件（以及子目录）暴露给你所处网络的所有用户，使用： python -m SimpleHTTPServer 7777 （使用端口 7777 和 Python 2）或python -m http.server 7777 （使用端口 7777 和 Python 3）。 以其他用户的身份执行命令，使用 sudo。默认以 root 用户的身份执行；使用 -u 来指定其他用户。使用 -i 来以该用户登录（需要输入你自己的密码）。 将 shell 切换为其他用户，使用 su username 或者 sudo - username。加入 - 会使得切换后的环境与使用该用户登录后的环境相同。省略用户名则默认为 root。切换到哪个用户，就需要输入哪个用户的密码。 了解命令行的 128K 限制。使用通配符匹配大量文件名时，常会遇到“Argument list too long”的错误信息。（这种情况下换用 find 或 xargs 通常可以解决。） 当你需要一个基本的计算器时，可以使用 python 解释器（当然你要用 python 的时候也是这样）。例如： 12&gt;&gt;&gt; 2+35 文件及数据处理 在当前目录下通过文件名查找一个文件，使用类似于这样的命令：find . -iname &#39;*something*&#39;。在所有路径下通过文件名查找文件，使用 locate something （但注意到 updatedb 可能没有对最近新建的文件建立索引，所以你可能无法定位到这些未被索引的文件）。 使用 ag 在源代码或数据文件里检索（grep -r 同样可以做到，但相比之下 ag 更加先进）。 将 HTML 转为文本：lynx -dump -stdin。 Markdown，HTML，以及所有文档格式之间的转换，试试 pandoc。 当你要处理棘手的 XML 时候，xmlstarlet 算是上古时代流传下来的神器。 使用 jq 处理 JSON。 使用 shyaml 处理 YAML。 要处理 Excel 或 CSV 文件的话，csvkit 提供了 in2csv，csvcut，csvjoin，csvgrep 等方便易用的工具。 当你要处理 Amazon S3 相关的工作的时候，s3cmd 是一个很方便的工具而 s4cmd 的效率更高。Amazon 官方提供的 aws 以及 saws 是其他 AWS 相关工作的基础，值得学习。 了解如何使用 sort 和 uniq，包括 uniq 的 -u 参数和 -d 参数，具体内容在后文单行脚本节中。另外可以了解一下 comm。 了解如何使用 cut，paste 和 join 来更改文件。很多人都会使用 cut，但遗忘了 join。 了解如何运用 wc 去计算新行数（-l），字符数（-m），单词数（-w）以及字节数（-c）。 了解如何使用 tee 将标准输入复制到文件甚至标准输出，例如 ls -al | tee file.txt。 要进行一些复杂的计算，比如分组、逆序和一些其他的统计分析，可以考虑使用 datamash。 注意到语言设置（中文或英文等）对许多命令行工具有一些微妙的影响，比如排序的顺序和性能。大多数 Linux 的安装过程会将 LANG 或其他有关的变量设置为符合本地的设置。要意识到当你改变语言设置时，排序的结果可能会改变。明白国际化可能会使 sort 或其他命令运行效率下降许多倍。某些情况下（例如集合运算）你可以放心的使用 export LC_ALL=C 来忽略掉国际化并按照字节来判断顺序。 你可以单独指定某一条命令的环境，只需在调用时把环境变量设定放在命令的前面，例如 TZ=Pacific/Fiji date 可以获取斐济的时间。 了解如何使用 awk 和 sed 来进行简单的数据处理。 参阅 One-liners 获取示例。 替换一个或多个文件中出现的字符串： 1perl -pi.bak -e 's/old-string/new-string/g' my-files-*.txt 使用 repren 来批量重命名文件，或是在多个文件中搜索替换内容。（有些时候 rename 命令也可以批量重命名，但要注意，它在不同 Linux 发行版中的功能并不完全一样。） 123456# 将文件、目录和内容全部重命名 foo -&gt; bar:repren --full --preserve-case --from foo --to bar .# 还原所有备份文件 whatever.bak -&gt; whatever:repren --renames --from '(.*)\.bak' --to '\1' *.bak# 用 rename 实现上述功能（若可用）:rename 's/\.bak$//' *.bak 根据 man 页面的描述，rsync 是一个快速且非常灵活的文件复制工具。它闻名于设备之间的文件同步，但其实它在本地情况下也同样有用。在安全设置允许下，用 rsync 代替 scp 可以实现文件续传，而不用重新从头开始。它同时也是删除大量文件的最快方法之一： 1mkdir empty &amp;&amp; rsync -r --delete empty/ some-dir &amp;&amp; rmdir some-dir 若要在复制文件时获取当前进度，可使用 pv，pycp，progress，rsync --progress。若所执行的复制为block块拷贝，可以使用 dd status=progress。 使用 shuf 可以以行为单位来打乱文件的内容或从一个文件中随机选取多行。 了解 sort 的参数。显示数字时，使用 -n 或者 -h 来显示更易读的数（例如 du -h 的输出）。明白排序时关键字的工作原理（-t 和 -k）。例如，注意到你需要 -k1，1 来仅按第一个域来排序，而 -k1 意味着按整行排序。稳定排序（sort -s）在某些情况下很有用。例如，以第二个域为主关键字，第一个域为次关键字进行排序，你可以使用 sort -k1，1 | sort -s -k2，2。 如果你想在 Bash 命令行中写 tab 制表符，按下 ctrl-v [Tab] 或键入 $&#39;\t&#39; （后者可能更好，因为你可以复制粘贴它）。 标准的源代码对比及合并工具是 diff 和 patch。使用 diffstat 查看变更总览数据。注意到 diff -r 对整个文件夹有效。使用 diff -r tree1 tree2 | diffstat 查看变更的统计数据。vimdiff 用于比对并编辑文件。 对于二进制文件，使用 hd，hexdump 或者 xxd 使其以十六进制显示，使用 bvi，hexedit 或者 biew 来进行二进制编辑。 同样对于二进制文件，strings（包括 grep 等工具）可以帮助在二进制文件中查找特定比特。 制作二进制差分文件（Delta 压缩），使用 xdelta3。 使用 iconv 更改文本编码。需要更高级的功能，可以使用 uconv，它支持一些高级的 Unicode 功能。例如，这条命令移除了所有重音符号： 1uconv -f utf-8 -t utf-8 -x '::Any-Lower; ::Any-NFD; [:Nonspacing Mark:] &gt;; ::Any-NFC; ' &lt; input.txt &gt; output.txt 拆分文件可以使用 split（按大小拆分）和 csplit（按模式拆分）。 操作日期和时间表达式，可以用 dateutils 中的 dateadd、datediff、strptime 等工具。 使用 zless、zmore、zcat 和 zgrep 对压缩过的文件进行操作。 文件属性可以通过 chattr 进行设置，它比文件权限更加底层。例如，为了保护文件不被意外删除，可以使用不可修改标记：sudo chattr +i /critical/directory/or/file 使用 getfacl 和 setfacl 以保存和恢复文件权限。例如： 12getfacl -R /some/path &gt; permissions.txtsetfacl --restore=permissions.txt 为了高效地创建空文件，请使用 truncate（创建稀疏文件），fallocate（用于 ext4，xfs，btrf 和 ocfs2 文件系统），xfs_mkfile（适用于几乎所有的文件系统，包含在 xfsprogs 包中），mkfile（用于类 Unix 操作系统，比如 Solaris 和 Mac OS）。 系统调试 curl 和 curl -I 可以被轻松地应用于 web 调试中，它们的好兄弟 wget 也是如此，或者也可以试试更潮的 httpie。 获取 CPU 和硬盘的使用状态，通常使用使用 top（htop 更佳），iostat 和 iotop。而 iostat -mxz 15 可以让你获悉 CPU 和每个硬盘分区的基本信息和性能表现。 使用 netstat 和 ss 查看网络连接的细节。 dstat 在你想要对系统的现状有一个粗略的认识时是非常有用的。然而若要对系统有一个深度的总体认识，使用 glances，它会在一个终端窗口中向你提供一些系统级的数据。 若要了解内存状态，运行并理解 free 和 vmstat 的输出。值得留意的是“cached”的值，它指的是 Linux 内核用来作为文件缓存的内存大小，而与空闲内存无关。 Java 系统调试则是一件截然不同的事，一个可以用于 Oracle 的 JVM 或其他 JVM 上的调试的技巧是你可以运行 kill -3 &lt;pid&gt; 同时一个完整的栈轨迹和堆概述（包括 GC 的细节）会被保存到标准错误或是日志文件。JDK 中的 jps，jstat，jstack，jmap 很有用。SJK tools 更高级。 使用 mtr 去跟踪路由，用于确定网络问题。 用 ncdu 来查看磁盘使用情况，它比寻常的命令，如 du -sh *，更节省时间。 查找正在使用带宽的套接字连接或进程，使用 iftop 或 nethogs。 ab 工具（Apache 中自带）可以简单粗暴地检查 web 服务器的性能。对于更复杂的负载测试，使用 siege。 wireshark，tshark 和 ngrep 可用于复杂的网络调试。 了解 strace 和 ltrace。这俩工具在你的程序运行失败、挂起甚至崩溃，而你却不知道为什么或你想对性能有个总体的认识的时候是非常有用的。注意 profile 参数（-c）和附加到一个运行的进程参数 （-p）。 了解使用 ldd 来检查共享库。但是永远不要在不信任的文件上运行。 了解如何运用 gdb 连接到一个运行着的进程并获取它的堆栈轨迹。 学会使用 /proc。它在调试正在出现的问题的时候有时会效果惊人。比如：/proc/cpuinfo，/proc/meminfo，/proc/cmdline，/proc/xxx/cwd，/proc/xxx/exe，/proc/xxx/fd/，/proc/xxx/smaps（这里的 xxx 表示进程的 id 或 pid）。 当调试一些之前出现的问题的时候，sar 非常有用。它展示了 cpu、内存以及网络等的历史数据。 关于更深层次的系统分析以及性能分析，看看 stap（SystemTap），perf)，以及sysdig。 查看你当前使用的系统，使用 uname，uname -a（Unix／kernel 信息）或者 lsb_release -a（Linux 发行版信息）。 无论什么东西工作得很欢乐（可能是硬件或驱动问题）时可以试试 dmesg。 如果你删除了一个文件，但通过 du 发现没有释放预期的磁盘空间，请检查文件是否被进程占用： lsof | grep deleted | grep &quot;filename-of-my-big-file&quot; 单行脚本一些命令组合的例子： 当你需要对文本文件做集合交、并、差运算时，sort 和 uniq 会是你的好帮手。具体例子请参照代码后面的，此处假设 a 与 b 是两内容不同的文件。这种方式效率很高，并且在小文件和上 G 的文件上都能运用（注意尽管在 /tmp 在一个小的根分区上时你可能需要 -T 参数，但是实际上 sort 并不被内存大小约束），参阅前文中关于 LC_ALL 和 sort 的 -u 参数的部分。 123sort a b | uniq &gt; c # c 是 a 并 bsort a b | uniq -d &gt; c # c 是 a 交 bsort a b b | uniq -u &gt; c # c 是 a - b 使用 grep . *（每行都会附上文件名）或者 head -100 *（每个文件有一个标题）来阅读检查目录下所有文件的内容。这在检查一个充满配置文件的目录（如 /sys、/proc、/etc）时特别好用。 计算文本文件第三列中所有数的和（可能比同等作用的 Python 代码快三倍且代码量少三倍）： 1awk '&#123; x += $3 &#125; END &#123; print x &#125;' myfile 如果你想在文件树上查看大小/日期，这可能看起来像递归版的 ls -l 但比 ls -lR 更易于理解： 1find . -type f -ls 假设你有一个类似于 web 服务器日志文件的文本文件，并且一个确定的值只会出现在某些行上，假设一个 acct_id 参数在 URI 中。如果你想计算出每个 acct_id 值有多少次请求，使用如下代码： 1egrep -o 'acct_id=[0-9]+' access.log | cut -d= -f2 | sort | uniq -c | sort -rn 要持续监测文件改动，可以使用 watch，例如检查某个文件夹中文件的改变，可以用 watch -d -n 2 &#39;ls -rtlh | tail&#39;；或者在排查 WiFi 设置故障时要监测网络设置的更改，可以用 watch -d -n 2 ifconfig。 运行这个函数从这篇文档中随机获取一条技巧（解析 Markdown 文件并抽取项目）： 12345678function taocl() &#123; curl -s https://raw.githubusercontent.com/jlevy/the-art-of-command-line/master/README-zh.md| pandoc -f markdown -t html | iconv -f 'utf-8' -t 'unicode' | xmlstarlet fo --html --dropdtd | xmlstarlet sel -t -v "(html/body/ul/li[count(p)&gt;0])[$RANDOM mod last()+1]" | xmlstarlet unesc | fmt -80&#125; 冷门但有用 expr：计算表达式或正则匹配 m4：简单的宏处理器 yes：多次打印字符串 cal：漂亮的日历 env：执行一个命令（脚本文件中很有用） printenv：打印环境变量（调试时或在写脚本文件时很有用） look：查找以特定字符串开头的单词或行 cut，paste 和 join：数据修改 fmt：格式化文本段落 pr：将文本格式化成页／列形式 fold：包裹文本中的几行 column：将文本格式化成多个对齐、定宽的列或表格 expand 和 unexpand：制表符与空格之间转换 nl：添加行号 seq：打印数字 bc：计算器 factor：分解因数 gpg：加密并签名文件 toe：terminfo 入口列表 nc：网络调试及数据传输 socat：套接字代理，与 netcat 类似 slurm：网络流量可视化 dd：文件或设备间传输数据 file：确定文件类型 tree：以树的形式显示路径和文件，类似于递归的 ls stat：文件信息 time：执行命令，并计算执行时间 timeout：在指定时长范围内执行命令，并在规定时间结束后停止进程 lockfile：使文件只能通过 rm -f 移除 logrotate： 切换、压缩以及发送日志文件 watch：重复运行同一个命令，展示结果并／或高亮有更改的部分 when-changed：当检测到文件更改时执行指定命令。参阅 inotifywait 和 entr。 tac：反向输出文件 shuf：文件中随机选取几行 comm：一行一行的比较排序过的文件 strings：从二进制文件中抽取文本 tr：转换字母 iconv 或 uconv：文本编码转换 split 和 csplit：分割文件 sponge：在写入前读取所有输入，在读取文件后再向同一文件写入时比较有用，例如 grep -v something some-file | sponge some-file units：将一种计量单位转换为另一种等效的计量单位（参阅 /usr/share/units/definitions.units） apg：随机生成密码 xz：高比例的文件压缩 ldd：动态库信息 nm：提取 obj 文件中的符号 ab 或 wrk：web 服务器性能分析 strace：调试系统调用 mtr：更好的网络调试跟踪工具 cssh：可视化的并发 shell rsync：通过 ssh 或本地文件系统同步文件和文件夹 wireshark 和 tshark：抓包和网络调试工具 ngrep：网络层的 grep host 和 dig：DNS 查找 lsof：列出当前系统打开文件的工具以及查看端口信息 dstat：系统状态查看 glances：高层次的多子系统总览 iostat：硬盘使用状态 mpstat： CPU 使用状态 vmstat： 内存使用状态 htop：top 的加强版 last：登入记录 w：查看处于登录状态的用户 id：用户/组 ID 信息 sar：系统历史数据 iftop 或 nethogs：套接字及进程的网络利用情况 ss：套接字数据 dmesg：引导及系统错误信息 sysctl： 在内核运行时动态地查看和修改内核的运行参数 hdparm：SATA/ATA 磁盘更改及性能分析 lsblk：列出块设备信息：以树形展示你的磁盘以及磁盘分区信息 lshw，lscpu，lspci，lsusb 和 dmidecode：查看硬件信息，包括 CPU、BIOS、RAID、显卡、USB设备等 lsmod 和 modinfo：列出内核模块，并显示其细节 fortune，ddate 和 sl：额，这主要取决于你是否认为蒸汽火车和莫名其妙的名人名言是否“有用” 仅限 OS X 系统以下是仅限于 OS X 系统的技巧。 用 brew （Homebrew）或者 port （MacPorts）进行包管理。这些可以用来在 OS X 系统上安装以上的大多数命令。 用 pbcopy 复制任何命令的输出到桌面应用，用 pbpaste 粘贴输入。 若要在 OS X 终端中将 Option 键视为 alt 键（例如在上面介绍的 alt-b、alt-f 等命令中用到），打开 偏好设置 -&gt; 描述文件 -&gt; 键盘 并勾选“使用 Option 键作为 Meta 键”。 用 open 或者 open -a /Applications/Whatever.app 使用桌面应用打开文件。 Spotlight：用 mdfind 搜索文件，用 mdls 列出元数据（例如照片的 EXIF 信息）。 注意 OS X 系统是基于 BSD UNIX 的，许多命令（例如 ps，ls，tail，awk，sed）都和 Linux 中有微妙的不同（ Linux 很大程度上受到了 System V-style Unix 和 GNU 工具影响）。你可以通过标题为 “BSD General Commands Manual” 的 man 页面发现这些不同。在有些情况下 GNU 版本的命令也可能被安装（例如 gawk 和 gsed 对应 GNU 中的 awk 和 sed ）。如果要写跨平台的 Bash 脚本，避免使用这些命令（例如，考虑 Python 或者 perl ）或者经过仔细的测试。 用 sw_vers 获取 OS X 的版本信息。 仅限 Windows 系统以下是仅限于 Windows 系统的技巧。 在 Winodws 下获取 Unix 工具 可以安装 Cygwin 允许你在 Microsoft Windows 中体验 Unix shell 的威力。这样的话，本文中介绍的大多数内容都将适用。 在 Windows 10 上，你可以使用 Bash on Ubuntu on Windows，它提供了一个熟悉的 Bash 环境，包含了不少 Unix 命令行工具。好处是它允许 Linux 上编写的程序在 Windows 上运行，而另一方面，Windows 上编写的程序却无法在 Bash 命令行中运行。 如果你在 Windows 上主要想用 GNU 开发者工具（例如 GCC），可以考虑 MinGW 以及它的 MSYS 包，这个包提供了例如 bash，gawk，make 和 grep 的工具。MSYS 并不包含所有可以与 Cygwin 媲美的特性。当制作 Unix 工具的原生 Windows 端口时 MinGW 将特别地有用。 另一个在 Windows 下实现接近 Unix 环境外观效果的选项是 Cash。注意在此环境下只有很少的 Unix 命令和命令行可用。 实用 Windows 命令行工具 可以使用 wmic 在命令行环境下给大部分 Windows 系统管理任务编写脚本以及执行这些任务。 Windows 实用的原生命令行网络工具包括 ping，ipconfig，tracert，和 netstat。 可以使用 Rundll32 命令来实现许多有用的 Windows 任务 。 Cygwin 技巧 通过 Cygwin 的包管理器来安装额外的 Unix 程序。 使用 mintty 作为你的命令行窗口。 要访问 Windows 剪贴板，可以通过 /dev/clipboard。 运行 cygstart 以通过默认程序打开一个文件。 要访问 Windows 注册表，可以使用 regtool。 注意 Windows 驱动器路径 C:\ 在 Cygwin 中用 /cygdrive/c 代表，而 Cygwin 的 / 代表 Windows 中的 C:\cygwin。要转换 Cygwin 和 Windows 风格的路径可以用 cygpath。这在需要调用 Windows 程序的脚本里很有用。 学会使用 wmic，你就可以从命令行执行大多数 Windows 系统管理任务，并编成脚本。 要在 Windows 下获得 Unix 的界面和体验，另一个办法是使用 Cash。需要注意的是，这个环境支持的 Unix 命令和命令行参数非常少。 要在 Windows 上获取 GNU 开发者工具（比如 GCC）的另一个办法是使用 MinGW 以及它的 MSYS 软件包，该软件包提供了 bash、gawk、make、grep 等工具。然而 MSYS 提供的功能没有 Cygwin 完善。MinGW 在创建 Unix 工具的 Windows 原生移植方面非常有用。 更多资源 awesome-shell：一份精心组织的命令行工具及资源的列表。 awesome-osx-command-line：一份针对 OS X 命令行的更深入的指南。 Strict mode：为了编写更好的脚本文件。 shellcheck：一个静态 shell 脚本分析工具，本质上是 bash／sh／zsh 的 lint。 Filenames and Pathnames in Shell：有关如何在 shell 脚本里正确处理文件名的细枝末节。 Data Science at the Command Line：用于数据科学的一些命令和工具，摘自同名书籍。 免责声明除去特别小的工作，你编写的代码应当方便他人阅读。能力往往伴随着责任，你 有能力 在 Bash 中玩一些奇技淫巧并不意味着你应该去做！;) 授权条款 本文使用授权协议 Creative Commons Attribution-ShareAlike 4.0 International License。]]></content>
      <categories>
        <category>IT技术</category>
      </categories>
      <tags>
        <tag>命令行 command-line</tag>
      </tags>
  </entry>
</search>
